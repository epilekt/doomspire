=== FILE STRUCTURE (relative to D:\doomspire) ===
.\gradle.properties
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java
.\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java
.\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java
.\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\S2C_SyncStats.java
.\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java
.\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\impl\FireBoltSpell.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\MobStatsProvider.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java
.\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java
.\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java
.\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json
.\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java
.\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java
.\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java
.\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java
.\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java
.\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java
.\grimfate\src\main\java\com\doomspire\grimfate\events\StaffAttackEvents.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java
.\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java
.\grimfate\src\main\java\com\doomspire\grimfate\loot\RustyRingDropModifier.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastStaffBoltPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java
.\grimfate\src\main\java\com\doomspire\grimfate\spell\FireboltEntity.java
.\grimfate\src\main\resources\assets\grimfate\lang\en_us.json
.\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json
.\grimfate\src\main\resources\assets\grimfate\models\item\bolt.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rusty_ring.json
.\grimfate\src\main\resources\assets\grimfate\models\item\staff.json
.\grimfate\src\main\resources\data\grimfate\balance\attributes.json
.\grimfate\src\main\resources\data\grimfate\balance\levels.json
.\grimfate\src\main\resources\data\grimfate\balance\spells.json
.\grimfate\src\main\resources\data\grimfate\loot_modifiers\rusty_ring.json
.\grimfate\src\main\resources\data\grimfate\recipes\staff.json
.\grimfate\src\main\resources\data\grimfate\tags\items\staves.json
.\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json
n=== CONCATENATED CONTENTS ===n
----- BEGIN FILE: .\gradle.properties -----
# ------------------------------
# Gradle performance
# ------------------------------
org.gradle.jvmargs=-Xmx2G
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configuration-cache=true

# ------------------------------
# Minecraft / NeoForge versions
# ------------------------------
minecraft_version=1.21.1
minecraft_version_range=[1.21.1,)
neo_version=21.1.208
loader_version_range=[1,)

# ------------------------------
# Parchment (mappings & docs)
# ------------------------------
parchment_minecraft_version=1.21.1
parchment_mappings_version=2024.11.17

# ------------------------------
# Mod metadata (???????? ??? grimfate)
# ------------------------------
mod_id=grimfate
mod_name=Grimfate
mod_version=0.0.1
mod_license=All Rights Reserved
mod_group_id=com.doomspire
mod_authors=Epilekt
mod_description=RPG ??? Grimfate. ????????? ??????, ??????, ????? ? ????? ????????? ? Minecraft.

# ------------------------------
# Mod metadata (?????????? grimcore)
# ------------------------------
core_mod_id=grimcore
core_mod_name=Grimcore
core_mod_version=0.0.1
core_mod_group_id=com.doomspire
core_mod_authors=Epilekt
core_mod_description=Core library with shared RPG systems for Grimfate

n----- END FILE: .\gradle.properties -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.*;

public final class MobStatCalculator {
    private MobStatCalculator(){}

    public static StatSnapshot calculate(MobStatsAttachment att) {
        StatSnapshot s = new StatSnapshot();

        int vit  = att.getAttribute(Attributes.VITALITY);
        int str  = att.getAttribute(Attributes.STRENGTH);
        int intl = att.getAttribute(Attributes.INTELLIGENCE);
        int dex  = att.getAttribute(Attributes.DEXTERITY);
        int eva  = att.getAttribute(Attributes.EVASION);

        // База для мобов (потом вынесем в датапак balance)
        s.maxHealth   = 60 + vit * 20;
        s.regenHealth = 0 + vit * 1;

        // у мобов нет маны
        s.maxMana   = 0;
        s.regenMana = 0;

        // Базовый урон (только физика для старта)
        s.damage.put(DamageTypes.PHYS_MELEE, 3f + str * 0.5f);
        s.damage.put(DamageTypes.PHYS_RANGED, dex * 0.5f);

        // Элементы оставим 0 по умолчанию (будут у кастомных мобов)
        s.damage.putIfAbsent(DamageTypes.FIRE, 0f);
        s.damage.putIfAbsent(DamageTypes.FROST, 0f);
        s.damage.putIfAbsent(DamageTypes.LIGHTNING, 0f);
        s.damage.putIfAbsent(DamageTypes.POISON, 0f);

        // Защита/уклон/крит как старт
        s.resistances.put(ResistTypes.PHYS, 0.0f);
        s.resistances.put(ResistTypes.FIRE, 0.0f);
        s.resistances.put(ResistTypes.FROST, 0.0f);
        s.resistances.put(ResistTypes.LIGHTNING, 0.0f);
        s.resistances.put(ResistTypes.POISON, 0.0f);

        s.evasionChance = Math.min(0.5f, eva * 0.005f); // 0.5% за очко, кап 50%
        s.critChance = 0f;
        s.critDamage = 0.25f;

        return s;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.*;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.EnumMap;

public class MobStatsAttachment {
    private final EnumMap<Attributes, Integer> attributes = new EnumMap<>(Attributes.class);
    private int currentHealth = 100;
    private boolean dirty = true;
    private StatSnapshot snapshot = new StatSnapshot();

    public MobStatsAttachment() {
        // у мобов нет маны → пропускаем SPIRIT
        for (Attributes a : Attributes.values()) {
            if (a != Attributes.SPIRIT) attributes.put(a, 0);
        }
    }

    public int getAttribute(Attributes attr) {
        return attributes.getOrDefault(attr, 0);
    }
    public void setAttribute(Attributes attr, int value) {
        if (attr == Attributes.SPIRIT) return; // игнор
        attributes.put(attr, Math.max(0, value)); dirty = true;
    }
    public void addAttribute(Attributes attr, int delta) {
        if (attr == Attributes.SPIRIT) return;
        attributes.put(attr, Math.max(0, getAttribute(attr) + delta)); dirty = true;
    }

    public int getCurrentHealth() { return currentHealth; }
    public void setCurrentHealth(int v) {
        int max = (int)Math.max(1, getSnapshot().maxHealth);
        currentHealth = Math.max(0, Math.min(v, max));
    }

    public StatSnapshot getSnapshot() {
        if (dirty) {
            snapshot = MobStatCalculator.calculate(this);
            dirty = false;
        }
        return snapshot;
    }
    public void markDirty() { dirty = true; }

    // --- net sync ---
    public static final StreamCodec<RegistryFriendlyByteBuf, MobStatsAttachment> STREAM_CODEC =
            StreamCodec.of(MobStatsAttachment::encode, MobStatsAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, MobStatsAttachment att) {
        buf.writeVarInt(att.currentHealth);
        // порядок атрибутов фиксируем:
        for (Attributes a : Attributes.values()) {
            if (a == Attributes.SPIRIT) continue;
            buf.writeVarInt(att.getAttribute(a));
        }
    }
    private static MobStatsAttachment decode(RegistryFriendlyByteBuf buf) {
        MobStatsAttachment att = new MobStatsAttachment();
        att.currentHealth = buf.readVarInt();
        for (Attributes a : Attributes.values()) {
            if (a == Attributes.SPIRIT) continue;
            att.attributes.put(a, buf.readVarInt());
        }
        att.dirty = true;
        return att;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java -----
package com.doomspire.grimcore.attach;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.resources.ResourceLocation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Лоадаут спеллов игрока: 6 слотов + пер-слот кулдауны.
 * Сериализация:
 *  - CODEC (в NBT/сейв): slots как список строк (пустая строка = null), cooldowns как список int.
 *  - STREAM_CODEC (в сеть): на слот пишем флаг наличия + ResourceLocation (если есть), затем cooldowns.
 */
public final class PlayerLoadoutAttachment {

    public static final int SLOTS = 6;

    private final ResourceLocation[] slots = new ResourceLocation[SLOTS];
    private final int[] cooldown = new int[SLOTS];

    public PlayerLoadoutAttachment() {}

    // -------- API --------
    public ResourceLocation get(int slot) { check(slot); return slots[slot]; }
    public void set(int slot, ResourceLocation id) { check(slot); slots[slot] = id; }

    public int getCooldown(int slot) { check(slot); return cooldown[slot]; }
    public void setCooldown(int slot, int ticks) { check(slot); cooldown[slot] = Math.max(0, ticks); }

    public void tickDown() {
        for (int i = 0; i < SLOTS; i++) if (cooldown[i] > 0) cooldown[i]--;
    }

    public void clearAll() {
        Arrays.fill(slots, null);
        Arrays.fill(cooldown, 0);
    }

    private static void check(int s) {
        if (s < 0 || s >= SLOTS) throw new IndexOutOfBoundsException("slot " + s);
    }

    // -------- CODEC (persist) --------
    public static final Codec<PlayerLoadoutAttachment> CODEC = RecordCodecBuilder.create(inst -> inst.group(
            // список строк длиной SLOTS; "" означает пустой слот
            Codec.list(Codec.STRING).fieldOf("slots").forGetter(att -> {
                List<String> out = new ArrayList<>(SLOTS);
                for (int i = 0; i < SLOTS; i++) out.add(att.slots[i] != null ? att.slots[i].toString() : "");
                return out;
            }),
            Codec.list(Codec.INT).fieldOf("cooldowns").forGetter(att -> {
                List<Integer> out = new ArrayList<>(SLOTS);
                for (int i = 0; i < SLOTS; i++) out.add(att.cooldown[i]);
                return out;
            })
    ).apply(inst, (slotStrings, cds) -> {
        PlayerLoadoutAttachment att = new PlayerLoadoutAttachment();
        int n = Math.min(SLOTS, slotStrings.size());
        for (int i = 0; i < n; i++) {
            String s = slotStrings.get(i);
            if (s != null && !s.isEmpty()) {
                ResourceLocation rl = ResourceLocation.tryParse(s);
                if (rl != null) att.slots[i] = rl;
            }
        }
        int m = Math.min(SLOTS, cds.size());
        for (int i = 0; i < m; i++) att.cooldown[i] = Math.max(0, cds.get(i));
        return att;
    }));

    // -------- STREAM_CODEC (network) --------
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerLoadoutAttachment> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public PlayerLoadoutAttachment decode(RegistryFriendlyByteBuf buf) {
                    PlayerLoadoutAttachment att = new PlayerLoadoutAttachment();
                    for (int i = 0; i < SLOTS; i++) {
                        boolean has = buf.readBoolean();
                        if (has) att.slots[i] = ResourceLocation.STREAM_CODEC.decode(buf);
                    }
                    for (int i = 0; i < SLOTS; i++) {
                        att.cooldown[i] = buf.readVarInt();
                    }
                    return att;
                }

                @Override
                public void encode(RegistryFriendlyByteBuf buf, PlayerLoadoutAttachment att) {
                    for (int i = 0; i < SLOTS; i++) {
                        ResourceLocation rl = att.slots[i];
                        buf.writeBoolean(rl != null);
                        if (rl != null) ResourceLocation.STREAM_CODEC.encode(buf, rl);
                    }
                    for (int i = 0; i < SLOTS; i++) {
                        buf.writeVarInt(att.cooldown[i]);
                    }
                }
            };
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimcore.xp.LevelTable;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

/**
 * Персистентный прогресс игрока (уровень/опыт/кап). Сохраняется через CODEC.
 * Клиенту отдаём лёгкий снапшот PlayerProgress.
 */
public class PlayerProgressAttachment {

    private int level;
    private int exp;
    private int expCap;

    public PlayerProgressAttachment() {
        this.level = 1;
        this.exp = 0;
        this.expCap = LevelTable.expForLevel(1); // кап до 2-го уровня
    }

    public int level() { return level; }
    public int exp() { return exp; }
    public int expCap() { return expCap; }

    /** Возвращает число полученных уровней (для выдачи очков атрибутов). */
    public int addExp(int amount) {
        if (amount <= 0) return 0;
        int gained = 0;
        exp += amount;
        while (exp >= expCap && level < LevelTable.maxLevel()) {
            exp -= expCap;
            level++;
            expCap = LevelTable.expForLevel(level);
            gained++;
        }
        return gained;
    }

    /** Снимок для HUD/клиента. */
    public PlayerProgress toSnapshot() {
        return new PlayerProgress(level, exp, expCap);
    }

    // ---------- Persist (save/load) ----------
    public static final Codec<PlayerProgressAttachment> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.fieldOf("level").forGetter(PlayerProgressAttachment::level),
            Codec.INT.fieldOf("exp").forGetter(PlayerProgressAttachment::exp),
            Codec.INT.fieldOf("exp_cap").forGetter(PlayerProgressAttachment::expCap)
    ).apply(i, (lvl, e, cap) -> {
        PlayerProgressAttachment a = new PlayerProgressAttachment();
        a.level = Math.max(1, lvl);
        a.exp = Math.max(0, e);
        a.expCap = Math.max(1, cap);
        return a;
    }));

    // ---------- Network (instant sync, если шлём кастомный пакет) ----------
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerProgressAttachment> STREAM_CODEC =
            StreamCodec.of(PlayerProgressAttachment::encode, PlayerProgressAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, PlayerProgressAttachment a) {
        buf.writeVarInt(a.level);
        buf.writeVarInt(a.exp);
        buf.writeVarInt(a.expCap);
    }

    private static PlayerProgressAttachment decode(RegistryFriendlyByteBuf buf) {
        PlayerProgressAttachment a = new PlayerProgressAttachment();
        a.level  = buf.readVarInt();
        a.exp    = buf.readVarInt();
        a.expCap = buf.readVarInt();
        return a;
    }
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatCalculator;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.world.entity.player.Player;
import com.doomspire.grimcore.datapack.BalanceData;
import java.util.EnumMap;
import java.util.Locale;

/**
 * Attachment игрока: очки атрибутов, текущие ресурсы и кэш агрегированных статов.
 * Без устаревших API. Для сети используем StreamCodec (NeoForge/Mojang 1.21.1).
 */
public class PlayerStatsAttachment {

    // ---- Текущие ресурсы (кастомные полосы) ----
    private int currentHealth = 100;
    private int currentMana   = 100;

    // ---- Распределённые очки по атрибутам ----
    private final EnumMap<Attributes, Integer> attributes = new EnumMap<>(Attributes.class);

    // ---- Очки, нераспределённые игроком ----
    private int unspentPoints = 0;

    // ---- Кэш снапшота и грязный флаг ----
    private StatSnapshot snapshot = new StatSnapshot();
    private boolean dirty = true;

    public PlayerStatsAttachment() {
        for (Attributes a : Attributes.values()) {
            attributes.put(a, 0);
        }
    }

    // ===================== API =====================

    public int getCurrentHealth() { return currentHealth; }
    public int getCurrentMana()   { return currentMana; }

    public void setCurrentHealth(int v) {
        int max = (int) Math.max(1, getSnapshot().maxHealth);
        currentHealth = Math.max(0, Math.min(v, max));
    }

    public void setCurrentMana(int v) {
        int max = (int) Math.max(1, getSnapshot().maxMana);
        currentMana = Math.max(0, Math.min(v, max));
    }

    public void markDirty() { this.dirty = true; }

    public int getAttribute(Attributes attr) {
        return attributes.getOrDefault(attr, 0);
    }

    public void setAttribute(Attributes attr, int value) {
        attributes.put(attr, Math.max(0, value));
        dirty = true;
    }

    public void addAttribute(Attributes attr, int delta) {
        attributes.put(attr, Math.max(0, getAttribute(attr) + delta));
        dirty = true;
    }

    public int getUnspentPoints() { return unspentPoints; }
    public void setUnspentPoints(int v) { unspentPoints = Math.max(0, v); }
    public void addUnspentPoints(int amount) { if (amount > 0) unspentPoints += amount; }

    public int hardCapFor(Attributes attr) {
        return BalanceData.attrs().cap(attr);
    }

    /** Потратить 1 очко в атрибут с проверкой капа. Возвращает true при успехе. */
    public boolean tryAllocatePoint(Attributes attr) {
        if (unspentPoints <= 0) return false;
        int cap = hardCapFor(attr);
        int cur = getAttribute(attr);
        if (cur >= cap) return false;

        setAttribute(attr, cur + 1);
        unspentPoints--;
        return true;
    }

    public StatSnapshot getSnapshot() {
        if (dirty) {
            snapshot = StatCalculator.calculate(this);
            dirty = false;
        }
        return snapshot;
    }

    // ===================== NET (StreamCodec) =====================
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerStatsAttachment> STREAM_CODEC =
            StreamCodec.of(PlayerStatsAttachment::encode, PlayerStatsAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, PlayerStatsAttachment att) {
        buf.writeVarInt(att.unspentPoints);
        buf.writeVarInt(att.currentHealth);
        buf.writeVarInt(att.currentMana);
        for (Attributes a : Attributes.values()) {
            buf.writeVarInt(att.getAttribute(a));
        }
    }

    private static PlayerStatsAttachment decode(RegistryFriendlyByteBuf buf) {
        PlayerStatsAttachment att = new PlayerStatsAttachment();
        att.unspentPoints = buf.readVarInt();
        att.currentHealth = buf.readVarInt();
        att.currentMana   = buf.readVarInt();
        for (Attributes a : Attributes.values()) {
            att.attributes.put(a, buf.readVarInt());
        }
        att.dirty = true;
        return att;
    }

    // ===================== Утилиты =====================

    /** Достаёт аттачмент у игрока. */
    public static PlayerStatsAttachment get(Player player) {
        return player.getData(ModAttachments.PLAYER_STATS.get());
    }

    /** Пытается распарсить строковый id атрибута в enum (без краша). */
    public static Attributes parseAttrId(String id) {
        if (id == null) return null;
        try {
            return Attributes.valueOf(id.trim().toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException ex) {
            return null;
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java -----
package com.doomspire.grimcore.combat;

import com.doomspire.grimcore.stat.DamageTypes;
import net.minecraft.world.entity.LivingEntity;

import java.util.EnumMap;

/**
 * Контекст одного удара/заклинания.
 * Заполняется перед вызовом DamageEngine.
 */
public class DamageContext {
    public final LivingEntity attacker;
    public final LivingEntity target;
    public final EnumMap<DamageTypes, Float> damageMap = new EnumMap<>(DamageTypes.class);
    public boolean critical = false;

    public DamageContext(LivingEntity attacker, LivingEntity target) {
        this.attacker = attacker;
        this.target = target;
        for (DamageTypes t : DamageTypes.values()) damageMap.put(t, 0f);
    }

    public DamageContext add(DamageTypes type, float amount) {
        damageMap.put(type, damageMap.get(type) + amount);
        return this;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java -----
package com.doomspire.grimcore.combat;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.DamageTypes;
import com.doomspire.grimcore.stat.ResistTypes;
import com.doomspire.grimcore.stat.StatSnapshot;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.LivingEntity;

import java.util.concurrent.ThreadLocalRandom;

public final class DamageEngine {
    private DamageEngine() {}

    public static float resolveAndApply(DamageContext ctx) {
        final LivingEntity target = ctx.target;

        // --- читаем снапшот цели (игрок или моб) ---
        StatSnapshot tSnap;
        boolean targetIsPlayer = target.getData(ModAttachments.PLAYER_STATS.get()) != null;
        if (targetIsPlayer) {
            PlayerStatsAttachment tAtt = target.getData(ModAttachments.PLAYER_STATS.get());
            if (tAtt == null) return 0f;
            tSnap = tAtt.getSnapshot();
            // Evade
            if (ThreadLocalRandom.current().nextFloat() < tSnap.evasionChance) {
                return 0f;
            }
        } else {
            MobStatsAttachment tAtt = target.getData(ModAttachments.MOB_STATS.get());
            if (tAtt == null) return 0f;
            tSnap = tAtt.getSnapshot();
            if (ThreadLocalRandom.current().nextFloat() < tSnap.evasionChance) {
                return 0f;
            }
        }

        // --- снапшот атакера (для крита/воровства) ---
        StatSnapshot aSnap = null;
        if (ctx.attacker != null) {
            var aPlayer = ctx.attacker.getData(ModAttachments.PLAYER_STATS.get());
            if (aPlayer != null) aSnap = aPlayer.getSnapshot();
            else {
                var aMob = ctx.attacker.getData(ModAttachments.MOB_STATS.get());
                if (aMob != null) aSnap = aMob.getSnapshot();
            }
        }

        float total = 0f;

        for (var entry : ctx.damageMap.entrySet()) {
            DamageTypes type = entry.getKey();
            float dmg = entry.getValue();
            if (dmg <= 0f) continue;

            // crit
            if (aSnap != null) {
                boolean rollCrit = ctx.critical || ThreadLocalRandom.current().nextFloat() < aSnap.critChance;
                if (rollCrit) {
                    dmg *= (1f + Math.max(0f, aSnap.critDamage)); // +50% => 0.5
                }
            }

            // resist mapping
            float resist = switch (type) {
                case PHYS_MELEE, PHYS_RANGED -> tSnap.resistances.getOrDefault(ResistTypes.PHYS, 0f);
                case FIRE -> tSnap.resistances.getOrDefault(ResistTypes.FIRE, 0f);
                case FROST -> tSnap.resistances.getOrDefault(ResistTypes.FROST, 0f);
                case LIGHTNING -> tSnap.resistances.getOrDefault(ResistTypes.LIGHTNING, 0f);
                case POISON -> tSnap.resistances.getOrDefault(ResistTypes.POISON, 0f);
            };
            resist = Math.max(0f, Math.min(resist, 0.90f)); // хард-кап 90%
            dmg *= (1f - resist);

            total += Math.max(0f, dmg);
        }

        // lifesteal/manasteal по суммарному урону
        if (aSnap != null && total > 0f && ctx.attacker instanceof LivingEntity attackerLe) {
            int heal = Math.round(total * Math.max(0f, aSnap.lifesteal));
            int mana = Math.round(total * Math.max(0f, aSnap.manasteal));

            var aPlayer = attackerLe.getData(ModAttachments.PLAYER_STATS.get());
            if (aPlayer != null) {
                boolean changed = false;
                if (heal > 0) {
                    aPlayer.setCurrentHealth(aPlayer.getCurrentHealth() + heal);
                    changed = true;
                }
                if (mana > 0) {
                    aPlayer.setCurrentMana(aPlayer.getCurrentMana() + mana);
                    changed = true;
                }
                if (changed) {
                    aPlayer.markDirty();
                    if (attackerLe instanceof ServerPlayer spA) {
                        GrimcoreNetworking.syncPlayerStats(spA, aPlayer);
                    }
                }
            } else {
                var aMob = attackerLe.getData(ModAttachments.MOB_STATS.get());
                if (aMob != null && heal > 0) {
                    aMob.setCurrentHealth(aMob.getCurrentHealth() + heal);
                    aMob.markDirty();
                }
            }
        }

        // применяем к цели
        int applied = Math.max(0, Math.round(total));
        if (applied > 0) {
            if (targetIsPlayer) {
                PlayerStatsAttachment tAtt = target.getData(ModAttachments.PLAYER_STATS.get());
                tAtt.setCurrentHealth(tAtt.getCurrentHealth() - applied);
                tAtt.markDirty();
                if (target instanceof ServerPlayer spT) {
                    GrimcoreNetworking.syncPlayerStats(spT, tAtt); // мгновенный HUD-синк цели
                }
            } else {
                MobStatsAttachment tAtt = target.getData(ModAttachments.MOB_STATS.get());
                tAtt.setCurrentHealth(tAtt.getCurrentHealth() - applied);
                tAtt.markDirty();
            }
        }

        return applied;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java -----
package com.doomspire.grimcore.combat;

import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.damagesource.DamageTypes;

import java.util.Map;

public final class EnvironmentalDamage {
    private EnvironmentalDamage(){}

    // проценты от maxHP (0..1)
    private static final Map<net.minecraft.resources.ResourceKey<net.minecraft.world.damagesource.DamageType>, Float> PERCENTS = Map.of(
            DamageTypes.FALL, 0.15f,
            DamageTypes.DROWN, 0.10f,
            DamageTypes.LAVA, 0.25f,
            DamageTypes.ON_FIRE, 0.08f,
            DamageTypes.IN_FIRE, 0.12f,
            DamageTypes.HOT_FLOOR, 0.10f,
            DamageTypes.SWEET_BERRY_BUSH, 0.04f,
            DamageTypes.OUTSIDE_BORDER, 1.0f
    );

    public static Float percentFor(DamageSource src) {
        for (var e : PERCENTS.entrySet()) {
            if (src.is(e.getKey())) return e.getValue();
        }
        return null;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.commands.GrimfateCommands;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.RegisterCommandsEvent;

@EventBusSubscriber(modid = Grimcore.MODID)
public final class CommandBusHandlers {
    private CommandBusHandlers(){}

    @SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent e) {
        GrimfateCommands.register(e.getDispatcher());
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java -----
package com.doomspire.grimcore.commands;

import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;

import java.util.Collection;
import java.util.List;

public final class GrimfateCommands {
    private GrimfateCommands(){}

    public static void register(CommandDispatcher<CommandSourceStack> d) {
        d.register(
                Commands.literal("grimfate")
                        .requires(src -> src.hasPermission(2)) // только операторы по умолчанию
                        .then(Commands.literal("give")
                                .then(Commands.literal("exp")
                                        // вариант: /grimfate give exp <amount>
                                        .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                                .executes(ctx -> {
                                                    ServerPlayer target = ctx.getSource().getPlayerOrException();
                                                    int amount = IntegerArgumentType.getInteger(ctx, "amount");
                                                    return giveExp(ctx.getSource(), List.of(target), amount);
                                                })
                                                // вариант: /grimfate give exp <amount> <targets>
                                                .then(Commands.argument("targets", EntityArgument.players())
                                                        .executes(ctx -> {
                                                            Collection<ServerPlayer> targets = EntityArgument.getPlayers(ctx, "targets");
                                                            int amount = IntegerArgumentType.getInteger(ctx, "amount");
                                                            return giveExp(ctx.getSource(), targets, amount);
                                                        })
                                                )
                                        )
                                )
                        )
        );
    }

    private static int giveExp(CommandSourceStack src, Collection<ServerPlayer> targets, int amount) {
        int totalLevels = 0;

        for (ServerPlayer player : targets) {
            PlayerProgressAttachment prog = player.getData(ModAttachments.PLAYER_PROGRESS.get());
            PlayerStatsAttachment    stats= player.getData(ModAttachments.PLAYER_STATS.get());
            if (prog == null || stats == null) continue;

            int levels = prog.addExp(amount);
            if (levels > 0) {
                stats.addUnspentPoints(levels);
                stats.markDirty();
                GrimcoreNetworking.syncPlayerStats(player, stats);         // мгновенный HUD (очки/полосы)
            }
            ProgressNetworking.syncPlayerProgress(player, prog);            // мгновенный HUD (XP/уровень)

            totalLevels += levels;
            src.sendSuccess(() -> Component.literal(
                    "Given " + amount + " XP to " + player.getGameProfile().getName() +
                            (levels > 0 ? (" (+" + levels + " level)") : "")), true);
        }

        return Math.max(1, totalLevels);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java -----
package com.doomspire.grimcore.config;

import net.neoforged.neoforge.common.ModConfigSpec;

public final class CoreCommonConfig {
    //    public static final ModConfigSpec SPEC;
    //    public static final ModConfigSpec.BooleanValue PULL_ENABLED;
    //    public static final ModConfigSpec.IntValue PULL_RADIUS;     // 0..4
    //    public static final ModConfigSpec.IntValue MAX_CONTAINERS;  // safety cap
    //
            //    static {
        //        ModConfigSpec.Builder b = new ModConfigSpec.Builder();
        //        PULL_ENABLED   = b.comment("Enable QoL pulling from nearby containers").define("pullEnabled", true);
        //        PULL_RADIUS    = b.comment("Pull radius (0..4)").defineInRange("pullRadius", 3, 0, 4);
        //        MAX_CONTAINERS = b.comment("Safety cap for scanned containers").defineInRange("maxContainers", 24, 1, 128);
        //        SPEC = b.build();
        //    }

    private CoreCommonConfig() {}
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.spell.api.SpellSchool;
import com.mojang.serialization.Codec;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;

/**
 * Разрешённые дисциплины (школы), при которых предмет активирует бонусы/эффект.
 * Например: только WARCRY/TECHNIQUE.
 *
 * Иммутабельный компонент с корректными equals/hashCode.
 */
public final class ClassRestrictionComponent {
    private final EnumSet<SpellSchool> allowed; // внутреннее хранилище

    public ClassRestrictionComponent(Set<SpellSchool> allowed) {
        EnumSet<SpellSchool> s = allowed == null || allowed.isEmpty()
                ? EnumSet.noneOf(SpellSchool.class)
                : EnumSet.copyOf(allowed);
        this.allowed = s;
    }

    /** Пустой набор = разрешено всем. */
    public boolean isAllowed(SpellSchool school) {
        return allowed.isEmpty() || allowed.contains(school);
    }

    /** Неизменяемое представление. */
    public Set<SpellSchool> allowed() {
        return Collections.unmodifiableSet(allowed);
    }

    public static final Codec<SpellSchool> SCHOOL_CODEC =
            Codec.STRING.xmap(s -> SpellSchool.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<ClassRestrictionComponent> CODEC =
            SCHOOL_CODEC.listOf().xmap(list -> new ClassRestrictionComponent(Set.copyOf(list)),
                    c -> java.util.List.copyOf(c.allowed()));

    public static final StreamCodec<RegistryFriendlyByteBuf, ClassRestrictionComponent> STREAM_CODEC =
            StreamCodec.of(
                    (buf, c) -> {
                        ByteBufCodecs.VAR_INT.encode(buf, c.allowed.size());
                        for (var s : c.allowed) ByteBufCodecs.fromCodec(SCHOOL_CODEC).encode(buf, s);
                    },
                    buf -> {
                        int n = ByteBufCodecs.VAR_INT.decode(buf);
                        EnumSet<SpellSchool> set = EnumSet.noneOf(SpellSchool.class);
                        for (int i = 0; i < n; i++) set.add(ByteBufCodecs.fromCodec(SCHOOL_CODEC).decode(buf));
                        return new ClassRestrictionComponent(set);
                    }
            );

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ClassRestrictionComponent that)) return false;
        return Objects.equals(allowed, that.allowed);
    }

    @Override
    public int hashCode() {
        return Objects.hash(allowed);
    }

    @Override
    public String toString() {
        return "ClassRestrictionComponent" + allowed;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.stat.Attributes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;
import java.util.Objects;

/**
 * Иммутабельный data-component с бонусами к атрибутам, напр.:
 * {"strength": 3, "intelligence": 2}
 *
 * Требования NeoForge к компонентам:
 *  - иммутабельность
 *  - корректные equals/hashCode
 */
public final class StatBonusComponent {

    private final EnumMap<Attributes, Integer> bonus; // иммутабельное содержимое

    public StatBonusComponent(Map<Attributes, Integer> map) {
        EnumMap<Attributes, Integer> tmp = new EnumMap<>(Attributes.class);
        if (map != null) {
            for (var e : map.entrySet()) {
                if (e.getKey() != null) {
                    int v = e.getValue() == null ? 0 : e.getValue();
                    if (v != 0) tmp.put(e.getKey(), v);
                }
            }
        }
        this.bonus = tmp.isEmpty() ? new EnumMap<>(Attributes.class) : new EnumMap<>(tmp);
    }

    /** Возвращает бонус для заданного атрибута (0 если не задан). */
    public int get(Attributes a) {
        Integer v = bonus.get(a);
        return v == null ? 0 : v;
    }

    /** Неизменяемое представление всех бонусов. */
    public Map<Attributes, Integer> all() {
        return Collections.unmodifiableMap(bonus);
    }

    // --- Codec/StreamCodec ---
    public static final Codec<Attributes> ATTR_CODEC =
            Codec.STRING.xmap(s -> Attributes.valueOf(s.toUpperCase()), a -> a.name().toLowerCase());

    public static final Codec<StatBonusComponent> CODEC =
            Codec.unboundedMap(ATTR_CODEC, Codec.INT)
                    .xmap(StatBonusComponent::new, c -> c.all());

    public static final StreamCodec<RegistryFriendlyByteBuf, StatBonusComponent> STREAM_CODEC =
            StreamCodec.of(
                    (buf, c) -> {
                        var map = c.bonus;
                        ByteBufCodecs.VAR_INT.encode(buf, map.size());
                        for (var e : map.entrySet()) {
                            ByteBufCodecs.fromCodec(ATTR_CODEC).encode(buf, e.getKey());
                            ByteBufCodecs.VAR_INT.encode(buf, e.getValue());
                        }
                    },
                    buf -> {
                        int n = ByteBufCodecs.VAR_INT.decode(buf);
                        EnumMap<Attributes, Integer> m = new EnumMap<>(Attributes.class);
                        for (int i = 0; i < n; i++) {
                            Attributes a = ByteBufCodecs.fromCodec(ATTR_CODEC).decode(buf);
                            int v = ByteBufCodecs.VAR_INT.decode(buf);
                            if (v != 0) m.put(a, v);
                        }
                        return new StatBonusComponent(m);
                    }
            );

    // --- equals/hashCode (по содержимому карты) ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof StatBonusComponent that)) return false;
        return Objects.equals(bonus, that.bonus);
    }

    @Override
    public int hashCode() {
        return Objects.hash(bonus);
    }

    @Override
    public String toString() {
        return "StatBonusComponent" + bonus;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java -----
package com.doomspire.grimcore.data;

import com.doomspire.grimcore.data.component.StatBonusComponent;
import com.doomspire.grimcore.stat.Attributes;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.player.Player;

public final class ItemBonusHelper {
    private ItemBonusHelper(){}

    public static int sum(Player p, Attributes attr) {
        int total = 0;
        for (var slot : EquipmentSlot.values()) {
            var stack = p.getItemBySlot(slot);
            if (stack.isEmpty()) continue;
            var comp = stack.get(ModDataComponents.STAT_BONUS.get());
            if (comp != null) total += comp.get(attr);
        }
        return total;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java -----
package com.doomspire.grimcore.data;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.data.component.ClassRestrictionComponent;
import com.doomspire.grimcore.data.component.StatBonusComponent;
import net.minecraft.core.registries.Registries;
import net.minecraft.core.component.DataComponentType;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModDataComponents {
    private ModDataComponents() {}

    public static final DeferredRegister<DataComponentType<?>> COMPONENT_TYPES =
            DeferredRegister.create(Registries.DATA_COMPONENT_TYPE, Grimcore.MODID);

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<StatBonusComponent>> STAT_BONUS =
            COMPONENT_TYPES.register("stat_bonus", () ->
                    DataComponentType.<StatBonusComponent>builder()
                            .persistent(StatBonusComponent.CODEC)
                            .networkSynchronized(StatBonusComponent.STREAM_CODEC)
                            .build()
            );

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<ClassRestrictionComponent>> CLASS_RESTRICTION =
            COMPONENT_TYPES.register("class_restriction", () ->
                    DataComponentType.<ClassRestrictionComponent>builder()
                            .persistent(ClassRestrictionComponent.CODEC)
                            .networkSynchronized(ClassRestrictionComponent.STREAM_CODEC)
                            .build()
            );

    public static void init(net.neoforged.bus.api.IEventBus modBus) {
        COMPONENT_TYPES.register(modBus);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import net.minecraft.resources.ResourceLocation;
import org.jetbrains.annotations.Nullable;

/** Глобальный снимок data-driven баланса (обновляется при перезагрузке датапаков). */
public final class Balance {
    private Balance() {}

    private static volatile LevelsCurve levels = LevelsCurve.defaults();
    private static volatile AttributesBalance attributes = AttributesBalance.defaults();
    private static volatile SpellTuning spells = SpellTuning.defaults();

    public static void set(LevelsCurve l, AttributesBalance a, SpellTuning s) {
        levels = (l != null) ? l : LevelsCurve.defaults();
        attributes = (a != null) ? a : AttributesBalance.defaults();
        spells = (s != null) ? s : SpellTuning.defaults();
    }

    public static LevelsCurve levels() { return levels; }
    public static AttributesBalance attributes() { return attributes; }
    public static SpellTuning spells() { return spells; }

    public static @Nullable SpellTuning.Entry getSpellEntry(ResourceLocation id) {
        return spells.byId().get(id);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.doomspire.grimcore.stat.Attributes;
import com.mojang.logging.LogUtils;
import org.slf4j.Logger;

import java.util.EnumMap;
import java.util.Map;

/**
 * Глобальный кэш загруженных из datapack'ов балансовых таблиц.
 * Потокобезопасность: доступ только с сервера-треда при reload/старте.
 */
public final class BalanceData {
    private static final Logger LOG = LogUtils.getLogger();

    // Текущие активные значения
    private static volatile LevelsCurve levelsCurve = LevelsCurve.defaults();
    private static volatile AttributesBalance attributes = AttributesBalance.defaults();
    private static volatile SpellTuning spellTuning = SpellTuning.defaults();

    private BalanceData() {}

    public static LevelsCurve levels() { return levelsCurve; }
    public static AttributesBalance attrs() { return attributes; }
    public static SpellTuning spells() { return spellTuning; }

    /** Вызывается из BalanceReloadListener после успешного парсинга JSON. */
    static void apply(LevelsCurve lv, AttributesBalance ab, SpellTuning st) {
        if (lv != null) levelsCurve = lv;
        if (ab != null) attributes = ab;
        if (st != null) spellTuning = st;
        LOG.info("[Grim] Balance data applied: levels={}, attrs={}, spells={}",
                levelsCurve.summary(), attributes.summary(), spellTuning.summary());
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.mojang.logging.LogUtils;
import com.mojang.serialization.Codec;
import com.mojang.serialization.JsonOps;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.packs.resources.ResourceManager;
import net.minecraft.server.packs.resources.SimplePreparableReloadListener;
import net.minecraft.util.profiling.ProfilerFiller;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.event.AddReloadListenerEvent;
import org.slf4j.Logger;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;

/**
 * Читает JSON из:
 *  - data/grimfate/balance/levels.json
 *  - data/grimfate/balance/attributes.json
 *  - data/grimfate/balance/spells.json
 * и применяет в BalanceData.
 *
 * 1.21.1 / NeoForge: регистрируемся через AddReloadListenerEvent.
 */
public final class BalanceReloadListener extends SimplePreparableReloadListener<BalanceReloadListener.Data> {
    private static final Logger LOG = LogUtils.getLogger();

    /** Снэпшот подготовленных данных. */
    public record Data(LevelsCurve levels, AttributesBalance attrs, SpellTuning spells) {}

    /** Регистрация серверного reload-listener’а. */
    @SubscribeEvent
    public static void onAddReloadListeners(AddReloadListenerEvent e) {
        e.addListener(new BalanceReloadListener());
    }

    @Override
    protected Data prepare(ResourceManager rm, ProfilerFiller profiler) {
        var levels = readJson(rm, "grimfate", "balance/levels.json", LevelsCurve.CODEC);
        var attrs  = readJson(rm, "grimfate", "balance/attributes.json", AttributesBalance.CODEC);
        var spells = readJson(rm, "grimfate", "balance/spells.json", SpellTuning.CODEC);
        com.doomspire.grimcore.datapack.Balance.set(levels, attrs, spells);
        return new Data(levels, attrs, spells);
    }

    @Override
    protected void apply(Data data, ResourceManager rm, ProfilerFiller profiler) {
        BalanceData.apply(
                data.levels() != null ? data.levels() : LevelsCurve.defaults(),
                data.attrs()  != null ? data.attrs()  : AttributesBalance.defaults(),
                data.spells() != null ? data.spells() : SpellTuning.defaults()
        );
        LOG.info("[Grim] BalanceReloadListener applied.");
    }

    // ---------- helpers ----------

    private static <T> T readJson(ResourceManager rm, String namespace, String path, Codec<T> codec) {
        try {
            ResourceLocation rl = ResourceLocation.fromNamespaceAndPath(namespace, path);
            var opt = rm.getResource(rl);
            if (opt.isEmpty()) return null;

            try (var in = opt.get().open();
                 var br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
                var json = com.google.gson.JsonParser.parseReader(br);
                var parsed = codec.parse(JsonOps.INSTANCE, json);
                return parsed.result().orElse(null);
            }
        } catch (Exception ex) {
            LOG.error("[Grim] Failed to read json {}/{}: {}", namespace, path, ex.toString());
            return null;
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java -----
package com.doomspire.grimcore.datapack.codec;

import com.doomspire.grimcore.stat.Attributes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

import java.util.EnumMap;
import java.util.Map;

public record AttributesBalance(Map<Attributes, Rule> byAttr) {

    public static final Codec<Rule> RULE_CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.optionalFieldOf("cap", 99).forGetter(Rule::cap),
            Codec.DOUBLE.optionalFieldOf("max_health_per", 5.0).forGetter(Rule::maxHealthPer),
            Codec.DOUBLE.optionalFieldOf("max_mana_per", 5.0).forGetter(Rule::maxManaPer),
            Codec.DOUBLE.optionalFieldOf("regen_hp_per", 0.05).forGetter(Rule::regenHpPer),
            Codec.DOUBLE.optionalFieldOf("regen_mp_per", 0.05).forGetter(Rule::regenMpPer),
            Codec.DOUBLE.optionalFieldOf("crit_chance_per", 0.0).forGetter(Rule::critChancePer),
            Codec.DOUBLE.optionalFieldOf("evasion_per", 0.0).forGetter(Rule::evasionPer),
            Codec.DOUBLE.optionalFieldOf("melee_damage_per", 0.0).forGetter(Rule::meleeDamagePer),
            Codec.DOUBLE.optionalFieldOf("spell_power_per", 0.0).forGetter(Rule::spellPowerPer),
            Codec.DOUBLE.optionalFieldOf("cast_speed_per", 0.0).forGetter(Rule::castSpeedPer)
    ).apply(i, Rule::new));

    public static final Codec<Attributes> ATTR_CODEC =
            Codec.STRING.xmap(s -> Attributes.valueOf(s.toUpperCase()), a -> a.name().toLowerCase());

    public static final Codec<Map<Attributes, Rule>> MAP_CODEC =
            Codec.unboundedMap(ATTR_CODEC, RULE_CODEC).xmap(m -> {
                EnumMap<Attributes, Rule> map = new EnumMap<>(Attributes.class);
                map.putAll(m);
                return map;
            }, m -> m);

    public static final Codec<AttributesBalance> CODEC =
            RecordCodecBuilder.create(i -> i.group(
                    MAP_CODEC.fieldOf("attributes").forGetter(AttributesBalance::byAttr)
            ).apply(i, AttributesBalance::new));

    public static AttributesBalance defaults() {
        EnumMap<Attributes, Rule> def = new EnumMap<>(Attributes.class);
        for (Attributes a : Attributes.values()) {
            int cap = (a == Attributes.EVASION) ? 100 : 99;

            double maxHealthPer = (a == Attributes.VITALITY) ? 6.0 : 0.0;
            double regenHpPer   = (a == Attributes.VITALITY) ? 0.06 : 0.0;

            double maxManaPer   = (a == Attributes.SPIRIT) ? 10.0 : 0.0;
            double regenMpPer   = (a == Attributes.SPIRIT) ? 0.08 : 0.0;

            double meleePer     = (a == Attributes.STRENGTH) ? 0.7 : 0.0;
            double spellPer     = (a == Attributes.INTELLIGENCE) ? 0.7 : 0.0;
            double castPer      = (a == Attributes.DEXTERITY) ? 0.5 : 0.0;
            double evasionPer   = (a == Attributes.EVASION) ? 0.5 : 0.0;

            def.put(a, new Rule(cap, maxHealthPer, maxManaPer, regenHpPer, regenMpPer,
                    0.0, evasionPer, meleePer, spellPer, castPer));
        }
        return new AttributesBalance(def);
    }

    public int cap(Attributes a) { return byAttr.getOrDefault(a, defaults().byAttr.get(a)).cap; }

    public String summary() { return "attrs=" + byAttr.size(); }

    public record Rule(
            int cap,
            double maxHealthPer,
            double maxManaPer,
            double regenHpPer,
            double regenMpPer,
            double critChancePer,
            double evasionPer,
            double meleeDamagePer,
            double spellPowerPer,
            double castSpeedPer
    ) {}
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java -----
package com.doomspire.grimcore.datapack.codec;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

public record LevelsCurve(int maxLevel, double base, double growth) {

    public static final Codec<LevelsCurve> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.fieldOf("max_level").forGetter(LevelsCurve::maxLevel),
            Codec.DOUBLE.fieldOf("base").forGetter(LevelsCurve::base),
            Codec.DOUBLE.fieldOf("growth").forGetter(LevelsCurve::growth)
    ).apply(i, LevelsCurve::new));

    public static LevelsCurve defaults() {
        return new LevelsCurve(50, 100.0, 1.10); // прежние дефолты, пока не пришли данные из датапака
    }

    public String summary() {
        return "max=" + maxLevel + ", base=" + base + ", growth=" + growth;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java -----
package com.doomspire.grimcore.datapack.codec;

import com.doomspire.grimcore.spell.api.SpellSchool;
import com.doomspire.grimcore.spell.api.SpellTag;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.resources.ResourceLocation;

import java.util.List;
import java.util.Map;

public record SpellTuning(Map<ResourceLocation, Entry> byId) {

    public static final Codec<ResourceLocation> RL_CODEC = ResourceLocation.CODEC;

    public static final Codec<SpellSchool> SCHOOL_CODEC =
            Codec.STRING.xmap(s -> SpellSchool.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<SpellTag> TAG_CODEC =
            Codec.STRING.xmap(s -> SpellTag.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<Scaling> SCALING_CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.DOUBLE.optionalFieldOf("vitality", 0.0).forGetter(Scaling::vitality),
            Codec.DOUBLE.optionalFieldOf("strength", 0.0).forGetter(Scaling::strength),
            Codec.DOUBLE.optionalFieldOf("intelligence", 0.0).forGetter(Scaling::intelligence),
            Codec.DOUBLE.optionalFieldOf("spirit", 0.0).forGetter(Scaling::spirit),
            Codec.DOUBLE.optionalFieldOf("dexterity", 0.0).forGetter(Scaling::dexterity),
            Codec.DOUBLE.optionalFieldOf("evasion", 0.0).forGetter(Scaling::evasion)
    ).apply(i, Scaling::new));

    public static final Codec<Entry> ENTRY_CODEC = RecordCodecBuilder.create(i -> i.group(
            SCHOOL_CODEC.fieldOf("school").forGetter(Entry::school),
            Codec.list(TAG_CODEC).optionalFieldOf("tags", List.of()).forGetter(Entry::tags),
            Codec.INT.optionalFieldOf("base_cost", 0).forGetter(Entry::baseCost),
            Codec.INT.optionalFieldOf("base_cooldown", 0).forGetter(Entry::baseCooldown),
            SCALING_CODEC.optionalFieldOf("scaling", Scaling.ZERO).forGetter(Entry::scaling),
            Codec.list(Codec.STRING).optionalFieldOf("forbidden_weapons", List.of()).forGetter(Entry::forbiddenWeapons),
            Codec.list(Codec.STRING).optionalFieldOf("allowed_armor_tags", List.of()).forGetter(Entry::allowedArmorTags)
    ).apply(i, Entry::new));

    public static final Codec<Map<ResourceLocation, Entry>> MAP_CODEC =
            Codec.unboundedMap(RL_CODEC, ENTRY_CODEC);

    public static final Codec<SpellTuning> CODEC =
            RecordCodecBuilder.create(i -> i.group(
                    MAP_CODEC.fieldOf("spells").forGetter(SpellTuning::byId)
            ).apply(i, SpellTuning::new));

    /** Значения по умолчанию — пустой набор. */
    public static SpellTuning defaults() {
        return new SpellTuning(Map.of());
    }

    /** Короткий summary для логов. */
    public String summary() {
        return "spells=" + (byId != null ? byId.size() : 0);
    }

    // --- types ---

    public record Entry(
            SpellSchool school,
            List<SpellTag> tags,
            int baseCost,
            int baseCooldown,
            Scaling scaling,
            List<String> forbiddenWeapons,
            List<String> allowedArmorTags
    ) {}

    public record Scaling(
            double vitality,
            double strength,
            double intelligence,
            double spirit,
            double dexterity,
            double evasion
    ) {
        public static final Scaling ZERO = new Scaling(0,0,0,0,0,0);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.combat.DamageContext;
import com.doomspire.grimcore.combat.DamageEngine;
import com.doomspire.grimcore.combat.EnvironmentalDamage;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.DamageTypes;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.living.LivingDamageEvent;

public final class CoreDamageEvents {

    private CoreDamageEvents() {}

    /** Регистрируй из инициализации: NeoForge.EVENT_BUS.register(CoreDamageEvents.class); */
    public static void registerToBus() {
        NeoForge.EVENT_BUS.register(CoreDamageEvents.class);
    }

    /**
     * Ядро обработки урона. Никакой предметной/спелл-логики здесь нет.
     * Сначала экологический урон (% от MaxHP), затем боевой пайплайн.
     */
    @SubscribeEvent
    public static void onLivingDamage(LivingDamageEvent.Pre event) {
        LivingEntity living = event.getEntity();
        if (living.level().isClientSide() || !living.isAlive()) return;

        // ---------- Экологический урон как % MaxHP ----------
        Float pct = EnvironmentalDamage.percentFor(event.getSource());
        if (pct != null) {
            if (living instanceof ServerPlayer sp) {
                PlayerStatsAttachment ps = sp.getData(ModAttachments.PLAYER_STATS.get());
                if (ps != null) {
                    int max = (int) Math.max(1, ps.getSnapshot().maxHealth);
                    int delta = Math.max(1, Math.round(max * pct));
                    ps.setCurrentHealth(ps.getCurrentHealth() - delta);
                    ps.markDirty();
                    // мгновенный синк HUD
                    GrimcoreNetworking.syncPlayerStats(sp, ps);
                    event.setNewDamage(0f);
                    if (ps.getCurrentHealth() <= 0) killByGeneric(sp);
                }
                return;
            } else {
                MobStatsAttachment ms = living.getData(ModAttachments.MOB_STATS.get());
                if (ms != null) {
                    int max = (int) Math.max(1, ms.getSnapshot().maxHealth);
                    int delta = Math.max(1, Math.round(max * pct));
                    ms.setCurrentHealth(ms.getCurrentHealth() - delta);
                    ms.markDirty();
                    event.setNewDamage(0f);
                    if (ms.getCurrentHealth() <= 0) killByGeneric(living);
                }
                return;
            }
        }

        float amountAfterContent = event.getNewDamage();
        if (amountAfterContent <= 0f) return;

        Entity src = event.getSource() != null ? event.getSource().getEntity() : null;

        // ---------- Цель — игрок: расчёт через DamageEngine ----------
        if (living instanceof ServerPlayer serverPlayer) {
            LivingEntity attacker = (src instanceof LivingEntity le) ? le : null;

            DamageContext ctx = new DamageContext(attacker, serverPlayer);
            if (attacker != null) {
                // если атакует моб с кастомными статами — берём его физический урон
                MobStatsAttachment aStats = attacker.getData(ModAttachments.MOB_STATS.get());
                if (aStats != null) {
                    float phys = aStats.getSnapshot().damage.getOrDefault(DamageTypes.PHYS_MELEE, amountAfterContent);
                    ctx.add(DamageTypes.PHYS_MELEE, phys);
                } else {
                    // иначе fallback на ванильное число
                    ctx.add(DamageTypes.PHYS_MELEE, amountAfterContent);
                }
            } else {
                ctx.add(DamageTypes.PHYS_MELEE, amountAfterContent);
            }

            DamageEngine.resolveAndApply(ctx);
            event.setNewDamage(0f);

            PlayerStatsAttachment att = serverPlayer.getData(ModAttachments.PLAYER_STATS.get());
            if (att != null && att.getCurrentHealth() <= 0) killByGeneric(serverPlayer);
            return;
        }

        // ---------- Цель — моб: прямое применение к кастомному HP ----------
        {
            float base = amountAfterContent;
            if (src instanceof LivingEntity le) {
                MobStatsAttachment aStats = le.getData(ModAttachments.MOB_STATS.get());
                if (aStats != null) {
                    base = aStats.getSnapshot().damage.getOrDefault(DamageTypes.PHYS_MELEE, base);
                }
            }
            MobStatsAttachment tStats = living.getData(ModAttachments.MOB_STATS.get());
            if (tStats != null) {
                tStats.setCurrentHealth(tStats.getCurrentHealth() - Math.round(base));
                tStats.markDirty();
                event.setNewDamage(0f);
                if (tStats.getCurrentHealth() <= 0) killByGeneric(living);
            }
        }
    }

    private static void killByGeneric(LivingEntity entity) {
        entity.setHealth(0f);
        DamageSource genericKill = new DamageSource(
                entity.level().registryAccess()
                        .registryOrThrow(Registries.DAMAGE_TYPE)
                        .getHolderOrThrow(net.minecraft.world.damagesource.DamageTypes.GENERIC_KILL)
        );
        entity.hurt(genericKill, Float.MAX_VALUE);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatEffects;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.PlayerEvent;

public final class CorePlayerEvents {
    private CorePlayerEvents() {}

    /** Вызови из инициализации мода ядра (common): NeoForge.EVENT_BUS.register(CorePlayerEvents.class); */
    public static void registerToBus() {
        NeoForge.EVENT_BUS.register(CorePlayerEvents.class);
    }

    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!(event.getEntity() instanceof ServerPlayer player)) return;

        PlayerStatsAttachment stats = player.getData(ModAttachments.PLAYER_STATS.get());
        if (stats == null) return;

        // первичная инициализация «текущих» ресурсов
        var snap = stats.getSnapshot();
        if (stats.getCurrentHealth() <= 0) stats.setCurrentHealth((int) snap.maxHealth);
        if (stats.getCurrentMana()   <= 0) stats.setCurrentMana((int) snap.maxMana);
        stats.markDirty();

        // синк клиенту, чтобы HUD сразу обновился
        GrimcoreNetworking.syncPlayerStats(player, stats);

        // применяем ВСЕ эффекты статов к ванильным атрибутам (DEX→скорость и т.д.)
        StatEffects.applyAll(player);
    }

    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!(event.getEntity() instanceof ServerPlayer player)) return;

        // после респауна: повторно применяем эффекты (могли слететь с нового Entity)
        StatEffects.applyAll(player);
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.EntityJoinLevelEvent;

public final class MobSpawnInit {
    private MobSpawnInit(){}

    public static void registerToBus() { NeoForge.EVENT_BUS.register(MobSpawnInit.class); }

    @SubscribeEvent
    public static void onJoin(EntityJoinLevelEvent event) {
        if (event.getLevel().isClientSide()) return;
        if (!(event.getEntity() instanceof LivingEntity living)) return;
        if (living instanceof net.minecraft.world.entity.player.Player) return;

        MobStatsAttachment att = living.getData(ModAttachments.MOB_STATS.get());
        if (att == null) {
            att = new MobStatsAttachment();
            living.setData(ModAttachments.MOB_STATS.get(), att);
        }

        // Применяем data-driven оверрайд (если есть)
        MobTuning.applyPerEntityOverrides((ServerLevel) event.getLevel(), living, att);

        // Инициализируем HP от max
        int max = (int)Math.max(1, att.getSnapshot().maxHealth);
        if (att.getCurrentHealth() <= 0) att.setCurrentHealth(max);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;

/**
 * Заглушка-провайдер пер-мобных оверрайдов.
 * На следующем шаге подменим на чтение JSON из datapack.
 */
public final class MobTuning {
    private MobTuning(){}

    public static void applyPerEntityOverrides(ServerLevel level, LivingEntity mob, MobStatsAttachment att) {
        ResourceLocation id = mob.getType().builtInRegistryHolder().key().location();
        // Пример: зомби — пожирнее, паук — ловчее
        if ("minecraft".equals(id.getNamespace()) && "zombie".equals(id.getPath())) {
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.VITALITY, 3);
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.STRENGTH, 2);
        } else if ("minecraft".equals(id.getNamespace()) && "spider".equals(id.getPath())) {
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.EVASION, 5);
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.DEXTERITY, 3);
        }
        att.markDirty();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.PlayerEvent;
import net.neoforged.neoforge.event.tick.PlayerTickEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Простая серверная регенерация HP/MP с аккумуляторами.
 * - считает реген каждый тик
 * - применяет целые очки, дробную часть копит
 * - синкает на клиент не чаще, чем раз в 10 тиков и только при изменениях
 */
public final class RegenTicker {
    private RegenTicker(){}

    public static void registerToBus() {
        NeoForge.EVENT_BUS.register(RegenTicker.class);
    }

    private static final class Accum {
        double hpFrac = 0.0;
        double mpFrac = 0.0;
        int    lastSyncedHp = Integer.MIN_VALUE;
        int    lastSyncedMp = Integer.MIN_VALUE;
        long   lastSyncGameTime = 0L;
    }

    private static final Map<UUID, Accum> ACCUMS = new HashMap<>();
    private static final int SYNC_COOLDOWN_TICKS = 10;

    @SubscribeEvent
    public static void onPlayerTick(PlayerTickEvent.Post e) {
        if (!(e.getEntity() instanceof ServerPlayer sp)) return;
        var level = sp.serverLevel();
        PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (att == null) return;

        StatSnapshot snap = att.getSnapshot();
        // реген/сек из снапшота → реген/тик
        double hpPerTick = Math.max(0.0, snap.regenHealth) / 20.0;
        double mpPerTick = Math.max(0.0, snap.regenMana)   / 20.0;

        var a = ACCUMS.computeIfAbsent(sp.getUUID(), k -> new Accum());
        a.hpFrac += hpPerTick;
        a.mpFrac += mpPerTick;

        int hpGain = (int) Math.floor(a.hpFrac);
        int mpGain = (int) Math.floor(a.mpFrac);
        if (hpGain != 0 || mpGain != 0) {
            a.hpFrac -= hpGain;
            a.mpFrac -= mpGain;

            // применяем к текущим ресурсам
            int beforeHp = att.getCurrentHealth();
            int beforeMp = att.getCurrentMana();
            att.setCurrentHealth(beforeHp + hpGain);
            att.setCurrentMana(beforeMp + mpGain);
            att.markDirty();

            // редкий синк: только если значения изменились и прошло >= cooldown
            boolean hpChanged = att.getCurrentHealth() != a.lastSyncedHp;
            boolean mpChanged = att.getCurrentMana()   != a.lastSyncedMp;
            long now = level.getGameTime();
            if ((hpChanged || mpChanged) && now - a.lastSyncGameTime >= SYNC_COOLDOWN_TICKS) {
                GrimcoreNetworking.syncPlayerStats(sp, att);
                a.lastSyncedHp = att.getCurrentHealth();
                a.lastSyncedMp = att.getCurrentMana();
                a.lastSyncGameTime = now;
            }
        }
    }

    @SubscribeEvent
    public static void onPlayerLoggedOut(PlayerEvent.PlayerLoggedOutEvent e) {
        if (e.getEntity() != null) {
            ACCUMS.remove(e.getEntity().getUUID());
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.LivingEntity;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.living.LivingDeathEvent;

public final class XpEvents {
    private XpEvents(){}

    public static void registerToBus() {
        NeoForge.EVENT_BUS.register(XpEvents.class);
    }

    @SubscribeEvent
    public static void onLivingDeath(LivingDeathEvent event) {
        if (event.getEntity().level().isClientSide()) return;

        LivingEntity dead = event.getEntity();
        if (dead instanceof ServerPlayer) return;

        ServerPlayer killer = null;
        if (event.getSource() != null && event.getSource().getEntity() instanceof ServerPlayer sp) {
            killer = sp;
        } else if (dead.getKillCredit() instanceof ServerPlayer sp2) {
            killer = sp2;
        }
        if (killer == null) return;

        // --- вычисляем "цену" моба ---
        int maxHp;
        MobStatsAttachment mobAtt = dead.getData(ModAttachments.MOB_STATS.get());
        if (mobAtt != null) {
            maxHp = Math.max(1, (int) mobAtt.getSnapshot().maxHealth);
        } else {
            maxHp = Math.max(1, (int) Math.ceil(dead.getMaxHealth()));
        }
        int xp = Math.max(1, Math.round((float) Math.pow(maxHp, 0.80) * 4f));

        // --- применяем на игроке ---
        PlayerProgressAttachment prog = killer.getData(ModAttachments.PLAYER_PROGRESS.get());
        PlayerStatsAttachment stats   = killer.getData(ModAttachments.PLAYER_STATS.get());
        if (prog == null || stats == null) return;

        int levels = prog.addExp(xp);

        if (levels > 0) {
            stats.addUnspentPoints(levels); // выдаём очки за ап-левел
            stats.markDirty();
            GrimcoreNetworking.syncPlayerStats(killer, stats); // мгновенно обновим HUD (очки можно показывать)
        }

        // прогресс: мгновенный клиентский синк (HUD увидит exp/level/cap)
        ProgressNetworking.syncPlayerProgress(killer, prog);
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.data.ModDataComponents;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;

@Mod(Grimcore.MODID)
public final class Grimcore {
    public static final String MODID = "grimcore";
    public Grimcore(IEventBus modEventBus, ModContainer container) {
        // attachments регистрируем на MOD bus
        com.doomspire.grimcore.stat.ModAttachments.ATTACHMENT_TYPES.register(modEventBus);
        com.doomspire.grimcore.events.RegenTicker.registerToBus();
        // игровые события — на общий шина NeoForge
        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.register(com.doomspire.grimcore.events.CoreDamageEvents.class);
        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.register(com.doomspire.grimcore.events.CorePlayerEvents.class);
        ModDataComponents.init(modEventBus);
    }
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java -----
package com.doomspire.grimcore.item.comp;

public class BlockBonusComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java -----
package com.doomspire.grimcore.item.comp;

public class ClassRestrictionComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java -----
package com.doomspire.grimcore.item.comp;

public class StatBonusComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

@EventBusSubscriber(modid = Grimcore.MODID) // без bus = ...
public final class ModBusHandlers {
    private ModBusHandlers() {}

    @SubscribeEvent
    public static void onRegisterPayloads(RegisterPayloadHandlersEvent e) {
        GrimcoreNetworking.register(e);
        ProgressNetworking.register(e);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

public final class GrimcoreNetworking {
    private GrimcoreNetworking() {}

    public static void register(final RegisterPayloadHandlersEvent event) {
        var registrar = event.registrar(Grimcore.MODID);

        // 1.21.x: используем playToClient / playToServer и CustomPacketPayload.Type
        registrar.playToClient(
                S2C_SyncPlayerStats.TYPE,
                S2C_SyncPlayerStats.STREAM_CODEC,
                (payload, ctx) -> {
                    Player clientPlayer = Minecraft.getInstance().player;
                    if (clientPlayer != null) {
                        clientPlayer.setData(ModAttachments.PLAYER_STATS.get(), payload.att());
                    }
                }
        );
    }

    /** Вызывать на сервере после изменения HP/MP, чтобы HUD сразу обновился. */
    public static void syncPlayerStats(ServerPlayer target, PlayerStatsAttachment att) {
        PacketDistributor.sendToPlayer(target, new S2C_SyncPlayerStats(att));
    }

    // -------- payload (CLIENT-bound) --------
    public record S2C_SyncPlayerStats(PlayerStatsAttachment att) implements CustomPacketPayload {
        public static final Type<S2C_SyncPlayerStats> TYPE =
                new Type<>(ResourceLocation.fromNamespaceAndPath(Grimcore.MODID, "sync_player_stats"));

        public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncPlayerStats> STREAM_CODEC =
                StreamCodec.composite(
                        PlayerStatsAttachment.STREAM_CODEC, S2C_SyncPlayerStats::att,
                        S2C_SyncPlayerStats::new
                );

        @Override
        public Type<? extends CustomPacketPayload> type() {
            return TYPE;
        }
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

public final class ProgressNetworking {
    private ProgressNetworking(){}

    public static void register(final RegisterPayloadHandlersEvent event) {
        var registrar = event.registrar(Grimcore.MODID);
        registrar.playToClient(
                S2C_SyncPlayerProgress.TYPE,
                S2C_SyncPlayerProgress.STREAM_CODEC,
                (payload, ctx) -> {
                    var player = Minecraft.getInstance().player;
                    if (player != null) {
                        player.setData(ModAttachments.PLAYER_PROGRESS.get(), payload.att());
                    }
                }
        );
    }

    public static void syncPlayerProgress(ServerPlayer target, PlayerProgressAttachment att) {
        PacketDistributor.sendToPlayer(target, new S2C_SyncPlayerProgress(att));
    }

    public record S2C_SyncPlayerProgress(PlayerProgressAttachment att) implements CustomPacketPayload {
        public static final Type<S2C_SyncPlayerProgress> TYPE =
                new Type<>(ResourceLocation.fromNamespaceAndPath(Grimcore.MODID, "sync_player_progress"));

        public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncPlayerProgress> STREAM_CODEC =
                StreamCodec.composite(
                        PlayerProgressAttachment.STREAM_CODEC, S2C_SyncPlayerProgress::att,
                        S2C_SyncPlayerProgress::new
                );

        @Override
        public Type<? extends CustomPacketPayload> type() { return TYPE; }
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\S2C_SyncStats.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record S2C_SyncStats(PlayerStatsAttachment stats) implements CustomPacketPayload {
    public static final ResourceLocation ID =
            ResourceLocation.fromNamespaceAndPath("grimcore", "sync_stats");
    public static final Type<S2C_SyncStats> TYPE = new Type<>(ID);

    public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncStats> STREAM_CODEC =
            StreamCodec.composite(
                    PlayerStatsAttachment.STREAM_CODEC, S2C_SyncStats::stats,
                    S2C_SyncStats::new
            );

    @Override public Type<? extends CustomPacketPayload> type() { return TYPE; }

    public static void handle(S2C_SyncStats msg) {
        Minecraft.getInstance().execute(() -> {
            var player = Minecraft.getInstance().player;
            if (player != null) {
                player.setData(ModAttachments.PLAYER_STATS.get(), msg.stats);
            }
        });
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\S2C_SyncStats.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java -----
package com.doomspire.grimcore.runtime;

/**
 * Лёгкий runtime-хаб для каждого игрока.
 * Не сериализуется. Хранится в ConcurrentHashMap на сервере.
 */
public class PlayerRuntimeData {
    public double healthAccumulator = 0.0;
    public double manaAccumulator = 0.0;
    public long lastSyncTick = 0L; // gameTime последнего синка
    public boolean dirty = false;  // пометка для внешних систем
    // Кеши для тяжёлых вычислений
    public int cachedDamage = -1;
    public long cacheUntilTick = 0L;
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java -----
package com.doomspire.grimcore.runtime;

import net.minecraft.server.level.ServerPlayer;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Простой manager для runtime-данных (сервер).
 */
public final class PlayerRuntimeManager {
    private static final ConcurrentHashMap<UUID, PlayerRuntimeData> RUNTIME = new ConcurrentHashMap<>();

    private PlayerRuntimeManager() {}

    public static PlayerRuntimeData getOrCreate(ServerPlayer player) {
        return RUNTIME.computeIfAbsent(player.getUUID(), uuid -> new PlayerRuntimeData());
    }

    public static PlayerRuntimeData get(ServerPlayer player) {
        return RUNTIME.get(player.getUUID());
    }

    public static void remove(ServerPlayer player) {
        if (player != null) RUNTIME.remove(player.getUUID());
    }

    public static void remove(UUID uuid) {
        if (uuid != null) RUNTIME.remove(uuid);
    }

    public static void clearAll() {
        RUNTIME.clear();
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java -----
package com.doomspire.grimcore.spell.api;

public enum CastResult {
    OK,
    NOT_ENOUGH_MANA,
    ON_COOLDOWN,
    BLOCKED,
    FAIL
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.resources.ResourceLocation;

import java.util.Set;

/** Базовый контракт любого спелла. Реализации — stateless-singleton. */
public interface Spell {
    /** Уникальный id, например grimfate:fire_bolt */
    ResourceLocation id();

    /** Школа (для фильтров/баланса/синергий). */
    SpellSchool school();

    /** Стоимость маны (базовая, до модификаторов). */
    int manaCost(SpellContext ctx);

    /** Кулдаун в тиках (базовый, до модификаторов). */
    int cooldownTicks(SpellContext ctx);

    /** Основной вызов кастования. Возвращает результат (успешно/недостаточно ресурса/на кулдауне...). */
    CastResult cast(SpellContext ctx);

    Set<SpellTag> tags();
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.player.Player;
import org.jetbrains.annotations.Nullable;

/** Контекст вызова спелла (сервер). */
public final class SpellContext {
    public final ServerLevel level;
    public final Player caster;
    public final int slot;                  // слот хотбара спеллов; -1 если вне хотбара
    public final double aimX, aimY, aimZ;   // произвольные «наводочные» параметры
    @Nullable public final Object tuning;   // объект tюнинга (деcериализованный из SpellTuning), типизируем позже

    public SpellContext(ServerLevel level, Player caster, int slot, double aimX, double aimY, double aimZ, @Nullable Object tuning) {
        this.level = level;
        this.caster = caster;
        this.slot = slot;
        this.aimX = aimX;
        this.aimY = aimY;
        this.aimZ = aimZ;
        this.tuning = tuning;
    }

    public static SpellContext simple(ServerLevel lvl, Player caster) {
        return new SpellContext(lvl, caster, -1, 0, 0, 0, null);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java -----
package com.doomspire.grimcore.spell.api;

public enum SpellSchool {
    FIRE, FROST, LIGHTNING, POISON,
    TECHNIQUE, WARCRY, AURA, ARCANE, SHADOW,
    UTILITY
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java -----
package com.doomspire.grimcore.spell.api;

public enum SpellTag {
    MELEE, RANGED, BUFF, DEBUFF, MOVEMENT, PROJECTILE, AREA,
    CHANNELED, DOT, SHIELD, SUMMON, WEAPON_SKILL
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java -----
package com.doomspire.grimcore.spell;

import com.doomspire.grimcore.spell.api.Spell;
import net.minecraft.resources.ResourceLocation;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Простой реестр спеллов в рантайме.
 * Регистрация выполняется на общих инициализациях мода или при загрузке datapack-тюнинга (в т.ч. референс-спеллы).
 */
public final class GrimSpells {
    private GrimSpells() {}

    private static final Map<ResourceLocation, Spell> REGISTRY = new LinkedHashMap<>();

    public static void register(Spell spell) {
        REGISTRY.put(spell.id(), spell);
        new com.doomspire.grimcore.spell.impl.FireBoltSpell();
    }

    public static Spell get(ResourceLocation id) {
        return REGISTRY.get(id);
    }

    public static Map<ResourceLocation, Spell> all() {
        return Collections.unmodifiableMap(REGISTRY);
    }

    public static void clear() {
        REGISTRY.clear();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\impl\FireBoltSpell.java -----
package com.doomspire.grimcore.spell.impl;

import com.doomspire.grimcore.datapack.Balance;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.doomspire.grimcore.spell.api.*;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;

import java.util.Set;

public final class FireBoltSpell implements Spell {
    private static final ResourceLocation ID = ResourceLocation.fromNamespaceAndPath("grimfate", "fire_bolt");

    @Override public ResourceLocation id() { return ID; }
    @Override public SpellSchool school() { return SpellSchool.FIRE; }
    @Override public Set<SpellTag> tags() { return Set.of(SpellTag.PROJECTILE, SpellTag.RANGED); }

    @Override public int manaCost(SpellContext ctx) {
        SpellTuning.Entry e = Balance.getSpellEntry(ID);
        return e != null ? Math.max(0, e.baseCost()) : 6;
    }
    @Override public int cooldownTicks(SpellContext ctx) {
        SpellTuning.Entry e = Balance.getSpellEntry(ID);
        return e != null ? Math.max(0, e.baseCooldown()) : 20;
    }

    @Override
    public CastResult cast(SpellContext ctx) {
        var p = ctx.caster;
        var lvl = ctx.level;

        // самый простой «трэйсер»: 16 блоков, пока без собственной сущности
        var from = p.getEyePosition();
        var look = p.getLookAngle();
        var to   = from.add(look.scale(16.0));
        var clip = lvl.clip(new net.minecraft.world.level.ClipContext(
                from, to,
                net.minecraft.world.level.ClipContext.Block.COLLIDER,
                net.minecraft.world.level.ClipContext.Fluid.NONE,
                p));

        var hitPos = clip.getLocation() != null ? clip.getLocation() : to;

        var target = lvl.getEntities(p, p.getBoundingBox().inflate(16.0),
                        e -> e instanceof net.minecraft.world.entity.LivingEntity && e != p).stream()
                .min(java.util.Comparator.comparingDouble(e -> e.distanceToSqr(hitPos.x, hitPos.y, hitPos.z)))
                .orElse(null);

        if (target instanceof net.minecraft.world.entity.LivingEntity living) {
            var src = lvl.damageSources().indirectMagic(p, p);
            living.hurt(src, 5.0f);
            lvl.playSound(null, p.blockPosition(), SoundEvents.BLAZE_SHOOT, SoundSource.PLAYERS, 0.6f, 1.2f);
            return CastResult.OK;
        }

        // холостой звук
        lvl.playSound(null, p.blockPosition(), SoundEvents.BLAZE_SHOOT, SoundSource.PLAYERS, 0.4f, 1.2f);
        return CastResult.OK;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\impl\FireBoltSpell.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java -----
package com.doomspire.grimcore.stat;

/**
 * Базовые атрибуты, которые игрок получает и распределяет при повышении уровня.
 */
public enum Attributes {
    VITALITY,      // здоровье, реген, бонус к блоку
    STRENGTH,      // физический урон ближнего боя
    INTELLIGENCE,  // урон заклинаний и стихий
    SPIRIT,        // мана, реген маны
    DEXTERITY,     // физический урон дальнего боя
    EVASION,       // шанс уворота
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java -----
package com.doomspire.grimcore.stat;

/**
 * Типы урона. Используются в DamageContext и StatSnapshot.
 */
public enum DamageTypes {
    PHYS_MELEE,
    PHYS_RANGED,
    FIRE,
    FROST,
    LIGHTNING,
    POISON
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\MobStatsProvider.java -----
// src/main/java/com/doomspire/grimcore/stats/MobStatsProvider.java
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.attach.MobStatsAttachment;

import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.world.entity.LivingEntity;

public class MobStatsProvider {

    public static MobStatsAttachment get(LivingEntity mob) {
        return mob.getData(ModAttachments.MOB_STATS.get());
    }

    public static void set(LivingEntity mob, MobStatsAttachment att) {
        mob.setData(ModAttachments.MOB_STATS.get(), att);
    }

    public static void damage(LivingEntity mob, int amount) {
        MobStatsAttachment att = get(mob);
        if (att == null) return;
        att.setCurrentHealth(att.getCurrentHealth() - Math.max(0, amount));
        att.markDirty();
    }

    public static void heal(LivingEntity mob, int amount) {
        MobStatsAttachment att = get(mob);
        if (att == null) return;
        att.setCurrentHealth(att.getCurrentHealth() + Math.max(0, amount));
        att.markDirty();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\MobStatsProvider.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.NeoForgeRegistries;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.attachment.AttachmentType;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;

public final class ModAttachments {
    private ModAttachments() {}

    public static final DeferredRegister<AttachmentType<?>> ATTACHMENT_TYPES =
            DeferredRegister.create(NeoForgeRegistries.ATTACHMENT_TYPES, Grimcore.MODID);

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerStatsAttachment>> PLAYER_STATS =
            ATTACHMENT_TYPES.register("player_stats",
                    () -> AttachmentType.builder(PlayerStatsAttachment::new)
                            // персист сохранять позже, когда добавим Codec:
                            // .serialize(YourCodecHere)
                            .sync(PlayerStatsAttachment.STREAM_CODEC) // сеть ОК
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<MobStatsAttachment>> MOB_STATS =
            ATTACHMENT_TYPES.register("mob_stats",
                    () -> AttachmentType.builder(MobStatsAttachment::new)
                            .sync(MobStatsAttachment.STREAM_CODEC) // можно выключить, если на клиенте не нужно
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerProgressAttachment>> PLAYER_PROGRESS =
            ATTACHMENT_TYPES.register("player_progress", () ->
                    AttachmentType.builder(PlayerProgressAttachment::new)
                            .serialize(PlayerProgressAttachment.CODEC)        // автосейв в сейв игрока
                            .sync(PlayerProgressAttachment.STREAM_CODEC)      // авто-синк при замене
                            .build()
            );

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerLoadoutAttachment>> PLAYER_LOADOUT =
            ATTACHMENT_TYPES.register("player_loadout",
                    () -> AttachmentType.builder(PlayerLoadoutAttachment::new)
                            .serialize(PlayerLoadoutAttachment.CODEC)      // хот-бар сохраняется
                            .sync(PlayerLoadoutAttachment.STREAM_CODEC)     // ВАЖНО: клиент видит изменения
                            .build());
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java -----
package com.doomspire.grimcore.stat;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

/**
 * Чистые данные об уровне игрока.
 * Только хранение + сериализация в NBT/сеть.
 */
public record PlayerProgress(int level, int exp, int expCap) {

    public static final Codec<PlayerProgress> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.INT.fieldOf("level").forGetter(PlayerProgress::level),
            Codec.INT.fieldOf("exp").forGetter(PlayerProgress::exp),
            Codec.INT.fieldOf("exp_cap").forGetter(PlayerProgress::expCap)
    ).apply(instance, PlayerProgress::new));

    public static final StreamCodec<FriendlyByteBuf, PlayerProgress> STREAM_CODEC = StreamCodec.composite(
            ByteBufCodecs.INT, PlayerProgress::level,
            ByteBufCodecs.INT, PlayerProgress::exp,
            ByteBufCodecs.INT, PlayerProgress::expCap,
            PlayerProgress::new
    );

    public static final PlayerProgress DEFAULT = new PlayerProgress(1, 0, 100);

    /**
     * Вспомогательный метод для проверки прогресса на клиенте (HUD).
     */
    public String hudString() {
        return "Lvl " + level + " (" + exp + "/" + expCap + ")";
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java -----
package com.doomspire.grimcore.stat;

/**
 * Сопротивления урону. Применяются в DamageEngine.
 */
public enum ResistTypes {
    PHYS,
    FIRE,
    FROST,
    LIGHTNING,
    POISON
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;

/**
 * Пересчитывает агрегированные статы (StatSnapshot) на основе атрибутов, предметов и бонусов.
 * Вызов: при изменении атрибутов/уровня/экипировки/эффектов.
 */
public class StatCalculator {

    public static StatSnapshot calculate(PlayerStatsAttachment att) {
        StatSnapshot snapshot = new StatSnapshot();

        // Атрибуты
        int vit = att.getAttribute(Attributes.VITALITY);
        int str = att.getAttribute(Attributes.STRENGTH);
        int intl = att.getAttribute(Attributes.INTELLIGENCE);
        int spirit = att.getAttribute(Attributes.SPIRIT);
        int dex = att.getAttribute(Attributes.DEXTERITY);
        int eva = att.getAttribute(Attributes.EVASION);

        // Примеры формул (значения можно вынести в JSON balance/attributes.json)
        snapshot.maxHealth = 100 + vit * 20;
        snapshot.regenHealth = 1 + vit * 1;

        snapshot.maxMana = 100 + spirit * 30;
        snapshot.regenMana = 1 + spirit * 3;

        snapshot.damage.put(DamageTypes.PHYS_MELEE, str * 0.03f);
        snapshot.damage.put(DamageTypes.PHYS_RANGED, dex * 0.03f);
        snapshot.damage.put(DamageTypes.FIRE, intl * 0.02f);
        snapshot.damage.put(DamageTypes.FROST, intl * 0.02f);
        snapshot.damage.put(DamageTypes.LIGHTNING, intl * 0.02f);
        snapshot.damage.put(DamageTypes.POISON, intl * 0.02f);

        snapshot.critChance = 0f; // 1% за очко
        snapshot.critDamage = 0.5f;        // +50% базово
        snapshot.lifesteal = 0f;
        snapshot.manasteal = 0f;
        snapshot.evasionChance = eva * 0.01f;
        snapshot.moveSpeedPct = dex * 0.25D; // 0.25% за 1 DEX

        // TODO: сюда позже подключим бонусы предметов через StatAggregator

        return snapshot;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;

/**
 * Применяет эффекты из статов к ванильным атрибутам игрока.
 * ЕДИНАЯ точка – тут же и снимаем/обновляем модификаторы.
 */
public final class StatEffects {
    private StatEffects() {}

    // Идентификаторы наших модификаторов (ResourceLocation в 1.21.1)
    public static final ResourceLocation MOVE_SPEED_ID =
            ResourceLocation.fromNamespaceAndPath("grimcore", "dex_move_speed");

    /**
     * Применяет все эффекты заново на основе текущего снапшота статов.
     * Вызывать после любого изменения статов/экипировки и при логине/респауне.
     */
    public static void applyAll(ServerPlayer sp) {
        PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (att == null) return;

        var snap = att.getSnapshot();

        // 1) Ловкость → скорость передвижения: +0.25% за 1 DEX
        applyMoveSpeed(sp, snap.moveSpeedPct);
        // 2) здесь же позже: сила → урон ближнего, интеллект → сила магии и т.п.
    }

    private static void applyMoveSpeed(ServerPlayer sp, double percent) {
        AttributeInstance inst = sp.getAttribute(Attributes.MOVEMENT_SPEED);
        if (inst == null) return;

        // снимаем старый наш модификатор
        inst.removeModifier(MOVE_SPEED_ID);

        // +X% к ИТОГОВОЙ скорости → ADD_MULTIPLIED_TOTAL с долей (0.075 для +7.5%)
        double addTotal = percent / 100.0;
        if (addTotal == 0.0) return;

        AttributeModifier mod = new AttributeModifier(
                MOVE_SPEED_ID,
                addTotal,
                AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL
        );
        inst.addPermanentModifier(mod);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java -----
package com.doomspire.grimcore.stat;

import java.util.EnumMap;

/**
 * Кэшированное состояние всех характеристик игрока/моба.
 * Используется в боевом движке и GUI.
 */
public class StatSnapshot {
    // Ресурсы
    public float maxHealth;
    public float regenHealth;
    public float maxMana;
    public float regenMana;

    // Урон
    public EnumMap<DamageTypes, Float> damage = new EnumMap<>(DamageTypes.class);

    // Резисты
    public EnumMap<ResistTypes, Float> resistances = new EnumMap<>(ResistTypes.class);

    // Боевые модификаторы
    public float critChance;
    public float critDamage;
    public float lifesteal;
    public float manasteal;
    public float evasionChance;
    public double moveSpeedPct; // бонус к скорости в процентах (например 7.5 = +7.5%)

    public StatSnapshot() {
        for (DamageTypes type : DamageTypes.values()) {
            damage.put(type, 0f);
        }
        for (ResistTypes type : ResistTypes.values()) {
            resistances.put(type, 0f);
        }
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java -----
package com.doomspire.grimcore.xp;

import com.doomspire.grimcore.datapack.BalanceData;

public final class LevelTable {
    private static final int MAX_LEVEL = 50; // временно, вынесем в конфиг
    private static final int BASE = 100;
    private static final double GROWTH = 1.10; // +10% к требованию на уровень

    private LevelTable() {}

    /** Сколько XP нужно, чтобы перейти с level → level+1 */
    public static int expForLevel(int level) {
        if (level <= 0) return BASE;
        return (int) Math.round(BASE * Math.pow(GROWTH, level - 1));
    }

    /** Сколько XP нужно всего, чтобы достичь этого уровня */
    public static int capForLevel(int level) {
        int sum = 0;
        for (int i = 1; i <= level; i++) {
            sum += expForLevel(i);
        }
        return sum;
    }

    public static int maxLevel() {
        return Math.max(1, BalanceData.levels().maxLevel());
    }

    /** Сколько XP нужно, чтобы достичь уровня L (с начала прогрессии). */
    public static long totalXpForLevel(int level) {
        var lv = BalanceData.levels();
        int L = Math.max(1, Math.min(level, lv.maxLevel()));
        double base = lv.base();
        double growth = lv.growth();
        // Геометрическая прогрессия: base * growth^(L-1) суммой от 1..L-1
        double sum = 0.0;
        double term = base;
        for (int i = 1; i < L; i++) {
            sum += term;
            term *= growth;
        }
        return Math.round(sum);
    }

    /** Сколько XP нужно от L до L+1 (инкрементальный шаг). */
    public static int xpForNextLevel(int level) {
        var lv = BalanceData.levels();
        int L = Math.max(1, Math.min(level, lv.maxLevel()));
        return (int)Math.round(lv.base() * Math.pow(lv.growth(), Math.max(0, L-1)));
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java -----
package com.doomspire.grimcore.xp;

public class Rewards {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java -----n
----- BEGIN FILE: .\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json -----
{
  "attributes": {
    "vitality": 3,
    "strength": 2,
    "dexterity": 0,
    "intelligence": 0,
    "evasion": 0
  },
  "resistances": {
    "phys": 0.10,
    "fire": 0.00,
    "frost": 0.00,
    "lightning": 0.00,
    "poison": 0.00
  },
  "damage": {
    "phys_melee": 25.0
  }
}

n----- END FILE: .\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimfate.config.ClientConfig;
import com.doomspire.grimfate.core.Grimfate;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.client.event.RenderGuiEvent;
import net.neoforged.neoforge.client.event.RenderGuiLayerEvent;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.CLIENT)
public final class CustomHudOverlay {
    private CustomHudOverlay() {}

    // ---- текстуры ----
    private static final ResourceLocation HEALTH_BAR_EMPTY =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_bg.png");
    private static final ResourceLocation HEALTH_BAR_FULL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_fill.png");

    private static final ResourceLocation MANA_BAR_EMPTY =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_bg.png");
    private static final ResourceLocation MANA_BAR_FULL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/mana_bar_fill.png");

    private static final ResourceLocation XP_BG =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/xp_background.png");
    private static final ResourceLocation XP_FILL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/xp_fill.png");

    private static final ResourceLocation SPELL_CELL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/spellbar/spell_bar_cell.png");

    // ---- плавные значения ----
    private static final Map<UUID, Float> DISPLAYED_HEALTH = new ConcurrentHashMap<>();
    private static final Map<UUID, Float> DISPLAYED_MANA   = new ConcurrentHashMap<>();
    private static final Map<UUID, Float> DISPLAYED_XP     = new ConcurrentHashMap<>();
    private static final float LERP_ALPHA = 0.20f;

    // ---- хот-бар ----
    private static final int SPELL_CELL_W = 20;
    private static final int SPELL_CELL_H = 20;
    private static final int SPELL_CELL_PAD = 2;

    // ---- какие ванильные слои гасим ----
    private static final Set<ResourceLocation> VANILLA_LAYERS_TO_HIDE = Set.of(
            ResourceLocation.fromNamespaceAndPath("minecraft", "player_health"),
            ResourceLocation.fromNamespaceAndPath("minecraft", "armor_level")
    );

    /** Гасим ванильные слои, чтобы рисовать свои HP/броню/ману/XP. */
    @SubscribeEvent
    public static void onRenderGuiLayerPre(RenderGuiLayerEvent.Pre event) {
        if (VANILLA_LAYERS_TO_HIDE.contains(event.getName())) {
            event.setCanceled(true);
        }
    }

    /** Рисуем наш общий HUD и хот-бар. */
    @SubscribeEvent
    public static void onRenderGui(RenderGuiEvent.Post event) {
        Minecraft mc = Minecraft.getInstance();
        if (mc.player == null || mc.screen != null) return;

        var player = mc.player;

        // --- статы ---
        PlayerStatsAttachment statsAtt = player.getData(ModAttachments.PLAYER_STATS.get());
        if (statsAtt == null) return;

        var snap = statsAtt.getSnapshot();
        int health    = statsAtt.getCurrentHealth();
        int maxHealth = Math.max(1, (int) snap.maxHealth);
        int mana      = statsAtt.getCurrentMana();
        int maxMana   = Math.max(1, (int) snap.maxMana);

        // --- прогресс ---
        PlayerProgressAttachment progressAtt = player.getData(ModAttachments.PLAYER_PROGRESS.get());
        PlayerProgress progress = (progressAtt != null) ? progressAtt.toSnapshot() : PlayerProgress.DEFAULT;

        GuiGraphics gui = event.getGuiGraphics();
        int sw = mc.getWindow().getGuiScaledWidth();
        int sh = mc.getWindow().getGuiScaledHeight();
        UUID uuid = player.getUUID();

        // наши бары
        renderHealthBar(gui, mc, sw, sh, uuid, health, maxHealth);
        renderManaBar(gui, mc, sw, sh, uuid, mana, maxMana);
        renderXpIcon(gui, mc, sw, sh, uuid, progress);

        // хот-бар спеллов
        renderSpellHotbar(gui, mc, sw, sh);
    }

    // -------------------- отрисовка --------------------

    private static void renderHealthBar(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                        UUID uuid, int health, int maxHealth) {
        final int W = 120, H = 12;

        float disp = DISPLAYED_HEALTH.getOrDefault(uuid, (float) health);
        disp += (health - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, maxHealth));
        DISPLAYED_HEALTH.put(uuid, disp);

        int x = sw / 2 + ClientConfig.HEALTH_BAR_X.get();
        int y = sh + ClientConfig.HEALTH_BAR_Y.get();

        gui.blit(HEALTH_BAR_EMPTY, x, y, 0, 0, W, H, W, H);
        int filled = (int) (W * (disp / Math.max(1f, maxHealth)));
        if (filled > 0) gui.blit(HEALTH_BAR_FULL, x, y, 0, 0, filled, H, W, H);

        String text = health + "/" + maxHealth;
        gui.drawString(mc.font, Component.literal(text),
                x + W / 2 - mc.font.width(text) / 2,
                y + (H - mc.font.lineHeight) / 2,
                0xFFFFFF, true);
    }

    private static void renderManaBar(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                      UUID uuid, int mana, int maxMana) {
        final int W = 120, H = 12;

        float disp = DISPLAYED_MANA.getOrDefault(uuid, (float) mana);
        disp += (mana - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, maxMana));
        DISPLAYED_MANA.put(uuid, disp);

        int x = sw / 2 + ClientConfig.MANA_BAR_X.get();
        int y = sh + ClientConfig.MANA_BAR_Y.get();

        gui.blit(MANA_BAR_EMPTY, x, y, 0, 0, W, H, W, H);
        int filled = (int) (W * (disp / Math.max(1f, maxMana)));
        if (filled > 0) gui.blit(MANA_BAR_FULL, x, y, 0, 0, filled, H, W, H);

        String text = mana + "/" + maxMana;
        gui.drawString(mc.font, Component.literal(text),
                x + W / 2 - mc.font.width(text) / 2,
                y + (H - mc.font.lineHeight) / 2,
                0xFFFFFF, true);
    }

    private static void renderXpIcon(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                     UUID uuid, PlayerProgress progress) {
        final int W = 32, H = 32;

        int exp = progress.exp();
        int cap = Math.max(1, progress.expCap());

        float disp = DISPLAYED_XP.getOrDefault(uuid, (float) exp);
        disp += (exp - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, cap));
        DISPLAYED_XP.put(uuid, disp);

        int x = sw / 2 + ClientConfig.XP_ICON_X.get();
        int y = sh + ClientConfig.XP_ICON_Y.get();

        gui.blit(XP_BG, x, y, 0, 0, W, H, W, H);

        int filledH = (int) (H * (disp / (float) cap));
        if (filledH > 0) {
            gui.blit(XP_FILL, x, y + (H - filledH), 0, H - filledH, W, filledH, W, H);
        }

        String lvl = String.valueOf(progress.level());
        gui.drawString(mc.font, Component.literal(lvl),
                x + W / 2 - mc.font.width(lvl) / 2,
                y + H / 2 - mc.font.lineHeight / 2,
                0xFFFFFF, true);

        String expTxt = exp + "/" + cap;
        gui.drawString(mc.font, Component.literal(expTxt),
                x + W / 2 - mc.font.width(expTxt) / 2,
                y + H + 2,
                0xFFFFFF, false);
    }

    private static void renderSpellHotbar(GuiGraphics gg, Minecraft mc, int sw, int sh) {
        var p = mc.player;
        var loadout = p.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (loadout == null) return;

        final int CELLS = PlayerLoadoutAttachment.SLOTS; // 6
        final int CELL = 20; // 20x20, без отступов

        // 1) ширина полосы
        int totalW = CELLS * CELL;

        // 2) дефолт по X: центр экрана; по Y: ровно между прицелом (sh/2) и ванильным хотбаром (~sh - 22)
        int vanillaHotbarY = sh - 22;
        int midY = (sh / 2 + vanillaHotbarY) / 2;

        int x0 = (sw - totalW) / 2 + ClientConfig.SPELLBAR_X.get();
        int y0 = midY + ClientConfig.SPELLBAR_Y.get();

        // 3) рисуем все 6 ячеек
        for (int i = 0; i < CELLS; i++) {
            int x = x0 + i * CELL;
            int y = y0;

            // фон ячейки (твоя текстура 20x20)
            gg.blit(SPELL_CELL, x, y, 0, 0, CELL, CELL, CELL, CELL);

            var rl = loadout.get(i);

            // если слот пуст — ничего не пишем (ни хоткей, ни кд)
            if (rl == null) continue;

            // кулдаун
            int cd = loadout.getCooldown(i);
            if (cd > 0) {
                // тёмная маска поверх (оставим как заливку; если захочешь — заменим на текстуру маски)
                gg.fill(x + 1, y + 1, x + CELL - 1, y + CELL - 1, 0x80000000);
                String s = String.valueOf(cd / 20);
                gg.drawString(mc.font, s, x + (CELL - mc.font.width(s)) / 2, y + 5, 0xFFFFFFFF, false);
            }

            // хоткей (буква/цифра) — только если слот не пуст
            String hk = Hotkeys.spellKeyName(i);
            // рисуем в правом нижнем углу, вписываемся в ~8x9px
            int hkX = x + CELL - mc.font.width(hk) - 2;
            int hkY = y + CELL - 9;
            gg.drawString(mc.font, hk, hkX, hkY, 0xFFE6DDAA, false);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java -----
package com.doomspire.grimfate.client.gui;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.AbstractButton;
import net.minecraft.client.gui.components.Tooltip;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.client.event.ScreenEvent;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.CLIENT)
public final class InventoryTabsButtons {
    private InventoryTabsButtons() {}

    private static final ResourceLocation TAB_TEX =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/button_tab.png");
    private static final ResourceLocation ICON_STATS =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/icon_stats.png");
    private static final ResourceLocation ICON_SKILLS =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/icon_skills.png");

    // Держим ссылки для лайв-репозиционирования
    private static SpriteTabButton STATS_BTN;
    private static SpriteTabButton SKILLS_BTN;

    @SubscribeEvent
    public static void onInit(ScreenEvent.Init.Post e) {
        Screen screen = e.getScreen();
        if (!(screen instanceof InventoryScreen inv)) return;

        int left = inv.getGuiLeft();
        int top  = inv.getGuiTop();
        int w    = inv.getXSize();

        int xStats  = left + w + 2;
        int yStats  = top;
        int xSkills = xStats;
        int ySkills = yStats + 22;

        STATS_BTN = new SpriteTabButton(
                xStats, yStats,
                TAB_TEX, 20, 20, 60,
                ICON_STATS, 16, 48, 3, // 3 кадра у icon_stats
                () -> Minecraft.getInstance().setScreen(new InventoryWithStatsScreen(Minecraft.getInstance().player)));
        STATS_BTN.setTooltip(Tooltip.create(Component.translatable("grimfate.ui.stats.open")));

        SKILLS_BTN = new SpriteTabButton(
                xSkills, ySkills,
                TAB_TEX, 20, 20, 60,
                ICON_SKILLS, 16, 80, 5, // 5 кадров у icon_skills
                () -> {
                    var p = Minecraft.getInstance().player;
                    if (p != null) p.displayClientMessage(Component.literal("Древо не нарисовано, но открылось бы и все работает"), true);
                });

        SKILLS_BTN.setTooltip(Tooltip.create(Component.literal("Дерево навыков (WIP)")));

        e.addListener(STATS_BTN);
        e.addListener(SKILLS_BTN);
    }

    // Двигаем кнопки каждый кадр — они «клеятся» к инвентарю и при книге рецептов
    @SubscribeEvent
    public static void onRender(ScreenEvent.Render.Post e) {
        Screen screen = e.getScreen();
        if (!(screen instanceof InventoryScreen inv)) return;
        int left = inv.getGuiLeft();
        int top  = inv.getGuiTop();
        int w    = inv.getXSize();

        if (STATS_BTN != null) {
            STATS_BTN.setX(left + w + 2);
            STATS_BTN.setY(top);
        }
        if (SKILLS_BTN != null) {
            SKILLS_BTN.setX(left + w + 2);
            SKILLS_BTN.setY(top + 22);
        }
    }

    /** Кнопка-«таб»: фон 3 состояния, иконка — анимированный спрайт по времени. */
    static final class SpriteTabButton extends AbstractButton {
        private final ResourceLocation tabTex;
        private final int tabFrameW, tabFrameH, tabTexH;

        private final ResourceLocation iconTex;
        private final int iconFrame;   // размер кадра иконки (обычно 16)
        private final int iconTexH;    // высота текстуры иконки (для blit)
        private final int iconFrames;  // сколько кадров у иконки

        private boolean pressedVisual = false;
        private final Runnable onPress;

        SpriteTabButton(
                int x, int y,
                ResourceLocation tabTex, int tabFrameW, int tabFrameH, int tabTexH,
                ResourceLocation iconTex, int iconFrame, int iconTexH, int iconFrames,
                Runnable onPress
        ) {
            super(x, y, tabFrameW, tabFrameH, Component.empty());
            this.tabTex = tabTex;
            this.tabFrameW = tabFrameW;
            this.tabFrameH = tabFrameH;
            this.tabTexH = tabTexH;

            this.iconTex = iconTex;
            this.iconFrame = iconFrame;
            this.iconTexH = iconTexH;
            this.iconFrames = Math.max(1, iconFrames);

            this.onPress = onPress;
        }

        @Override
        protected void renderWidget(GuiGraphics g, int mouseX, int mouseY, float partialTick) {
            // Фон — по состоянию
            int state = this.isHovered() ? 1 : 0;
            if (pressedVisual) state = 2; // 0/1/2 = normal/hover/pressed
            int vTab = state * tabFrameH;
            g.blit(tabTex, getX(), getY(), 0, vTab, tabFrameW, tabFrameH, tabFrameW, tabTexH);

            // Иконка — анимируем по времени, независимо от состояния
            long ms = System.currentTimeMillis();
            int anim = (int)((ms / 200L) % iconFrames); // ~5 FPS
            int vIcon = anim * iconFrame;

            int ix = getX() + (tabFrameW - 16) / 2;
            int iy = getY() + (tabFrameH - 16) / 2;
            g.blit(iconTex, ix, iy, 0, vIcon, 16, 16, 16, iconTexH);
        }

        @Override
        public void onPress() {
            if (onPress != null) onPress.run();
        }

        @Override
        public boolean mouseClicked(double mx, double my, int button) {
            if (this.isMouseOver(mx, my)) pressedVisual = true;
            return super.mouseClicked(mx, my, button);
        }

        @Override
        public boolean mouseReleased(double mx, double my, int button) {
            pressedVisual = false;
            return super.mouseReleased(mx, my, button);
        }

        @Override
        protected void updateWidgetNarration(NarrationElementOutput narration) {
            this.defaultButtonNarrationText(narration);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java -----
package com.doomspire.grimfate.client.gui;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.network.ModNetworking;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.AbstractButton;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Player;

public class InventoryWithStatsScreen extends InventoryScreen {
    private static final int PANEL_W = 240;
    private static final int PANEL_H = 360;   // без скролла — делаем выше
    private static final int INV_SHIFT = 140; // инвентарь уезжает влево не полностью

    private static final ResourceLocation PANEL_BG =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/stats_panel_bg.png");
    private static final ResourceLocation CLOSE_TEX =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/close_btn.png");

    private int panelX, panelY;
    private int closeX, closeY;

    private boolean isMouseDown = false;

    // «+» кнопки для атрибутов
    private java.util.List<PlusBtn> plusButtons = java.util.Collections.emptyList();

    public InventoryWithStatsScreen(Player player) { super(player); }

    @Override
    protected void init() {
        super.init();

        // сдвигаем инвентарь влево
        this.leftPos -= INV_SHIFT;

        // панель прижата к правому краю инвентаря
        panelX = this.leftPos + this.imageWidth;
        panelY = this.topPos;

        // закрыть (12×12)
        closeX = panelX + PANEL_W - 12 - 4;
        closeY = panelY + 4;

        // строки атрибутов: аббревиатуры + «+»
        plusButtons = new java.util.ArrayList<>();
        int y = panelY + 30;
        int xPlus = panelX + PANEL_W - 10 - 12; // 12px ширина «+»

        AttrRow[] rows = new AttrRow[] {
                new AttrRow(Attributes.STRENGTH,     "СИЛ"),
                new AttrRow(Attributes.VITALITY,     "СТК"),
                new AttrRow(Attributes.INTELLIGENCE, "ИНТ"),
                new AttrRow(Attributes.SPIRIT,       "ДУХ"),
                new AttrRow(Attributes.DEXTERITY,    "ЛВК"),
                new AttrRow(Attributes.EVASION,      "УКЛ")
        };
        for (AttrRow r : rows) {
            PlusBtn btn = new PlusBtn(xPlus, y, () -> ModNetworking.sendAllocatePoint(r.id.name()));
            this.addRenderableWidget(btn);
            plusButtons.add(btn);
            y += (this.font.lineHeight + 6);
        }
    }

    @Override
    public void render(GuiGraphics g, int mouseX, int mouseY, float pt) {
        // фон
        this.renderBackground(g, mouseX, mouseY, pt);

        // инвентарь (уже сдвинут)
        super.render(g, mouseX, mouseY, pt);

        // фон панели (240×360)
        g.blit(PANEL_BG, panelX, panelY, 0, 0, PANEL_W, PANEL_H, PANEL_W, PANEL_H);

        // закрыть
        boolean overClose = mouseX >= closeX && mouseX <= closeX + 12 && mouseY >= closeY && mouseY <= closeY + 12;
        int v = overClose ? (isMouseDown ? 24 : 12) : 0;
        g.blit(CLOSE_TEX, closeX, closeY, 0, v, 12, 12, 12, 36);

        // данные игрока
        var p = this.minecraft.player;
        var progressAtt = p.getData(ModAttachments.PLAYER_PROGRESS.get());
        var statsAtt    = p.getData(ModAttachments.PLAYER_STATS.get());

        PlayerProgress prog = progressAtt != null ? progressAtt.toSnapshot() : PlayerProgress.DEFAULT;
        int unspent = statsAtt != null ? statsAtt.getUnspentPoints() : 0;

        // шапка
        g.drawString(this.font, "Lv." + prog.level(), panelX + 10, panelY + 10, 0xFFE6DDAA, false);
        g.drawString(this.font, "Unspent: " + unspent, panelX + 110, panelY + 10, 0xFFFFFF, false);

        // атрибуты (аббревиатуры слева, значения справа; «+» уже нарисованы как виджеты)
        int xLabel = panelX + 10;
        int xValue = panelX + PANEL_W - 10 - 12 - 6 - 24; // справа от значений остаётся место под «+»
        int y = panelY + 30;

        if (statsAtt != null) {
            // порядок в точности как у кнопок
            AttrRow[] rows = new AttrRow[] {
                    new AttrRow(Attributes.STRENGTH,     "СИЛ"),
                    new AttrRow(Attributes.VITALITY,     "СТК"),
                    new AttrRow(Attributes.INTELLIGENCE, "ИНТ"),
                    new AttrRow(Attributes.SPIRIT,       "ДУХ"),
                    new AttrRow(Attributes.DEXTERITY,    "ЛВК"),
                    new AttrRow(Attributes.EVASION,      "УКЛ")
            };
            for (AttrRow r : rows) {
                int val = statsAtt.getAttribute(r.id);
                g.drawString(this.font, r.label, xLabel, y, 0xFFFFFF, false);
                g.drawString(this.font, String.valueOf(val), xValue, y, 0xFFFFFF, false);
                y += (this.font.lineHeight + 6);
            }
        } else {
            g.drawString(this.font, "No stats data", xLabel, y, 0xFFFFFF, false);
            y += (this.font.lineHeight + 6);
        }

        // разделитель
        y += 4;
        g.fill(panelX + 10, y, panelX + PANEL_W - 10, y + 1, 0x44FFFFFF);
        y += 6;

        // Характеристики (готовые значения из snapshot)
        g.drawString(this.font, "Характеристики", xLabel, y, 0xFFE6DDAA, false);
        y += (this.font.lineHeight + 4);

        if (statsAtt != null) {
            var s = statsAtt.getSnapshot();

            y = statLine(g, xLabel, y, "Max HP", String.valueOf((int) s.maxHealth));
            y = statLine(g, xLabel, y, "Max MP", String.valueOf((int) s.maxMana));
            y = statLine(g, xLabel, y, "Regen HP/s", String.valueOf((int) s.regenHealth));
            y = statLine(g, xLabel, y, "Regen MP/s", String.valueOf((int) s.regenMana));
            y = statLine(g, xLabel, y, "Speed", String.format("+%.2f%%", s.moveSpeedPct)); // <— НОВОЕ

            // резисты
            for (var e : s.resistances.entrySet()) {
                y = statLine(g, xLabel, y, "Res " + e.getKey().name(), Math.round(e.getValue() * 100) + "%");
                if (y > panelY + PANEL_H - 20) break;
            }
            // урон
            for (var e : s.damage.entrySet()) {
                y = statLine(g, xLabel, y, "Dmg " + e.getKey().name(), String.format("%.1f", e.getValue()));
                if (y > panelY + PANEL_H - 20) break;
            }
        }

        this.renderTooltip(g, mouseX, mouseY);
    }

    private int statLine(GuiGraphics g, int x, int y, String label, String value) {
        g.drawString(this.font, label, x, y, 0xFFFFFF, false);
        int vx = panelX + PANEL_W - 10 - this.font.width(value);
        g.drawString(this.font, value, vx, y, 0xFFFFFF, false);
        return y + this.font.lineHeight + 2;
    }

    @Override
    public boolean mouseClicked(double mx, double my, int button) {
        isMouseDown = true;
        if (mx >= closeX && mx <= closeX + 12 && my >= closeY && my <= closeY + 12) {
            this.minecraft.setScreen(new InventoryScreen(this.minecraft.player));
            return true;
        }
        return super.mouseClicked(mx, my, button);
    }

    @Override
    public boolean mouseReleased(double mx, double my, int button) {
        isMouseDown = false;
        return super.mouseReleased(mx, my, button);
    }

    private record AttrRow(Attributes id, String label) {}

    /** маленькая квадратная кнопка «+» 12×12 */
    private static final class PlusBtn extends AbstractButton {
        private final Runnable onPress;

        PlusBtn(int x, int y, Runnable onPress) {
            super(x, y, 12, 12, Component.empty());
            this.onPress = onPress;
        }

        @Override
        protected void renderWidget(GuiGraphics g, int mouseX, int mouseY, float pt) {
            int col = this.isHovered() ? 0xAAFFFFFF : 0x66FFFFFF;
            // полупрозрачный фон
            g.fill(getX(), getY(), getX() + 12, getY() + 12, 0x33000000 | (col & 0x00FFFFFF));
            // плюсик
            g.drawString(Minecraft.getInstance().font, "+", getX() + 3, getY() + 1, 0xFFFFFFFF, false);
        }

        @Override
        public void onPress() {
            if (onPress != null) onPress.run();
        }

        @Override
        protected void updateWidgetNarration(NarrationElementOutput narration) {
            this.defaultButtonNarrationText(narration);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimfate.network.ModNetworking;
import net.minecraft.client.KeyMapping;
import net.minecraft.client.Minecraft;
import net.minecraft.client.player.LocalPlayer;
import net.neoforged.neoforge.client.event.ClientTickEvent;
import net.neoforged.neoforge.client.event.RegisterKeyMappingsEvent;
import org.lwjgl.glfw.GLFW;

public final class Hotkeys {
    private Hotkeys() {}

    private static final String CAT = "key.categories.grimfate";

    // Только слоты спеллов
    private static final String[] SPELL_IDS = {
            "key.grimfate.spellslot_1",
            "key.grimfate.spellslot_2",
            "key.grimfate.spellslot_3",
            "key.grimfate.spellslot_4",
            "key.grimfate.spellslot_5",
            "key.grimfate.spellslot_6"
    };
    private static final int[] DEFAULTS = {
            GLFW.GLFW_KEY_R, GLFW.GLFW_KEY_F, GLFW.GLFW_KEY_C,
            GLFW.GLFW_KEY_V, GLFW.GLFW_KEY_B, GLFW.GLFW_KEY_N
    };

    private static final KeyMapping[] SPELL_KEYS = new KeyMapping[6];

    private static boolean CREATED = false;
    private static boolean REGISTERED = false;

    private static void ensureCreated() {
        if (CREATED) return;
        CREATED = true;

        for (int i = 0; i < SPELL_KEYS.length; i++) {
            SPELL_KEYS[i] = new KeyMapping(SPELL_IDS[i], DEFAULTS[i], CAT);
        }
    }

    /** MOD-bus: регистрация key mappings. */
    public static void onRegisterKeys(RegisterKeyMappingsEvent e) {
        ensureCreated();
        if (REGISTERED) {
            // уже зарегистрировано
            return;
        }
        REGISTERED = true;

        for (KeyMapping km : SPELL_KEYS) e.register(km);
    }

    /** NeoForge-bus: обработка нажатий. */
    public static void onClientTick(ClientTickEvent.Post e) {
        Minecraft mc = Minecraft.getInstance();
        LocalPlayer p = mc.player;
        if (p == null) return;

        for (int i = 0; i < SPELL_KEYS.length; i++) {
            KeyMapping km = SPELL_KEYS[i];
            if (km != null && km.consumeClick()) {
                ModNetworking.sendCastSpellSlot(i);
            }
        }
    }

    public static String spellKeyName(int idx) {
        if (idx < 0 || idx >= SPELL_KEYS.length || SPELL_KEYS[idx] == null) return "?";
        return SPELL_KEYS[idx].getTranslatedKeyMessage().getString();
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java -----
package com.doomspire.grimfate.commands;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.commands.arguments.ResourceLocationArgument;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.exceptions.CommandSyntaxException;

import java.util.Collection;

public final class AddSpellCommand {

    private AddSpellCommand() {}

    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        dispatcher.register(Commands.literal("grimfate")
                .then(Commands.literal("addspell")
                        // /grimfate addspell <spell>  — для себя
                        .then(Commands.argument("spell", ResourceLocationArgument.id())
                                .executes(ctx -> {
                                    ServerPlayer self = ctx.getSource().getPlayerOrException();
                                    ResourceLocation rl = ResourceLocationArgument.getId(ctx, "spell");
                                    int added = addToPlayer(self, rl);
                                    if (added > 0) {
                                        ctx.getSource().sendSuccess(() ->
                                                Component.literal("Added spell " + rl + " to " + self.getGameProfile().getName()), true);
                                        return 1;
                                    } else {
                                        ctx.getSource().sendFailure(Component.literal("No free slot for " + rl + " on " + self.getGameProfile().getName()));
                                        return 0;
                                    }
                                }))
                        // /grimfate addspell <targets> <spell>
                        .then(Commands.argument("targets", EntityArgument.players())
                                .then(Commands.argument("spell", ResourceLocationArgument.id())
                                        .executes(ctx -> {
                                            Collection<ServerPlayer> targets = EntityArgument.getPlayers(ctx, "targets");
                                            ResourceLocation rl = ResourceLocationArgument.getId(ctx, "spell");
                                            int total = 0;
                                            for (ServerPlayer sp : targets) {
                                                total += addToPlayer(sp, rl);
                                            }
                                            if (total > 0) {
                                                final int count = total; // effectively final копия для лямбды
                                                ctx.getSource().sendSuccess(() ->
                                                        Component.literal("Added spell " + rl + " to " + count + " player(s)"), true);
                                                return total;
                                            } else {
                                                ctx.getSource().sendFailure(Component.literal("No recipients had a free slot for " + rl));
                                                return 0;
                                            }
                                        })))
                )
        );
    }

    /**
     * Пытается добавить спелл в первый свободный слот лоадаута игрока.
     * Возвращает 1 если добавлено, иначе 0.
     */
    private static int addToPlayer(ServerPlayer sp, ResourceLocation rl) throws CommandSyntaxException {
        PlayerLoadoutAttachment att = sp.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (att == null) {
            return 0;
        }
        for (int i = 0; i < PlayerLoadoutAttachment.SLOTS; i++) {
            if (att.get(i) == null) {
                att.set(i, rl);
                // Триггерим авто-синхронизацию (ModAttachments.PLAYER_LOADOUT должен быть зарегистрирован с .sync(...))
                sp.setData(ModAttachments.PLAYER_LOADOUT.get(), att);
                return 1;
            }
        }
        return 0;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java -----
package com.doomspire.grimfate.config;

import net.neoforged.fml.config.ModConfig;
import net.neoforged.neoforge.common.ModConfigSpec;

public class ClientConfig {
    public static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();

    public static final ModConfigSpec.IntValue HEALTH_BAR_X;
    public static final ModConfigSpec.IntValue HEALTH_BAR_Y;

    public static final ModConfigSpec.IntValue MANA_BAR_X;
    public static final ModConfigSpec.IntValue MANA_BAR_Y;

    public static final ModConfigSpec.IntValue XP_ICON_X;
    public static final ModConfigSpec.IntValue XP_ICON_Y;

    public static final ModConfigSpec.IntValue SPELLBAR_X;
    public static final ModConfigSpec.IntValue SPELLBAR_Y;

    static {
        SPELLBAR_X = BUILDER
                .comment("Смещение спелбара по X")
                .defineInRange("hud.spellbar_x", -60, -500, 500);

        SPELLBAR_Y = BUILDER
                .comment("Смещение спелбара по X")
                .defineInRange("hud.spellbar_y", -78, -500, 500);

        HEALTH_BAR_X = BUILDER
                .comment("Смещение полоски здоровья по X")
                .defineInRange("hud.health_bar_x", -60, -500, 500);

        HEALTH_BAR_Y = BUILDER
                .comment("Смещение полоски здоровья по Y")
                .defineInRange("hud.health_bar_y", -78, -500, 500);

        MANA_BAR_X = BUILDER
                .comment("Смещение полоски маны по X")
                .defineInRange("hud.mana_bar_x", -60, -500, 500);

        MANA_BAR_Y = BUILDER
                .comment("Смещение полоски маны по Y")
                .defineInRange("hud.mana_bar_y", -65, -500, 500);

        XP_ICON_X = BUILDER
                .comment("Смещение иконки опыта по X")
                .defineInRange("hud.xp_icon_x", -30, -500, 500);

        XP_ICON_Y = BUILDER
                .comment("Смещение иконки опыта по Y")
                .defineInRange("hud.xp_icon_y", -100, -500, 500);
    }

    public static final ModConfigSpec SPEC = BUILDER.build();
}



n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java -----
package com.doomspire.grimfate.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * 🔧 ModConfig — централизованный конфиг мода
 * В будущем:
 *  - хранение базовых статов для игроков и мобов
 *  - множители регена/урона
 *  - настройка аффиксов
 *  - редактирование через JSON без пересборки
 */
public class ModConfig {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final File CONFIG_FILE = new File("config/grimfate.json");

    // ===== Пример будущих параметров (пока закомментированы) =====

    // Базовые статы игрока
    // public int basePlayerHealth = 100;
    // public float basePlayerRegen = 0.5f; // 0.5 хп в сек.
    // public int basePlayerMana = 50;
    // public float manaRegenMultiplier = 1.0f;

    // Базовые статы мобов
    // public int baseMobHealth = 50;
    // public float baseMobRegen = 1.0f;

    // Множители урона/защиты
    // public float damageMultiplier = 1.0f;
    // public float defenseMultiplier = 1.0f;

    // Система аффиксов (позже)
    // public float affixDropChance = 0.1f;

    // =============================================================

    private static ModConfig INSTANCE = new ModConfig();

    public static ModConfig get() {
        return INSTANCE;
    }

    /** Загружаем конфиг из JSON */
    public static void load() {
        if (!CONFIG_FILE.exists()) {
            save(); // если файла нет, создаём дефолт
            return;
        }

        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            INSTANCE = GSON.fromJson(reader, ModConfig.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /** Сохраняем конфиг в JSON */
    public static void save() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(INSTANCE, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java -----
package com.doomspire.grimfate.core;

import java.util.List;

import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.neoforge.common.ModConfigSpec;

// An example config class. This is not required, but it's a good idea to have one to keep your config organized.
// Demonstrates how to use Neo's config APIs
public class Config {
    private static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();

    public static final ModConfigSpec.BooleanValue LOG_DIRT_BLOCK = BUILDER
            .comment("Whether to log the dirt block on common setup")
            .define("logDirtBlock", true);

    public static final ModConfigSpec.IntValue MAGIC_NUMBER = BUILDER
            .comment("A magic number")
            .defineInRange("magicNumber", 42, 0, Integer.MAX_VALUE);

    public static final ModConfigSpec.ConfigValue<String> MAGIC_NUMBER_INTRODUCTION = BUILDER
            .comment("What you want the introduction message to be for the magic number")
            .define("magicNumberIntroduction", "The magic number is... ");

    // a list of strings that are treated as resource locations for items
    public static final ModConfigSpec.ConfigValue<List<? extends String>> ITEM_STRINGS = BUILDER
            .comment("A list of items to log on common setup.")
            .defineListAllowEmpty("items", List.of("minecraft:iron_ingot"), () -> "", Config::validateItemName);

    static final ModConfigSpec SPEC = BUILDER.build();

    private static boolean validateItemName(final Object obj) {
        return obj instanceof String itemName && BuiltInRegistries.ITEM.containsKey(ResourceLocation.parse(itemName));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java -----
package com.doomspire.grimfate.core;

import com.doomspire.grimfate.commands.AddSpellCommand;
import com.doomspire.grimfate.config.ClientConfig;
import com.doomspire.grimfate.events.LoadoutTickEvents;
import com.doomspire.grimfate.events.StaffAttackEvents;
import com.doomspire.grimfate.network.ModNetworking;
import com.doomspire.grimfate.registry.ModEntityTypes;
import com.doomspire.grimfate.registry.ModItems;
import com.mojang.logging.LogUtils;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.CreativeModeTab;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;
import net.neoforged.fml.config.ModConfig;
import net.neoforged.fml.event.lifecycle.FMLCommonSetupEvent;
import net.neoforged.fml.loading.FMLEnvironment;
import net.neoforged.neoforge.event.BuildCreativeModeTabContentsEvent;
import net.neoforged.neoforge.event.RegisterCommandsEvent;
import net.neoforged.neoforge.event.server.ServerStartingEvent;
import net.neoforged.neoforge.registries.DeferredRegister;
import org.slf4j.Logger;

@Mod(Grimfate.MODID)
public class Grimfate {
    public static final String MODID = "grimfate";
    public static final Logger LOGGER = LogUtils.getLogger();

    public static final DeferredRegister<CreativeModeTab> CREATIVE_MODE_TABS =
            DeferredRegister.create(Registries.CREATIVE_MODE_TAB, MODID);

    public Grimfate(IEventBus modEventBus, ModContainer modContainer) {
        // Конфиги
        modContainer.registerConfig(ModConfig.Type.CLIENT, ClientConfig.SPEC);
        modContainer.registerConfig(ModConfig.Type.COMMON, Config.SPEC);

        // Сеть
        modEventBus.addListener(ModNetworking::register);

        // Контент
        CREATIVE_MODE_TABS.register(modEventBus);
        ModItems.init(modEventBus);
        ModEntityTypes.init(modEventBus);
        com.doomspire.grimfate.loot.ModLootModifiers.init(modEventBus);

        // Фазы
        modEventBus.addListener(this::commonSetup);
        modEventBus.addListener(this::addCreative);

        // Клиент — все клиентские MOD-бус листенеры (вместе с Hotkeys onRegisterKeys)
        if (FMLEnvironment.dist.isClient()) {
                GrimfateClient.registerModBusListeners(modEventBus);
            }

        // Игровые слушатели (Forge bus)
        StaffAttackEvents.register();
    }

    private void commonSetup(final FMLCommonSetupEvent e) { /* ... */ }

    private void addCreative(final BuildCreativeModeTabContentsEvent e) { /* ... */ }

    @net.neoforged.bus.api.SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent e) {
        AddSpellCommand.register(e.getDispatcher());
    }

    public static ResourceLocation rl(String path) {
        return ResourceLocation.fromNamespaceAndPath(MODID, path);
    }

    @net.neoforged.bus.api.SubscribeEvent
    public void onServerStarting(ServerStartingEvent event) { /* ... */ }
}
n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java -----
package com.doomspire.grimfate.core;

import com.doomspire.grimfate.client.Hotkeys;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import com.doomspire.grimfate.registry.ModEntityTypes;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.entity.ThrownItemRenderer;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.client.event.EntityRenderersEvent;
import net.neoforged.neoforge.client.event.RegisterKeyMappingsEvent;
import net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;
import net.neoforged.neoforge.common.NeoForge;

public final class GrimfateClient {
    private GrimfateClient() {}

    public static void registerModBusListeners(IEventBus modBus) {
        modBus.addListener(GrimfateClient::onRegisterRenderers);
        modBus.addListener(GrimfateClient::onClientSetup);
        // Ключевая строка: регистрируем KeyMappings только отсюда
        modBus.addListener(Hotkeys::onRegisterKeys);
    }

    static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers e) {
        e.registerEntityRenderer(ModEntityTypes.BOLT.get(),
                ctx -> new ThrownItemRenderer<BoltProjectileEntity>(ctx, 1.0f, false));
    }

    static void onClientSetup(FMLClientSetupEvent e) {
        Grimfate.LOGGER.info("Client setup OK. User={}", Minecraft.getInstance().getUser().getName());
        // Forge-bus listener для тиков — ровно один раз
        NeoForge.EVENT_BUS.addListener(Hotkeys::onClientTick);
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java -----
package com.doomspire.grimfate.entity;

import net.minecraft.core.particles.ParticleTypes;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.projectile.ThrowableItemProjectile;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.Level;
import net.minecraft.world.phys.HitResult;
import net.minecraft.world.phys.Vec3;

public class BoltProjectileEntity extends ThrowableItemProjectile {

    public BoltProjectileEntity(EntityType<? extends BoltProjectileEntity> type, Level level) {
        super(type, level);
        this.setNoGravity(true);
    }

    public BoltProjectileEntity(Level level, LivingEntity shooter) {
        this(com.doomspire.grimfate.registry.ModEntityTypes.BOLT.get(), level);
        this.setOwner(shooter);
        this.setNoGravity(true);
    }

    /** Отдаём клиенту предмет для ThrownItemRenderer. */
    @Override
    protected Item getDefaultItem() {
        return com.doomspire.grimfate.registry.ModItems.BOLT_ITEM.get();
    }

    /** Старт с небольшим смещением от глаз + задание скорости. */
    public void shootForward(LivingEntity shooter, float speed) {
        Vec3 look = shooter.getLookAngle();
        // смещение на полблока вперёд, чтобы не цеплять свой хитбокс
        this.setPos(
                shooter.getX() + look.x * 0.5,
                shooter.getEyeY() - 0.1 + look.y * 0.5,
                shooter.getZ() + look.z * 0.5
        );
        this.setDeltaMovement(look.normalize().scale(speed));
    }

    @Override
    protected void onHit(HitResult result) {
        super.onHit(result);

        if (!level().isClientSide) {
            // Небольшая частица в месте попадания
            ((ServerLevel) level()).sendParticles(ParticleTypes.CRIT, getX(), getY(), getZ(), 4, 0, 0, 0, 0.0);

            // Урон по цели, если есть «живая» цель
            if (result.getType() == HitResult.Type.ENTITY && getOwner() instanceof LivingEntity owner) {
                var hit = ((net.minecraft.world.phys.EntityHitResult) result).getEntity();
                if (hit instanceof LivingEntity target) {
                    // наш физ-ранжед, простой урон через ванильный DamageSource (ядро боя подключим позже)
                    DamageSource src = level().damageSources().indirectMagic(this, owner); // пока нейтральный DS
                    target.hurt(src, 5.0f); // базовый урон; позже подменим на DamageEngine
                }
            }
            discard();
        }
    }

    @Override
    public void tick() {
        super.tick();
        // Жизнь ~36 блоков при скорости ~1.8 => 20 тиков * 2 сек достаточно
        if (this.tickCount > 40) this.discard();
        if (level().isClientSide) {
            level().addParticle(ParticleTypes.CRIT, getX(), getY(), getZ(), 0, 0, 0);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java -----
package com.doomspire.grimfate.events;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.world.entity.player.Player;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.tick.PlayerTickEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.DEDICATED_SERVER) // слушаем только на сервере
public final class LoadoutTickEvents {
    private LoadoutTickEvents() {}

    private static final Map<UUID, Long> LAST_SYNC_TICK = new HashMap<>();
    private static final Map<UUID, Integer> LAST_SUM = new HashMap<>();
    private static final int SYNC_COOLDOWN_TICKS = 10; // ~0.5с при 20 TPS

    @SubscribeEvent
    public static void onPlayerTick(PlayerTickEvent.Post e) {
        Player p = e.getEntity();
        if (p.level().isClientSide) return;

        PlayerLoadoutAttachment att = p.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (att == null) return;

        // 1) уменьшаем кулдауны
        att.tickDown();

        // 2) считаем «суммарный кулдаун», чтобы дешево понимать, изменилось ли что-то
        int sum = 0;
        for (int i = 0; i < PlayerLoadoutAttachment.SLOTS; i++) {
            sum += att.getCooldown(i);
        }

        long now = p.level().getGameTime();
        UUID id = p.getUUID();
        long last = LAST_SYNC_TICK.getOrDefault(id, 0L);
        int prev = LAST_SUM.getOrDefault(id, -1);

        // 3) синкаем только если:
        //  - прошло >= SYNC_COOLDOWN_TICKS тиков
        //  - изменилась агрегированная сумма (включая переход в ноль)
        if ((now - last) >= SYNC_COOLDOWN_TICKS && sum != prev) {
            p.setData(ModAttachments.PLAYER_LOADOUT.get(), att); // триггерит .sync(...) из ModAttachments
            LAST_SYNC_TICK.put(id, now);
            LAST_SUM.put(id, sum);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\StaffAttackEvents.java -----
package com.doomspire.grimfate.events;

import com.doomspire.grimfate.network.payload.C2SCastStaffBoltPayload;
import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.item.ItemStack;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.AttackEntityEvent;
import net.neoforged.neoforge.event.entity.player.PlayerInteractEvent;
import net.neoforged.neoforge.network.PacketDistributor;

public final class StaffAttackEvents {
    private StaffAttackEvents(){}

    public static void register() {
        NeoForge.EVENT_BUS.register(StaffAttackEvents.class);
    }

    /** ЛКМ по сущности → отменяем ванильный удар и шлём наш каст (если в руке посох). */
    @SubscribeEvent
    public static void onAttackEntity(AttackEntityEvent e) {
        var p = e.getEntity();
        ItemStack main = p.getMainHandItem();
        if (main.is(ModItems.STAFF.get())) {
            e.setCanceled(true);
            PacketDistributor.sendToServer(new C2SCastStaffBoltPayload());
            p.swing(InteractionHand.MAIN_HAND); // анимация на клиенте, звук играет сервер при спавне
        }
    }

    /** ЛКМ в воздухе → тоже каст (если посох). ЛКМ по блоку оставляем ванили (копание). */
    @SubscribeEvent
    public static void onLeftClickEmpty(PlayerInteractEvent.LeftClickEmpty e) {
        var p = e.getEntity();
        ItemStack main = p.getMainHandItem();
        if (main.is(ModItems.STAFF.get())) {
            PacketDistributor.sendToServer(new C2SCastStaffBoltPayload());
            p.swing(InteractionHand.MAIN_HAND);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\StaffAttackEvents.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java -----
package com.doomspire.grimfate.item;

import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BlockEntityWithoutLevelRenderer;
import net.minecraft.world.item.Item;
import net.neoforged.neoforge.client.extensions.common.IClientItemExtensions;

import java.util.function.Consumer;

public class StaffItem extends Item {
    public StaffItem(Properties props) {
        super(props);
    }
    // Атака происходит не тут, а через ивенты (см. StaffAttackEvents) — так мы сохраняем копание блоков по ЛКМ
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java -----
package com.doomspire.grimfate.loot;

import com.doomspire.grimfate.core.Grimfate;
import com.mojang.serialization.MapCodec;
import net.neoforged.neoforge.common.loot.IGlobalLootModifier;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.NeoForgeRegistries;

public final class ModLootModifiers {
    private ModLootModifiers() {}

    // Регистрируем КОДЕКИ модификаторов лута
    public static final DeferredRegister<MapCodec<? extends IGlobalLootModifier>> GLM_SERIALIZERS =
            DeferredRegister.create(NeoForgeRegistries.Keys.GLOBAL_LOOT_MODIFIER_SERIALIZERS, Grimfate.MODID);

    public static final DeferredHolder<MapCodec<? extends IGlobalLootModifier>, MapCodec<RustyRingDropModifier>> RUSTY_RING =
            GLM_SERIALIZERS.register("rusty_ring", () -> RustyRingDropModifier.CODEC);

    public static void init(net.neoforged.bus.api.IEventBus modBus) {
        GLM_SERIALIZERS.register(modBus);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\RustyRingDropModifier.java -----
package com.doomspire.grimfate.loot;

import com.doomspire.grimcore.data.ModDataComponents;
import com.doomspire.grimcore.data.component.StatBonusComponent;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.registry.ModItems;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.storage.loot.LootContext;
import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
import net.neoforged.neoforge.common.loot.IGlobalLootModifier;
import net.neoforged.neoforge.common.loot.LootModifier;

import java.util.Map;

/** Простой GLM: с заданным шансом добавляет grimfate:rusty_ring (+1 SPIRIT). */
public class RustyRingDropModifier extends LootModifier {

    public static final MapCodec<RustyRingDropModifier> CODEC = RecordCodecBuilder.mapCodec(inst ->
            LootModifier.codecStart(inst)
                    .and(Codec.DOUBLE.fieldOf("chance").forGetter(m -> m.chance))
                    .apply(inst, RustyRingDropModifier::new)
    );

    private final double chance;

    public RustyRingDropModifier(LootItemCondition[] conditions, double chance) {
        super(conditions);
        this.chance = chance;
    }

    @Override
    public MapCodec<? extends IGlobalLootModifier> codec() { return CODEC; }

    @Override
    protected ObjectArrayList<ItemStack> doApply(ObjectArrayList<ItemStack> generatedLoot, LootContext ctx) {
        // ✅ Ограничиваемся сундуками: имя лут-таблицы должно содержать "chests/"
        ResourceLocation tableId = ctx.getQueriedLootTableId();
        if (tableId == null || !tableId.getPath().contains("chests/")) return generatedLoot;

        if (ctx.getRandom().nextDouble() > this.chance) return generatedLoot;

        ItemStack ring = new ItemStack(ModItems.RUSTY_RING.get());

        // Компонент: +1 к SPIRIT
        ring.set(ModDataComponents.STAT_BONUS.get(),
                new StatBonusComponent(Map.of(Attributes.SPIRIT, 1)));

        generatedLoot.add(ring);
        Grimfate.LOGGER.debug("[GLM] rusty_ring: ADDED to {}", tableId);
        return generatedLoot;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\RustyRingDropModifier.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.spell.GrimSpells;
import com.doomspire.grimcore.spell.api.CastResult;
import com.doomspire.grimcore.spell.api.SpellContext;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatEffects;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import com.doomspire.grimfate.network.payload.C2SAllocatePointPayload;
import com.doomspire.grimfate.network.payload.C2SCastSpellSlotPayload;
import com.doomspire.grimfate.network.payload.C2SCastStaffBoltPayload;
import com.doomspire.grimfate.network.payload.S2CAllocateResultPayload;
import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.client.Minecraft;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;
import net.neoforged.neoforge.network.handling.IPayloadContext;

import java.util.UUID;

public final class ModNetworking {
    private ModNetworking() {}

    public static void register(RegisterPayloadHandlersEvent e) {
        var reg = e.registrar("grimfate");

        reg.playToServer(C2SAllocatePointPayload.TYPE, C2SAllocatePointPayload.STREAM_CODEC,
                ModNetworking::handleAllocatePoint);

        reg.playToClient(S2CAllocateResultPayload.TYPE, S2CAllocateResultPayload.STREAM_CODEC,
                ModNetworking::handleAllocateResult);

        reg.playToServer(C2SCastStaffBoltPayload.TYPE, C2SCastStaffBoltPayload.STREAM_CODEC,
                ModNetworking::handleCastStaffBolt);

        reg.playToServer(C2SCastSpellSlotPayload.TYPE, C2SCastSpellSlotPayload.STREAM_CODEC,
                ModNetworking::handleCastSpellSlot);
    }

    /** Клиентский хелпер для отправки каста болта. */
    public static void sendCastStaffBolt() {
        PacketDistributor.sendToServer(new C2SCastStaffBoltPayload());
    }

    public static void sendAllocatePoint(String attrId) {
        PacketDistributor.sendToServer(new C2SAllocatePointPayload(attrId));
    }

    // === handlers ===

    private static void handleAllocatePoint(C2SAllocatePointPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (att == null) return;

            Attributes attr = PlayerStatsAttachment.parseAttrId(msg.attributeId());
            if (attr == null) return;

            boolean ok = att.tryAllocatePoint(attr);
            int allocated = att.getAttribute(attr);
            int unspent   = att.getUnspentPoints();

            PacketDistributor.sendToPlayer(sp, new S2CAllocateResultPayload(attr.name(), allocated, unspent));

            att.markDirty();
            GrimcoreNetworking.syncPlayerStats(sp, att);

            // ⬇️ ТОЛЬКО вызов ядра — никаких модификаторов в ModNetworking
            StatEffects.applyAll(sp);
        });
    }

    private static void handleAllocateResult(S2CAllocateResultPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            var mc = Minecraft.getInstance();
            if (mc.player == null) return;

            var att = mc.player.getData(ModAttachments.PLAYER_STATS.get());
            if (att != null) {
                Attributes attr = PlayerStatsAttachment.parseAttrId(msg.attributeId());
                if (attr != null) {
                    att.setAttribute(attr, msg.newAllocated());
                }
                att.setUnspentPoints(msg.unspent());
                att.markDirty();
            }
            // UI обновится сам — экран читает свежие данные из Attachment.
        });
    }

    private static void handleCastStaffBolt(C2SCastStaffBoltPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            var stack = sp.getMainHandItem();
            if (!stack.is(ModItems.STAFF.get())) return;

            if (sp.getCooldowns().isOnCooldown(ModItems.STAFF.get())) return;

            var att = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (att == null) return;

            if (att.getCurrentMana() < 2) return;

            att.setCurrentMana(att.getCurrentMana() - 2);
            att.markDirty();
            GrimcoreNetworking.syncPlayerStats(sp, att);

            var bolt = new BoltProjectileEntity(sp.level(), sp);
            bolt.shootForward(sp, 1.8f);
            sp.level().addFreshEntity(bolt);

            sp.getCooldowns().addCooldown(ModItems.STAFF.get(), 20);
            sp.level().playSound(null, sp.getX(), sp.getY(), sp.getZ(),
                    SoundEvents.WITHER_SHOOT, SoundSource.PLAYERS, 0.6f, 1.0f);
        });
    }

    private static void handleCastSpellSlot(C2SCastSpellSlotPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            int slot = msg.slot();
            if (slot < 0 || slot >= PlayerLoadoutAttachment.SLOTS) return;

            PlayerLoadoutAttachment loadout = sp.getData(ModAttachments.PLAYER_LOADOUT.get());
            if (loadout == null) return;

            if (loadout.getCooldown(slot) > 0) return;

            ResourceLocation spellId = loadout.get(slot);
            if (spellId == null) return;

            var spell = GrimSpells.get(spellId);
            if (spell == null) return;

            var lvl = sp.serverLevel();
            var ctxSpell = new SpellContext(lvl, sp, slot, 0, 0, 0, null);

            int cost = Math.max(0, spell.manaCost(ctxSpell));
            int cd   = Math.max(0, spell.cooldownTicks(ctxSpell));

            var stats = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (stats == null) return;
            if (stats.getCurrentMana() < cost) return;

            CastResult result = spell.cast(ctxSpell);
            if (result == CastResult.OK) {
                stats.setCurrentMana(stats.getCurrentMana() - cost);
                stats.markDirty();
                GrimcoreNetworking.syncPlayerStats(sp, stats);

                loadout.setCooldown(slot, cd);
                sp.setData(ModAttachments.PLAYER_LOADOUT.get(), loadout);
            }
        });
    }

    public static void sendCastSpellSlot(int slot) {
        PacketDistributor.sendToServer(new C2SCastSpellSlotPayload(slot));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SAllocatePointPayload(String attributeId) implements CustomPacketPayload {
    public static final Type<C2SAllocatePointPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_allocate_point"));

    public static final StreamCodec<RegistryFriendlyByteBuf, C2SAllocatePointPayload> STREAM_CODEC =
            StreamCodec.composite(
                    ByteBufCodecs.STRING_UTF8, C2SAllocatePointPayload::attributeId,
                    C2SAllocatePointPayload::new
            );

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SCastSpellSlotPayload(int slot) implements CustomPacketPayload {
    public static final Type<C2SCastSpellSlotPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_cast_spell_slot"));
    public static final StreamCodec<RegistryFriendlyByteBuf, C2SCastSpellSlotPayload> STREAM_CODEC =
            StreamCodec.of((buf, msg) -> ByteBufCodecs.VAR_INT.encode(buf, msg.slot),
                    buf -> new C2SCastSpellSlotPayload(ByteBufCodecs.VAR_INT.decode(buf)));

    @Override public Type<? extends CustomPacketPayload> type() { return TYPE; }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastStaffBoltPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SCastStaffBoltPayload() implements CustomPacketPayload {
    public static final Type<C2SCastStaffBoltPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_cast_staff_bolt"));

    // Пустой payload — всё считаем на сервере
    public static final StreamCodec<RegistryFriendlyByteBuf, C2SCastStaffBoltPayload> STREAM_CODEC =
            StreamCodec.of((buf, msg) -> {}, buf -> new C2SCastStaffBoltPayload());

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastStaffBoltPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record S2CAllocateResultPayload(String attributeId, int newAllocated, int unspent)
        implements CustomPacketPayload {

    public static final Type<S2CAllocateResultPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "s2c_allocate_result"));

    public static final StreamCodec<RegistryFriendlyByteBuf, S2CAllocateResultPayload> STREAM_CODEC =
            StreamCodec.composite(
                    ByteBufCodecs.STRING_UTF8, S2CAllocateResultPayload::attributeId,
                    ByteBufCodecs.VAR_INT,    S2CAllocateResultPayload::newAllocated,
                    ByteBufCodecs.VAR_INT,    S2CAllocateResultPayload::unspent,
                    S2CAllocateResultPayload::new
            );

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.MobCategory;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModEntityTypes {
    private ModEntityTypes(){}

    public static final DeferredRegister<EntityType<?>> ENTITIES =
            DeferredRegister.create(Registries.ENTITY_TYPE, Grimfate.MODID);

    public static final DeferredHolder<EntityType<?>, EntityType<BoltProjectileEntity>> BOLT =
            ENTITIES.register("bolt", () -> EntityType.Builder
                    .<BoltProjectileEntity>of(BoltProjectileEntity::new, MobCategory.MISC)
                    .sized(0.25f, 0.25f)
                    .clientTrackingRange(64)
                    .updateInterval(2)
                    .build(Grimfate.MODID + ":bolt"));

    public static void init(IEventBus modBus) {
        ENTITIES.register(modBus);
    }
}



n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.item.StaffItem;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.Rarity;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModItems {
    private ModItems(){}

    public static final DeferredRegister<Item> ITEMS =
            DeferredRegister.create(Registries.ITEM, Grimfate.MODID);

    public static final DeferredHolder<Item, Item> RUSTY_RING = ITEMS.register("rusty_ring",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .rarity(Rarity.UNCOMMON)
            ));

    public static final DeferredHolder<Item, Item> STAFF =
            ITEMS.register("staff", () -> new StaffItem(new Item.Properties().stacksTo(1)));

    /** Используется рендерером болта — простой предмет-«обёртка» для модели снаряда. */
    public static final DeferredHolder<Item, Item> BOLT_ITEM =
            ITEMS.register("bolt", () -> new Item(new Item.Properties()));

    public static void init(IEventBus modBus) {
        ITEMS.register(modBus);
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\spell\FireboltEntity.java -----
package com.doomspire.grimfate.spell;

import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.projectile.SmallFireball;
import net.minecraft.world.level.Level;
import net.minecraft.world.phys.Vec3;

/**
 * Кастомный фаерболт с полем урона.
 */
public class FireboltEntity extends SmallFireball {
    private final int spellDamage;

    public FireboltEntity(Level level, LivingEntity shooter, Vec3 direction, int damage) {
        // используем стандартный EntityType.SMALL_FIREBALL
        super(EntityType.SMALL_FIREBALL, level);
        this.setOwner(shooter);

        // Задаём вектор движения (скорость)
        this.setDeltaMovement(direction);

        this.spellDamage = damage;
    }

    public int getSpellDamage() {
        return spellDamage;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\spell\FireboltEntity.java -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\lang\en_us.json -----
{
  "key.categories.grimfate": "Grimfate",
  "key.grimfate.open_stats": "Open Stats",

  "key.grimfate.spellslot_1": "Spell Slot 1",
  "key.grimfate.spellslot_2": "Spell Slot 2",
  "key.grimfate.spellslot_3": "Spell Slot 3",
  "key.grimfate.spellslot_4": "Spell Slot 4",
  "key.grimfate.spellslot_5": "Spell Slot 5",
  "key.grimfate.spellslot_6": "Spell Slot 6",

  "screen.grimfate.stats_hub": "Attributes",
  "screen.grimfate.unspent": "Unspent points: %s",

  "attr.grimfate.vitality": "Vitality",
  "attr.grimfate.strength": "Strength",
  "attr.grimfate.intelligence": "Intelligence",
  "attr.grimfate.spirit": "Spirit",
  "attr.grimfate.dexterity": "Dexterity",
  "attr.grimfate.evasion": "Evasion",

  "attr.tip.vitality": "Increases health and regen.",
  "attr.tip.strength": "Increases physical melee damage.",
  "attr.tip.intelligence": "Increases spell power.",
  "attr.tip.spirit": "Increases max mana and mana regen.",
  "attr.tip.dexterity": "Increases physical ranged damage.",
  "attr.tip.evasion": "Dodge chance.",

  "grimfate.ui.stats.open": "Open Attributes",

"item.grimfate.rusty_ring": "Rusty Ring"
}


n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\lang\en_us.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json -----
{
  "key.categories.grimfate": "GrimFate",
  "key.grimfate.open_stats": "Открыть характеристики",

  "key.grimfate.spellslot_1": "Слот умения 1",
  "key.grimfate.spellslot_2": "Слот умения 2",
  "key.grimfate.spellslot_3": "Слот умения 3",
  "key.grimfate.spellslot_4": "Слот умения 4",
  "key.grimfate.spellslot_5": "Слот умения 5",
  "key.grimfate.spellslot_6": "Слот умения 6",

  "screen.grimfate.stats_hub": "Attributes",
  "screen.grimfate.unspent": "Unspent points: %s",

  "attr.grimfate.vitality": "Vitality",
  "attr.grimfate.strength": "Strength",
  "attr.grimfate.intelligence": "Intelligence",
  "attr.grimfate.spirit": "Spirit",
  "attr.grimfate.dexterity": "Dexterity",
  "attr.grimfate.evasion": "Evasion",

  "attr.tip.vitality": "Increases health and regen.",
  "attr.tip.strength": "Increases physical melee damage.",
  "attr.tip.intelligence": "Increases spell power.",
  "attr.tip.spirit": "Increases max mana and mana regen.",
  "attr.tip.dexterity": "Increases physical ranged damage.",
  "attr.tip.evasion": "Dodge chance.",

  "grimfate.ui.stats.open": "Открыть атрибуты",

  "item.grimfate.rusty_ring": "Rusty Ring"
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\bolt.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"textures": {
		"0": "grimfate:item/bolt_texture",
		"particle": "grimfate:item/bolt_texture"
	},
	"elements": [
		{
			"from": [0, 0, 0],
			"to": [3, 3, 3],
			"rotation": {"angle": 0, "axis": "y", "origin": [1, 0, 0]},
			"faces": {
				"north": {"uv": [0, 0, 3, 3], "texture": "#0"},
				"east": {"uv": [0, 3, 3, 6], "texture": "#0"},
				"south": {"uv": [3, 0, 6, 3], "texture": "#0"},
				"west": {"uv": [3, 3, 6, 6], "texture": "#0"},
				"up": {"uv": [3, 9, 0, 6], "texture": "#0"},
				"down": {"uv": [9, 0, 6, 3], "texture": "#0"}
			}
		}
	],
	"display": {
		"thirdperson_righthand": {
			"translation": [5, 6.75, 6.25]
		},
		"thirdperson_lefthand": {
			"translation": [-8, 6.75, 5.75]
		},
		"firstperson_righthand": {
			"translation": [16, 4, 0]
		},
		"firstperson_lefthand": {
			"translation": [4, 3.25, 0]
		},
		"ground": {
			"translation": [5.75, 3, 7]
		},
		"gui": {
			"translation": [26, 26, 0],
			"scale": [4, 4, 4]
		},
		"head": {
			"translation": [6.5, 13, 0]
		},
		"fixed": {
			"translation": [6.5, 6.25, 6.5]
		}
	}
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\bolt.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rusty_ring.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/rusty_ring"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rusty_ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\staff.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"ambientocclusion": false,
	"textures": {
		"0": "grimfate:item/staff_texture",
		"particle": "grimfate:item/staff_texture"
	},
	"elements": [
		{
			"from": [7, 0, 8.5],
			"to": [7.5, 15, 9],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 0, 7]},
			"faces": {
				"north": {"uv": [0, 0, 0.5, 15], "texture": "#0"},
				"east": {"uv": [1, 0, 1.5, 15], "texture": "#0"},
				"south": {"uv": [2, 0, 2.5, 15], "texture": "#0"},
				"west": {"uv": [3, 0, 3.5, 15], "texture": "#0"},
				"up": {"uv": [8.5, 6.5, 8, 6], "texture": "#0"},
				"down": {"uv": [8.5, 7, 8, 7.5], "texture": "#0"}
			}
		},
		{
			"from": [6.95, 7, 8.45],
			"to": [7.55, 9, 9.05],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 7, 7]},
			"faces": {
				"north": {"uv": [4, 0, 4.5, 2], "texture": "#0"},
				"east": {"uv": [4, 2, 4.5, 4], "texture": "#0"},
				"south": {"uv": [4, 4, 4.5, 6], "texture": "#0"},
				"west": {"uv": [5, 0, 5.5, 2], "texture": "#0"},
				"up": {"uv": [8.5, 8.5, 8, 8], "texture": "#0"},
				"down": {"uv": [9.5, 0, 9, 0.5], "texture": "#0"}
			}
		},
		{
			"from": [6.85, -0.6, 8.35],
			"to": [7.65, 0, 9.15],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, -2, 7]},
			"faces": {
				"north": {"uv": [4, 8, 4.75, 8.5], "texture": "#0"},
				"east": {"uv": [8, 4, 8.75, 4.5], "texture": "#0"},
				"south": {"uv": [5, 8, 5.75, 8.5], "texture": "#0"},
				"west": {"uv": [8, 5, 8.75, 5.5], "texture": "#0"},
				"up": {"uv": [8.75, 2.75, 8, 2], "texture": "#0"},
				"down": {"uv": [8.75, 3, 8, 3.75], "texture": "#0"}
			}
		},
		{
			"from": [6.95, 14.15, 8.45],
			"to": [7.55, 15.4, 9.05],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 13.4, 7]},
			"faces": {
				"north": {"uv": [7, 5, 7.5, 6.25], "texture": "#0"},
				"east": {"uv": [6, 7, 6.5, 8.25], "texture": "#0"},
				"south": {"uv": [7, 7, 7.5, 8.25], "texture": "#0"},
				"west": {"uv": [8, 0, 8.5, 1.25], "texture": "#0"},
				"up": {"uv": [9.5, 1.5, 9, 1], "texture": "#0"},
				"down": {"uv": [9.5, 2, 9, 2.5], "texture": "#0"}
			}
		},
		{
			"from": [6.75, 15.35, 8.25],
			"to": [7.75, 15.6, 9.25],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 14.6, 7]},
			"faces": {
				"north": {"uv": [9, 3, 10, 3.25], "texture": "#0"},
				"east": {"uv": [4, 9, 5, 9.25], "texture": "#0"},
				"south": {"uv": [9, 4, 10, 4.25], "texture": "#0"},
				"west": {"uv": [5, 9, 6, 9.25], "texture": "#0"},
				"up": {"uv": [6, 3, 5, 2], "texture": "#0"},
				"down": {"uv": [6, 3, 5, 4], "texture": "#0"}
			}
		},
		{
			"from": [6.75, 15.15, 7.15],
			"to": [7.75, 16.15, 8.15],
			"rotation": {"angle": -45, "axis": "x", "origin": [7, 17.4, 7.1]},
			"faces": {
				"north": {"uv": [5, 4, 6, 5], "texture": "#0"},
				"east": {"uv": [5, 5, 6, 6], "texture": "#0"},
				"south": {"uv": [6, 0, 7, 1], "texture": "#0"},
				"west": {"uv": [6, 1, 7, 2], "texture": "#0"},
				"up": {"uv": [7, 3, 6, 2], "texture": "#0"},
				"down": {"uv": [7, 3, 6, 4], "texture": "#0"}
			}
		},
		{
			"from": [6.45, 16.05, 7.9],
			"to": [7.45, 17.05, 8.9],
			"rotation": {"angle": 45, "axis": "y", "origin": [7.5, 18.3, 8.2]},
			"faces": {
				"north": {"uv": [4, 6, 5, 7], "texture": "#0"},
				"east": {"uv": [6, 4, 7, 5], "texture": "#0"},
				"south": {"uv": [5, 6, 6, 7], "texture": "#0"},
				"west": {"uv": [6, 5, 7, 6], "texture": "#0"},
				"up": {"uv": [7, 7, 6, 6], "texture": "#0"},
				"down": {"uv": [8, 0, 7, 1], "texture": "#0"}
			}
		},
		{
			"from": [5.35, 15.95, 8.25],
			"to": [6.35, 16.95, 9.25],
			"rotation": {"angle": 45, "axis": "z", "origin": [6.4, 18.2, 8.6]},
			"faces": {
				"north": {"uv": [7, 1, 8, 2], "texture": "#0"},
				"east": {"uv": [7, 2, 8, 3], "texture": "#0"},
				"south": {"uv": [7, 3, 8, 4], "texture": "#0"},
				"west": {"uv": [4, 7, 5, 8], "texture": "#0"},
				"up": {"uv": [8, 5, 7, 4], "texture": "#0"},
				"down": {"uv": [6, 7, 5, 8], "texture": "#0"}
			}
		}
	],
	"display": {
		"thirdperson_righthand": {
			"translation": [1, -1.5, 0],
			"scale": [2, 2, 2]
		},
		"thirdperson_lefthand": {
			"translation": [-2.25, 0, 0],
			"scale": [2, 2, 2]
		},
		"firstperson_righthand": {
			"translation": [2.25, -3.75, 0],
			"scale": [2, 2, 2]
		},
		"firstperson_lefthand": {
			"translation": [0, -3.25, 0],
			"scale": [2, 2, 2]
		},
		"ground": {
			"rotation": [0, 0, 90],
			"translation": [0, -5, 0],
			"scale": [2, 2, 2]
		},
		"gui": {
			"rotation": [0, 0, -40],
			"translation": [0.5, -1, 0]
		},
		"fixed": {
			"rotation": [0, 0, 40],
			"translation": [1.25, 2, -2],
			"scale": [2, 2, 2]
		}
	}
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\staff.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\attributes.json -----
{
  "attributes": {
    "vitality":     { "cap": 99, "max_health_per": 6.0, "regen_hp_per": 0.06 },
    "strength":     { "cap": 99, "melee_damage_per": 0.7 },
    "intelligence": { "cap": 99, "spell_power_per": 0.7 },
    "spirit":       { "cap": 99, "max_mana_per": 10.0, "regen_mp_per": 0.08 },
    "dexterity":    { "cap": 99, "cast_speed_per": 0.5 },
    "evasion":      { "cap": 100, "evasion_per": 0.5 }
  }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\attributes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\levels.json -----
{
  "max_level": 50,
  "base": 100.0,
  "growth": 1.10
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\levels.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\spells.json -----
{
  "spells": {
    "grimfate:staff_bolt": {
      "school": "TECHNIQUE",
      "tags": ["PROJECTILE", "RANGED", "WEAPON_SKILL"],
      "base_cost": 2,
      "base_cooldown": 20,
      "scaling": { "dexterity": 0.25, "spirit": 0.10 }
    },
    "grimfate:warcry_shout": {
      "school": "WARCRY",
      "tags": ["BUFF", "AREA"],
      "base_cost": 10,
      "base_cooldown": 200,
      "scaling": { "strength": 0.6, "spirit": 0.2 }
    },
    "grimfate:knight_dash": {
      "school": "TECHNIQUE",
      "tags": ["MOVEMENT"],
      "base_cost": 8,
      "base_cooldown": 60,
      "scaling": { "dexterity": 0.7 }
    },
    "grimfate:fire_bolt": {
      "school": "FIRE",
      "tags": ["PROJECTILE", "RANGED"],
      "base_cost": 20,
      "base_cooldown": 20,
      "scaling": { "intelligence": 0.8 }
    }
  }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\spells.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\rusty_ring.json -----
{
  "type": "grimfate:rusty_ring",
  "chance": 0.95,
  "conditions": [
    { "condition": "random_chance", "chance": 1.0 }
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\rusty_ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\staff.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": ["  S", " S ", "W  "],
  "key": {
    "S": { "item": "minecraft:stick" },
    "W": { "tag": "minecraft:planks" }
  },
  "result": { "id": "grimfate:staff", "count": 1 }
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\staff.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\staves.json -----
{
  "replace": false,
  "values": ["grimfate:staff"]
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\staves.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json -----
{
  "replace": false,
  "entries": [
    "grimfate:rusty_ring"
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json -----n
