=== FILE STRUCTURE (relative to D:\doomspire) ===
.\gradle.properties
.\grimcore\src\main\java\com\doomspire\grimcore\affix\Affix.java
.\grimcore\src\main\java\com\doomspire\grimcore\affix\AffixAggregator.java
.\grimcore\src\main\java\com\doomspire\grimcore\affix\ModAffixes.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobThreatAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\ThreatService.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java
.\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java
.\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java
.\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\ResistBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java
.\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java
.\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\WeaponGate.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\WeaponRequirement.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltResult.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltService.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\impl\AutoBoltSpell.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java
.\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java
.\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java
.\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json
.\grimfate\src\main\java\com\doomspire\grimfate\affix\GrimfateAffixExtraction.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\BowModelProperties.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\model\armor\BaseArmorGeoModel.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\render\armor\BaseArmorRenderer.java
.\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponPredicates.java
.\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponType.java
.\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java
.\grimfate\src\main\java\com\doomspire\grimfate\compat\bettercombat\BetterCombatBridge.java
.\grimfate\src\main\java\com\doomspire\grimfate\compat\curios\CuriosCompat.java
.\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java
.\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java
.\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java
.\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\armor\Armors.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\armor\GenericGeoArmorItem.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\BaseBowItem.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\comp\AffixListComponent.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\comp\WeaponProfileComponent.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\jewelry\Jewelry.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\materials\Materials.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\weapons\Weapons.java
.\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\AutoBoltServer.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastAutoBoltPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\SpellCastClient.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModArmorMaterials.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModCurios.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModDataComponents.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItemTags.java
.\grimfate\src\main\java\com\doomspire\grimfate\spell\SpellRequirements.java
.\grimfate\src\main\resources\assets\grimfate\geo\armor\copper_armor_set.geo.json
.\grimfate\src\main\resources\assets\grimfate\geo\armor\linen_armor_set.geo.json
.\grimfate\src\main\resources\assets\grimfate\geo\armor\rawhide_armor_set.geo.json
.\grimfate\src\main\resources\assets\grimfate\lang\en_us.json
.\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json
.\grimfate\src\main\resources\assets\grimfate\models\item\bronze_necklace.json
.\grimfate\src\main\resources\assets\grimfate\models\item\bronze_ring.json
.\grimfate\src\main\resources\assets\grimfate\models\item\canvas_fabric.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_boots.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_chestplate.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_helmet.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_leggings.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_necklace.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_ring.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword_2d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword_3d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield_2d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield_3d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\fiber.json
.\grimfate\src\main\resources\assets\grimfate\models\item\linen_cape.json
.\grimfate\src\main\resources\assets\grimfate\models\item\linen_hat.json
.\grimfate\src\main\resources\assets\grimfate\models\item\linen_pants.json
.\grimfate\src\main\resources\assets\grimfate\models\item\linen_shoes.json
.\grimfate\src\main\resources\assets\grimfate\models\item\pork_fat.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rawhide.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_boots.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_hood.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_jacket.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_wraps.json
.\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff.json
.\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff_2d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff_3d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow.json
.\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_2d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3d.json
.\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull0.json
.\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull1.json
.\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull2.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\axes.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\bows.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\crossbows.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\daggers.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\greataxes.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\greatswords.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\hammers.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\staves.json
.\grimfate\src\main\resources\data\bettercombat\tags\items\swords.json
.\grimfate\src\main\resources\data\curios\slot_types\belt.json
.\grimfate\src\main\resources\data\curios\slot_types\necklace.json
.\grimfate\src\main\resources\data\curios\slot_types\ring.json
.\grimfate\src\main\resources\data\curios\tags\items\belt.json
.\grimfate\src\main\resources\data\curios\tags\items\necklace.json
.\grimfate\src\main\resources\data\curios\tags\items\ring.json
.\grimfate\src\main\resources\data\grimfate\balance\attributes.json
.\grimfate\src\main\resources\data\grimfate\balance\levels.json
.\grimfate\src\main\resources\data\grimfate\balance\spells.json
.\grimfate\src\main\resources\data\grimfate\loot_modifiers\fiber_from_grass.json
.\grimfate\src\main\resources\data\grimfate\loot_modifiers\global_loot_modifiers.json
.\grimfate\src\main\resources\data\grimfate\loot_modifiers\jewelry_from_chests.json
.\grimfate\src\main\resources\data\grimfate\loot_modifiers\pork_fat_from_pig.json
.\grimfate\src\main\resources\data\grimfate\loot_tables\gameplay\jewelry_pool.json
.\grimfate\src\main\resources\data\grimfate\recipes\canvas_fabric.json
.\grimfate\src\main\resources\data\grimfate\recipes\copper_sword.json
.\grimfate\src\main\resources\data\grimfate\recipes\copperforced_shield.json
.\grimfate\src\main\resources\data\grimfate\recipes\rawhide.json
.\grimfate\src\main\resources\data\grimfate\recipes\scholar_staff.json
.\grimfate\src\main\resources\data\grimfate\recipes\weakling_bow.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\boots.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\chest.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\cloth.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\helm.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\leather.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\legs.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\plate.json
.\grimfate\src\main\resources\data\grimfate\tags\items\axes.json
.\grimfate\src\main\resources\data\grimfate\tags\items\bows.json
.\grimfate\src\main\resources\data\grimfate\tags\items\crossbows.json
.\grimfate\src\main\resources\data\grimfate\tags\items\daggers.json
.\grimfate\src\main\resources\data\grimfate\tags\items\greataxes.json
.\grimfate\src\main\resources\data\grimfate\tags\items\greatswords.json
.\grimfate\src\main\resources\data\grimfate\tags\items\hammers.json
.\grimfate\src\main\resources\data\grimfate\tags\items\jewelry.json
.\grimfate\src\main\resources\data\grimfate\tags\items\role\archer.json
.\grimfate\src\main\resources\data\grimfate\tags\items\role\mage.json
.\grimfate\src\main\resources\data\grimfate\tags\items\role\melee.json
.\grimfate\src\main\resources\data\grimfate\tags\items\shields.json
.\grimfate\src\main\resources\data\grimfate\tags\items\staves.json
.\grimfate\src\main\resources\data\grimfate\tags\items\swords.json
.\grimfate\src\main\resources\data\grimfate\weapon_attributes\copper_sword.json
.\grimfate\src\main\resources\data\grimfate\weapon_attributes\scholar_staff.json
.\grimfate\src\main\resources\data\grimfate\weapon_attributes\weakling_bow.json
.\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json
n=== CONCATENATED CONTENTS ===n
----- BEGIN FILE: .\gradle.properties -----
# ------------------------------
# Gradle performance
# ------------------------------
org.gradle.jvmargs=-Xmx2G
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configuration-cache=true

# ------------------------------
# Minecraft / NeoForge versions
# ------------------------------
minecraft_version=1.21.1
minecraft_version_range=[1.21.1,)
neo_version=21.1.208
loader_version_range=[1,)

# ------------------------------
# Parchment (mappings & docs)
# ------------------------------
parchment_minecraft_version=1.21.1
parchment_mappings_version=2024.11.17

# ------------------------------
# Mod metadata (???????? ??? grimfate)
# ------------------------------
mod_id=grimfate
mod_name=Grimfate
mod_version=0.0.1
mod_license=All Rights Reserved
mod_group_id=com.doomspire
mod_authors=Epilekt
mod_description=RPG ??? Grimfate. ????????? ??????, ??????, ????? ? ????? ????????? ? Minecraft.

# ------------------------------
# Mod metadata (?????????? grimcore)
# ------------------------------
core_mod_id=grimcore
core_mod_name=Grimcore
core_mod_version=0.0.1
core_mod_group_id=com.doomspire
core_mod_authors=Epilekt
core_mod_description=Core library with shared RPG systems for Grimfate

geckolib_version=4.7.7

n----- END FILE: .\gradle.properties -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\affix\Affix.java -----
package com.doomspire.grimcore.affix;

import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.resources.ResourceLocation;

//NOTE: Базовый контракт аффикса.
/**
 * Ядро (grimcore) не знает, как хранятся аффиксы на предметах — это задача контент-модуля.
 * Здесь — только применение к StatSnapshot и метаданные.
 *
 * Допущения:
 * - "magnitude" — числовая сила/вес аффикса, уже нормализованная контентом (например, 0.12f для +12%).
 * - "source" — откуда пришёл аффикс (броня, оружие, бижутерия/curios) — на случай разных формул.
 * - Применение идемпотентно и НЕ должно читать/менять состояние предметов, только модифицировать снапшот.
 */
public interface Affix {

    /**
     * Уникальный идентификатор аффикса (например, grimcore:dr_all, grimcore:fire_resist).
     */
    ResourceLocation id();

    /**
     * Применить эффект аффикса к снапшоту.
     *
     * @param outSnapshot целевой снапшот, в который суммируются эффекты
     * @param magnitude   сила аффикса (уже приведённая в доли/единицы)
     * @param source      источник (тип носителя аффикса)
     */
    void apply(StatSnapshot outSnapshot, float magnitude, Source source);

    /**
     * Короткий человекочитаемый ключ для тултипа/логов (без локализации).
     * Полноценный локализованный текст делаем на стороне клиента в grimfate.
     */
    default String tooltipKey() {
        return id().toString();
    }

    /**
     * Источник аффикса — может влиять на формулу (например, бонусы с оружия чаще «оффенсивные»).
     */
    enum Source {
        WEAPON,
        ARMOR,
        JEWELRY,   // кольца/амулеты (включая Curios)
        SHIELD,
        OTHER
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\affix\Affix.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\affix\AffixAggregator.java -----
package com.doomspire.grimcore.affix;

import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.LivingEntity;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

//NOTE: Сборщик эффектов аффиксов в общий StatSnapshot
/**
 * ВАЖНО:
 *  - grimcore НЕ знает, где хранятся аффиксы (компоненты предметов, Curios, теги и т.д.).
 *  - Контент-модуль (grimfate) обязан предоставить экстрактор через {@link #setExtractor(Extractor)}.
 *  - Экстрактор возвращает список "AffixEntry" (id, сила, источник) для КОНКРЕТНОЙ сущности.
 *
 * Алгоритм:
 *  1) Вызываем внешний Extractor → получаем список аффиксов сущности.
 *  2) Для каждого id резолвим Affix из {@link ModAffixes} и вызываем {@link Affix#apply}.
 *  3) Все эффекты суммируются в переданный снапшот.
 *
 * Безопасность:
 *  - Пустые/неизвестные id пропускаются молча.
 *  - Неверные или NaN величины "magnitude" приводятся к 0.
 */
public final class AffixAggregator {

    private AffixAggregator() {}

    /** Внешний экстрактор аффиксов (grimfate должен установить его на старте). */
    private static volatile Extractor EXTRACTOR = entity -> Collections.emptyList();

    /**
     * Установить внешний экстрактор аффиксов.
     * Вызывайте из grimfate при common-инициализации, когда готов чтение компонентов.
     */
    public static void setExtractor(Extractor extractor) {
        EXTRACTOR = Objects.requireNonNull(extractor, "AffixAggregator extractor");
    }

    /**
     * Собрать и применить ВСЕ аффиксы сущности к снапшоту.
     * Снапшот должен быть уже частично посчитан (атрибуты и т.п.) — аффиксы добавятся поверх.
     */
    public static void applyAll(StatSnapshot outSnapshot, LivingEntity entity) {
        if (outSnapshot == null || entity == null) return;

        List<AffixEntry> list;
        try {
            list = EXTRACTOR.extract(entity);
        } catch (Throwable t) {
            // Любая ошибка экстрактора не должна падать на ядро: просто игнорируем.
            list = Collections.emptyList();
        }

        if (list.isEmpty()) return;

        for (AffixEntry entry : list) {
            if (entry == null || entry.id() == null) continue;

            Affix affix = ModAffixes.get(entry.id());
            if (affix == null) continue; // неизвестный аффикс — пропускаем

            float mag = sanitize(entry.magnitude());
            if (mag == 0f) continue;

            try {
                affix.apply(outSnapshot, mag, entry.source());
            } catch (Throwable ignored) {
                // аффикс не должен ломать расчёт статов
            }
        }
    }

    private static float sanitize(float v) {
        if (Float.isNaN(v) || Float.isInfinite(v)) return 0f;
        // тут можно добавить клампы по типам аффиксов, но это ответственность конкретного Affix.apply
        return v;
    }

    // ===================== Контракт экстрактора и запись аффикса =====================

    /**
     * Экстрактор аффиксов для конкретной сущности.
     * ДОЛЖЕН собрать аффиксы со всей экипировки/бафов/Curios/компонентов и вернуть список.
     *
     * Пример реализации в grimfate:
     *  - обойти main/offhand + armor слоты,
     *  - если Curios загружен — обойти их слоты,
     *  - из каждого ItemStack прочитать AffixListComponent и собрать пары (id, magnitude, source).
     */
    @FunctionalInterface
    public interface Extractor {
        List<AffixEntry> extract(LivingEntity entity);
    }

    /**
     * Единичная запись аффикса.
     *
     * @param id        уникальный id аффикса (например, grimcore:damage_reduction_all)
     * @param magnitude числовая сила (уже нормализована, например 0.12f для +12%)
     * @param source    источник (оружие/броня/бижутерия/щит/прочее)
     */
    public record AffixEntry(ResourceLocation id, float magnitude, Affix.Source source) {
        public AffixEntry {
            if (source == null) source = Affix.Source.OTHER;
        }
    }

    // ===================== Утилита для сборки списков (необязательная) =====================

    /**
     * Удобный builder для внешнего экстрактора.
     * Позволяет накапливать аффиксы с валидацией, а затем получить immutable-список.
     */
    public static final class ListBuilder {
        private final List<AffixEntry> data = new ArrayList<>();

        public ListBuilder add(ResourceLocation id, float magnitude, Affix.Source source) {
            if (id != null && !Float.isNaN(magnitude) && !Float.isInfinite(magnitude)) {
                data.add(new AffixEntry(id, magnitude, source));
            }
            return this;
        }

        public List<AffixEntry> build() {
            return Collections.unmodifiableList(new ArrayList<>(data));
        }
    }
}
n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\affix\AffixAggregator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\affix\ModAffixes.java -----
package com.doomspire.grimcore.affix;

import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.resources.ResourceLocation;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

//NOTE: Глобальный реестр всех доступных аффиксов.
/**
 * Grimcore не знает, какие предметы их содержат — только предоставляет фабрики и реализацию.
 * Контент-модуль (grimfate) может расширять реестр через register().
 */
public final class ModAffixes {

    private static final Map<ResourceLocation, Affix> REGISTRY = new HashMap<>();

    private ModAffixes() {}

    // ------------------- API -------------------

    public static void register(Affix affix) {
        if (REGISTRY.containsKey(affix.id())) {
            throw new IllegalStateException("Affix id already registered: " + affix.id());
        }
        REGISTRY.put(affix.id(), affix);
    }

    public static Affix get(ResourceLocation id) {
        return REGISTRY.get(id);
    }

    public static Map<ResourceLocation, Affix> all() {
        return Collections.unmodifiableMap(REGISTRY);
    }

    /**
     * Вызвать один раз при старте мода (например, в common-инициализации).
     * Регистрирует базовые аффиксы ядра.
     * Контент может добавить свои дополнительно.
     */
    public static void bootstrap() {
        // Примеры: эти аффиксы базовые и нужны ядру для работы
        register(new SimpleAffix(
                ResourceLocation.fromNamespaceAndPath("grimcore", "damage_reduction_all"),
                (snap, mag, src) -> snap.damageReductionAll += mag
        ));

        register(new SimpleAffix(
                ResourceLocation.fromNamespaceAndPath("grimcore", "max_mana_flat"),
                (snap, mag, src) -> snap.maxMana += mag
        ));

        register(new SimpleAffix(
                ResourceLocation.fromNamespaceAndPath("grimcore", "fire_resist"),
                (snap, mag, src) -> snap.resistances.merge(
                        com.doomspire.grimcore.stat.ResistTypes.FIRE,
                        mag, Float::sum)
        ));
    }

    // ------------------- Реализация базового простого аффикса -------------------

    /**
     * Упрощённый аффикс, для случаев где достаточно «применить лямбду».
     */
    private record SimpleAffix(ResourceLocation id, Applier fn) implements Affix {
        @Override
        public void apply(StatSnapshot outSnapshot, float magnitude, Source source) {
            fn.apply(outSnapshot, magnitude, source);
        }

        @FunctionalInterface
        private interface Applier {
            void apply(StatSnapshot out, float mag, Source src);
        }
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\affix\ModAffixes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.*;

public final class MobStatCalculator {
    private MobStatCalculator(){}

    public static StatSnapshot calculate(MobStatsAttachment att) {
        StatSnapshot s = new StatSnapshot();

        int vit  = att.getAttribute(Attributes.VITALITY);
        int str  = att.getAttribute(Attributes.STRENGTH);
        int intl = att.getAttribute(Attributes.INTELLIGENCE);
        int dex  = att.getAttribute(Attributes.DEXTERITY);
        int eva  = att.getAttribute(Attributes.EVASION);

        // База для мобов (потом вынесем в датапак balance)
        s.maxHealth   = 60 + vit * 20;
        s.regenHealth = 0 + vit * 1;

        // у мобов нет маны
        s.maxMana   = 0;
        s.regenMana = 0;

        // Базовый урон (только физика для старта)
        s.damage.put(DamageTypes.PHYS_MELEE, 3f + str * 0.5f);
        s.damage.put(DamageTypes.PHYS_RANGED, dex * 0.5f);

        // Элементы оставим 0 по умолчанию (будут у кастомных мобов)
        s.damage.putIfAbsent(DamageTypes.FIRE, 0f);
        s.damage.putIfAbsent(DamageTypes.FROST, 0f);
        s.damage.putIfAbsent(DamageTypes.LIGHTNING, 0f);
        s.damage.putIfAbsent(DamageTypes.POISON, 0f);

        // Защита/уклон/крит как старт
        s.resistances.put(ResistTypes.PHYS, 0.0f);
        s.resistances.put(ResistTypes.FIRE, 0.0f);
        s.resistances.put(ResistTypes.FROST, 0.0f);
        s.resistances.put(ResistTypes.LIGHTNING, 0.0f);
        s.resistances.put(ResistTypes.POISON, 0.0f);

        s.evasionChance = Math.min(0.5f, eva * 0.005f); // 0.5% за очко, кап 50%
        s.critChance = 0f;
        s.critDamage = 0.25f;

        return s;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.*;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.EnumMap;

public class MobStatsAttachment {
    private final EnumMap<Attributes, Integer> attributes = new EnumMap<>(Attributes.class);
    private int currentHealth = 100;
    private boolean dirty = true;
    private StatSnapshot snapshot = new StatSnapshot();

    public MobStatsAttachment() {
        // у мобов нет маны → пропускаем SPIRIT
        for (Attributes a : Attributes.values()) {
            if (a != Attributes.SPIRIT) attributes.put(a, 0);
        }
    }

    public int getAttribute(Attributes attr) {
        return attributes.getOrDefault(attr, 0);
    }
    public void setAttribute(Attributes attr, int value) {
        if (attr == Attributes.SPIRIT) return; // игнор
        attributes.put(attr, Math.max(0, value)); dirty = true;
    }
    public void addAttribute(Attributes attr, int delta) {
        if (attr == Attributes.SPIRIT) return;
        attributes.put(attr, Math.max(0, getAttribute(attr) + delta)); dirty = true;
    }

    public int getCurrentHealth() { return currentHealth; }
    public void setCurrentHealth(int v) {
        int max = (int)Math.max(1, getSnapshot().maxHealth);
        currentHealth = Math.max(0, Math.min(v, max));
    }

    public StatSnapshot getSnapshot() {
        if (dirty) {
            snapshot = MobStatCalculator.calculate(this);
            dirty = false;
        }
        return snapshot;
    }
    public void markDirty() { dirty = true; }

    // --- net sync ---
    public static final StreamCodec<RegistryFriendlyByteBuf, MobStatsAttachment> STREAM_CODEC =
            StreamCodec.of(MobStatsAttachment::encode, MobStatsAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, MobStatsAttachment att) {
        buf.writeVarInt(att.currentHealth);
        // порядок атрибутов фиксируем:
        for (Attributes a : Attributes.values()) {
            if (a == Attributes.SPIRIT) continue;
            buf.writeVarInt(att.getAttribute(a));
        }
    }
    private static MobStatsAttachment decode(RegistryFriendlyByteBuf buf) {
        MobStatsAttachment att = new MobStatsAttachment();
        att.currentHealth = buf.readVarInt();
        for (Attributes a : Attributes.values()) {
            if (a == Attributes.SPIRIT) continue;
            att.attributes.put(a, buf.readVarInt());
        }
        att.dirty = true;
        return att;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobThreatAttachment.java -----
package com.doomspire.grimcore.attach;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.*;

/**
 * Таблица угрозы для одной боевой единицы (обычно — для моба).
 *
 * Модель:
 *  - БАЗОВАЯ угроза (накапливается от урона, постоянных статов и т.п.) — не "тает".
 *  - ВРЕМЕННЫЕ модификаторы (таунт/умения) — каждый с суммой и временем истечения.
 *  - Целью считается игрок с максимальной актуальной угрозой (base + активные temp).
 *
 * Никакого общего decay по тикам нет.
 */
public final class MobThreatAttachment {

    /** Порог «пыли», ниже которого записи очищаются. */
    public static final float EPSILON = 0.05f;

    /** Базовая угроза по игроку. */
    private final Map<UUID, Float> baseThreat = new HashMap<>();

    /** Временные модификаторы по игроку. */
    private final Map<UUID, List<TempBonus>> tempThreats = new HashMap<>();

    /** Момент последнего боевого события (для эвристик AI/логов). */
    private long lastCombatMs = 0L;

    /** Запись временного бонуса. */
    public static final class TempBonus {
        public float amount;
        public long expiresAtMs;

        public TempBonus(float amount, long expiresAtMs) {
            this.amount = amount;
            this.expiresAtMs = expiresAtMs;
        }
    }

    // ======== Мутации ========

    /** + к БАЗОВОЙ угрозе. Возвращает новое базовое значение. */
    public float addBaseThreat(UUID playerId, float amount) {
        if (playerId == null || amount <= 0f) return getBaseThreat(playerId);
        float next = Math.max(0f, baseThreat.getOrDefault(playerId, 0f) + amount);
        if (next < EPSILON) {
            baseThreat.remove(playerId);
        } else {
            baseThreat.put(playerId, next);
        }
        lastCombatMs = System.currentTimeMillis();
        return next;
    }

    /** Установить БАЗОВУЮ угрозу конкретного игрока. */
    public void setBaseThreat(UUID playerId, float value) {
        if (playerId == null) return;
        float v = Math.max(0f, value);
        if (v < EPSILON) baseThreat.remove(playerId);
        else baseThreat.put(playerId, v);
    }

    /** Добавить ВРЕМЕННУЮ угрозу (таунт/скилл) с длительностью в миллисекундах. */
    public void addTempThreat(UUID playerId, float amount, long durationMs) {
        if (playerId == null || amount <= 0f || durationMs <= 0L) return;
        long now = System.currentTimeMillis();
        long exp = now + durationMs;

        var list = tempThreats.computeIfAbsent(playerId, k -> new ArrayList<>());
        list.add(new TempBonus(amount, exp));
        lastCombatMs = now;
    }

    /** Очистить все угрозы конкретного игрока (base + temp). */
    public void clearFor(UUID playerId) {
        if (playerId == null) return;
        baseThreat.remove(playerId);
        tempThreats.remove(playerId);
    }

    /** Полная очистка. */
    public void clearAll() {
        baseThreat.clear();
        tempThreats.clear();
        lastCombatMs = 0L;
    }

    // ======== Чтение/вычисления ========

    /** БАЗОВАЯ угроза (без временных бонусов). */
    public float getBaseThreat(UUID playerId) {
        if (playerId == null) return 0f;
        return baseThreat.getOrDefault(playerId, 0f);
    }

    /** Полная угроза (base + актуальные temp), с ленивой очисткой просроченных бонусов. */
    public float totalThreatFor(UUID playerId, long nowMs) {
        if (playerId == null) return 0f;
        float base = baseThreat.getOrDefault(playerId, 0f);
        float sumTemp = sumAndPruneTemps(playerId, nowMs);
        float total = base + sumTemp;
        if (total < EPSILON) {
            // зачистим пустышки
            baseThreat.remove(playerId);
            if (sumTemp == 0f) tempThreats.remove(playerId);
            return 0f;
        }
        return total;
    }

    /** UUID игрока с максимальной актуальной угрозой (или null). */
    public UUID topThreatPlayer(long nowMs) {
        // объединённый набор ключей (у кого есть либо base, либо temp)
        Set<UUID> keys = new HashSet<>(baseThreat.keySet());
        keys.addAll(tempThreats.keySet());

        UUID bestId = null;
        float bestVal = 0f;

        for (UUID id : keys) {
            float val = totalThreatFor(id, nowMs);
            if (val > bestVal) {
                bestVal = val;
                bestId = id;
            }
        }
        // небольшая чистка глобальных карт, если всё осыпалось
        if (bestId == null) {
            baseThreat.entrySet().removeIf(e -> e.getValue() < EPSILON);
            tempThreats.entrySet().removeIf(e -> {
                float s = sumAndPruneTemps(e.getKey(), nowMs);
                return s < EPSILON;
            });
        }
        return bestId;
    }

    /** Топ-N (id, total) по убыванию, для отладки/UI. */
    public List<Map.Entry<UUID, Float>> topN(int n, long nowMs) {
        Set<UUID> keys = new HashSet<>(baseThreat.keySet());
        keys.addAll(tempThreats.keySet());
        ArrayList<Map.Entry<UUID, Float>> list = new ArrayList<>(keys.size());
        for (UUID id : keys) {
            float v = totalThreatFor(id, nowMs);
            if (v >= EPSILON) list.add(Map.entry(id, v));
        }
        list.sort((a, b) -> Float.compare(b.getValue(), a.getValue()));
        return list.size() > n ? list.subList(0, n) : list;
    }

    /** Были ли бои в последние timeoutMs миллисекунд. */
    public boolean isInCombat(long nowMs, long timeoutMs) {
        return lastCombatMs > 0L && (nowMs - lastCombatMs) <= Math.max(0L, timeoutMs);
    }

    // ======== Вспомогательное ========

    private float sumAndPruneTemps(UUID playerId, long nowMs) {
        var list = tempThreats.get(playerId);
        if (list == null || list.isEmpty()) return 0f;

        float sum = 0f;
        // лениво чистим просроченные
        list.removeIf(tb -> tb == null || tb.expiresAtMs <= nowMs || tb.amount < EPSILON);
        for (TempBonus tb : list) sum += tb.amount;

        if (list.isEmpty()) tempThreats.remove(playerId);
        return sum;
    }

    // ======== Сериализация (StreamCodec) ========

    /**
     * Формат:
     *  base: varInt size, затем (UUID hi, UUID lo, float base)
     *  temps: varInt size, затем для каждого ключа:
     *         (UUID hi, UUID lo, varInt listSize, повторить listSize раз: float amount, long expiresAtMs)
     *  lastCombatMs: long
     */
    public static final StreamCodec<RegistryFriendlyByteBuf, MobThreatAttachment> STREAM_CODEC =
            StreamCodec.of(MobThreatAttachment::encode, MobThreatAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, MobThreatAttachment att) {
        // base
        buf.writeVarInt(att.baseThreat.size());
        for (var e : att.baseThreat.entrySet()) {
            UUID id = e.getKey();
            buf.writeLong(id.getMostSignificantBits());
            buf.writeLong(id.getLeastSignificantBits());
            buf.writeFloat(e.getValue());
        }
        // temps
        buf.writeVarInt(att.tempThreats.size());
        for (var e : att.tempThreats.entrySet()) {
            UUID id = e.getKey();
            buf.writeLong(id.getMostSignificantBits());
            buf.writeLong(id.getLeastSignificantBits());
            List<TempBonus> list = e.getValue();
            buf.writeVarInt(list != null ? list.size() : 0);
            if (list != null) {
                for (TempBonus tb : list) {
                    buf.writeFloat(tb.amount);
                    buf.writeLong(tb.expiresAtMs);
                }
            }
        }
        buf.writeLong(att.lastCombatMs);
    }

    private static MobThreatAttachment decode(RegistryFriendlyByteBuf buf) {
        MobThreatAttachment a = new MobThreatAttachment();
        // base
        int bSize = buf.readVarInt();
        for (int i = 0; i < bSize; i++) {
            UUID id = new UUID(buf.readLong(), buf.readLong());
            float v = buf.readFloat();
            if (v >= EPSILON) a.baseThreat.put(id, v);
        }
        // temps
        int tSize = buf.readVarInt();
        for (int i = 0; i < tSize; i++) {
            UUID id = new UUID(buf.readLong(), buf.readLong());
            int n = buf.readVarInt();
            if (n > 0) {
                ArrayList<TempBonus> list = new ArrayList<>(n);
                for (int j = 0; j < n; j++) {
                    float amt = buf.readFloat();
                    long exp = buf.readLong();
                    if (amt >= EPSILON) list.add(new TempBonus(amt, exp));
                }
                if (!list.isEmpty()) a.tempThreats.put(id, list);
            }
        }
        a.lastCombatMs = buf.readLong();
        return a;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobThreatAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java -----
package com.doomspire.grimcore.attach;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.resources.ResourceLocation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Лоадаут спеллов игрока: 6 слотов + пер-слот кулдауны.
 * Сериализация:
 *  - CODEC (в NBT/сейв): slots как список строк (пустая строка = null), cooldowns как список int.
 *  - STREAM_CODEC (в сеть): на слот пишем флаг наличия + ResourceLocation (если есть), затем cooldowns.
 */
public final class PlayerLoadoutAttachment {

    public static final int SLOTS = 6;

    private final ResourceLocation[] slots = new ResourceLocation[SLOTS];
    private final int[] cooldown = new int[SLOTS];

    public PlayerLoadoutAttachment() {}

    // -------- API --------
    public ResourceLocation get(int slot) { check(slot); return slots[slot]; }
    public void set(int slot, ResourceLocation id) { check(slot); slots[slot] = id; }

    public int getCooldown(int slot) { check(slot); return cooldown[slot]; }
    public void setCooldown(int slot, int ticks) { check(slot); cooldown[slot] = Math.max(0, ticks); }

    public void tickDown() {
        for (int i = 0; i < SLOTS; i++) if (cooldown[i] > 0) cooldown[i]--;
    }

    public void clearAll() {
        Arrays.fill(slots, null);
        Arrays.fill(cooldown, 0);
    }

    private static void check(int s) {
        if (s < 0 || s >= SLOTS) throw new IndexOutOfBoundsException("slot " + s);
    }

    // -------- CODEC (persist) --------
    public static final Codec<PlayerLoadoutAttachment> CODEC = RecordCodecBuilder.create(inst -> inst.group(
            // список строк длиной SLOTS; "" означает пустой слот
            Codec.list(Codec.STRING).fieldOf("slots").forGetter(att -> {
                List<String> out = new ArrayList<>(SLOTS);
                for (int i = 0; i < SLOTS; i++) out.add(att.slots[i] != null ? att.slots[i].toString() : "");
                return out;
            }),
            Codec.list(Codec.INT).fieldOf("cooldowns").forGetter(att -> {
                List<Integer> out = new ArrayList<>(SLOTS);
                for (int i = 0; i < SLOTS; i++) out.add(att.cooldown[i]);
                return out;
            })
    ).apply(inst, (slotStrings, cds) -> {
        PlayerLoadoutAttachment att = new PlayerLoadoutAttachment();
        int n = Math.min(SLOTS, slotStrings.size());
        for (int i = 0; i < n; i++) {
            String s = slotStrings.get(i);
            if (s != null && !s.isEmpty()) {
                ResourceLocation rl = ResourceLocation.tryParse(s);
                if (rl != null) att.slots[i] = rl;
            }
        }
        int m = Math.min(SLOTS, cds.size());
        for (int i = 0; i < m; i++) att.cooldown[i] = Math.max(0, cds.get(i));
        return att;
    }));

    // -------- STREAM_CODEC (network) --------
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerLoadoutAttachment> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public PlayerLoadoutAttachment decode(RegistryFriendlyByteBuf buf) {
                    PlayerLoadoutAttachment att = new PlayerLoadoutAttachment();
                    for (int i = 0; i < SLOTS; i++) {
                        boolean has = buf.readBoolean();
                        if (has) att.slots[i] = ResourceLocation.STREAM_CODEC.decode(buf);
                    }
                    for (int i = 0; i < SLOTS; i++) {
                        att.cooldown[i] = buf.readVarInt();
                    }
                    return att;
                }

                @Override
                public void encode(RegistryFriendlyByteBuf buf, PlayerLoadoutAttachment att) {
                    for (int i = 0; i < SLOTS; i++) {
                        ResourceLocation rl = att.slots[i];
                        buf.writeBoolean(rl != null);
                        if (rl != null) ResourceLocation.STREAM_CODEC.encode(buf, rl);
                    }
                    for (int i = 0; i < SLOTS; i++) {
                        buf.writeVarInt(att.cooldown[i]);
                    }
                }
            };
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimcore.xp.LevelTable;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

/**
 * Персистентный прогресс игрока (уровень/опыт/кап). Сохраняется через CODEC.
 * Клиенту отдаём лёгкий снапшот PlayerProgress.
 */
public class PlayerProgressAttachment {

    private int level;
    private int exp;
    private int expCap;

    public PlayerProgressAttachment() {
        this.level = 1;
        this.exp = 0;
        this.expCap = LevelTable.expForLevel(1); // кап до 2-го уровня
    }

    public int level() { return level; }
    public int exp() { return exp; }
    public int expCap() { return expCap; }

    /** Возвращает число полученных уровней (для выдачи очков атрибутов). */
    public int addExp(int amount) {
        if (amount <= 0) return 0;
        int gained = 0;
        exp += amount;
        while (exp >= expCap && level < LevelTable.maxLevel()) {
            exp -= expCap;
            level++;
            expCap = LevelTable.expForLevel(level);
            gained++;
        }
        return gained;
    }

    /** Снимок для HUD/клиента. */
    public PlayerProgress toSnapshot() {
        return new PlayerProgress(level, exp, expCap);
    }

    // ---------- Persist (save/load) ----------
    public static final Codec<PlayerProgressAttachment> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.fieldOf("level").forGetter(PlayerProgressAttachment::level),
            Codec.INT.fieldOf("exp").forGetter(PlayerProgressAttachment::exp),
            Codec.INT.fieldOf("exp_cap").forGetter(PlayerProgressAttachment::expCap)
    ).apply(i, (lvl, e, cap) -> {
        PlayerProgressAttachment a = new PlayerProgressAttachment();
        a.level = Math.max(1, lvl);
        a.exp = Math.max(0, e);
        a.expCap = Math.max(1, cap);
        return a;
    }));

    // ---------- Network (instant sync, если шлём кастомный пакет) ----------
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerProgressAttachment> STREAM_CODEC =
            StreamCodec.of(PlayerProgressAttachment::encode, PlayerProgressAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, PlayerProgressAttachment a) {
        buf.writeVarInt(a.level);
        buf.writeVarInt(a.exp);
        buf.writeVarInt(a.expCap);
    }

    private static PlayerProgressAttachment decode(RegistryFriendlyByteBuf buf) {
        PlayerProgressAttachment a = new PlayerProgressAttachment();
        a.level  = buf.readVarInt();
        a.exp    = buf.readVarInt();
        a.expCap = buf.readVarInt();
        return a;
    }
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatCalculator;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.world.entity.player.Player;
import com.doomspire.grimcore.datapack.BalanceData;

import java.util.EnumMap;
import java.util.Locale;

//NOTE: Attachment игрока: очки атрибутов, текущие ресурсы и кэш агрегированных статов.

public class PlayerStatsAttachment {

    // ---- Текущие ресурсы (кастомные полосы) ----
    private int currentHealth = 100;
    private int currentMana   = 100;

    /**
     * Текущая «сверхщит» полоса (overshield).
     * Списывается ПЕРВОЙ при получении урона, затем уже здоровье.
     * Значение не входит в StatSnapshot, это runtime-ресурс (как временные бафы/щит).
     */
    private int overshield = 0;

    // ---- Распределённые очки по атрибутам ----
    private final EnumMap<Attributes, Integer> attributes = new EnumMap<>(Attributes.class);

    // ---- Очки, нераспределённые игроком ----
    private int unspentPoints = 0;

    // ---- Кэш снапшота и грязный флаг ----
    private StatSnapshot snapshot = new StatSnapshot();
    private boolean dirty = true;

    public PlayerStatsAttachment() {
        for (Attributes a : Attributes.values()) {
            attributes.put(a, 0);
        }
    }

    // ===================== API =====================

    public int getCurrentHealth() { return currentHealth; }
    public int getCurrentMana()   { return currentMana; }
    public int getOvershield()    { return overshield; }

    public void setCurrentHealth(int v) {
        int max = (int) Math.max(1, getSnapshot().maxHealth);
        currentHealth = Math.max(0, Math.min(v, max));
    }

    public void setCurrentMana(int v) {
        int max = (int) Math.max(1, getSnapshot().maxMana);
        currentMana = Math.max(0, Math.min(v, max));
    }

    /**
     * Установить текущий overshield с учётом верхней границы.
     * Верхнюю границу можно задавать через снапшот (например, статы/аффиксы),
     * иначе — ограничиваем «разумным» максимумом по здоровью.
     */
    public void setOvershield(int v) {
        int maxOs = estimateMaxOvershield();
        overshield = Math.max(0, Math.min(v, maxOs));
    }

    /** Увеличить overshield (для способностей/аффиксов), с клампом. */
    public void addOvershield(int delta) {
        if (delta <= 0) return;
        setOvershield(overshield + delta);
    }

    /**
     * Списать часть overshield, вернуть сколько НЕ покрылось (остаток урона).
     * Удобно вызывать из DamageEngine перед уроном по здоровью.
     */
    public int consumeOvershield(int amount) {
        if (amount <= 0 || overshield <= 0) return amount;
        int used = Math.min(amount, overshield);
        overshield -= used;
        return amount - used; // остаток, который пойдёт в здоровье/дальше по пайплайну
    }

    /** Оценка верхней границы overshield. Позже можно читать из снапшота (maxOvershield). */
    private int estimateMaxOvershield() {
        // Пока используем максимум равный текущему максимальному здоровью.
        // Если в StatCalculator появится отдельный stat maxOvershield — читать оттуда.
        return (int) Math.max(1, getSnapshot().maxHealth);
    }

    public void markDirty() { this.dirty = true; }

    public int getAttribute(Attributes attr) {
        return attributes.getOrDefault(attr, 0);
    }

    public void setAttribute(Attributes attr, int value) {
        attributes.put(attr, Math.max(0, value));
        dirty = true;
    }

    public void addAttribute(Attributes attr, int delta) {
        attributes.put(attr, Math.max(0, getAttribute(attr) + delta));
        dirty = true;
    }

    public int getUnspentPoints() { return unspentPoints; }
    public void setUnspentPoints(int v) { unspentPoints = Math.max(0, v); }
    public void addUnspentPoints(int amount) { if (amount > 0) unspentPoints += amount; }

    public int hardCapFor(Attributes attr) {
        return BalanceData.attrs().cap(attr);
    }

    /** Потратить 1 очко в атрибут с проверкой капа. Возвращает true при успехе. */
    public boolean tryAllocatePoint(Attributes attr) {
        if (unspentPoints <= 0) return false;
        int cap = hardCapFor(attr);
        int cur = getAttribute(attr);
        if (cur >= cap) return false;

        setAttribute(attr, cur + 1);
        unspentPoints--;
        return true;
    }

    /** Базовый снапшот без учёта аффиксов экипировки. */
    public StatSnapshot getSnapshot() {
        if (dirty) {
            snapshot = StatCalculator.calculate(this);
            dirty = false;
        }
        return snapshot;
    }

    /**
     * Полный снапшот с применением аффиксов владельца.
     * Если owner == null — вернёт базовый вариант как в {@link #getSnapshot()}.
     */
    public StatSnapshot getSnapshotWithAffixes(Player owner) {
        if (dirty) {
            if (owner != null) {
                snapshot = StatCalculator.calculateWithAffixes(this, owner);
            } else {
                snapshot = StatCalculator.calculate(this);
            }
            dirty = false;
        }
        return snapshot;
    }

    // ===================== NET (StreamCodec) =====================
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerStatsAttachment> STREAM_CODEC =
            StreamCodec.of(PlayerStatsAttachment::encode, PlayerStatsAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, PlayerStatsAttachment att) {
        buf.writeVarInt(att.unspentPoints);
        buf.writeVarInt(att.currentHealth);
        buf.writeVarInt(att.currentMana);
        buf.writeVarInt(att.overshield); // <<< новое поле
        for (Attributes a : Attributes.values()) {
            buf.writeVarInt(att.getAttribute(a));
        }
    }

    private static PlayerStatsAttachment decode(RegistryFriendlyByteBuf buf) {
        PlayerStatsAttachment att = new PlayerStatsAttachment();
        att.unspentPoints = buf.readVarInt();
        att.currentHealth = buf.readVarInt();
        att.currentMana   = buf.readVarInt();
        att.overshield    = buf.readVarInt(); // <<< читаем в том же порядке
        for (Attributes a : Attributes.values()) {
            att.attributes.put(a, buf.readVarInt());
        }
        att.dirty = true;
        return att;
    }

    // ===================== Утилиты =====================

    /** Достаёт аттачмент у игрока. */
    public static PlayerStatsAttachment get(Player player) {
        return player.getData(ModAttachments.PLAYER_STATS.get());
    }

    /** Пытается распарсить строковый id атрибута в enum (без краша). */
    public static Attributes parseAttrId(String id) {
        if (id == null) return null;
        try {
            return Attributes.valueOf(id.trim().toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException ex) {
            return null;
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\ThreatService.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.ModAttachments; // ← если пакет другой, поправь импорт
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;

import java.util.UUID;

/**
 * Централизованный сервис угрозы без тик-затухания:
 *  - конвертация нанесённого урона в БАЗОВУЮ угрозу,
 *  - добавление постоянной (base) угрозы,
 *  - добавление временной (temp) угрозы с авто-сбросом по таймеру,
 *  - чтение total/top.
 *
 * Событий/подписок тут нет — только прямые вызовы из боёвки/спеллов.
 */
public final class ThreatService {
    private ThreatService() {}

    /** Множитель перевода нанесённого урона в угрозу (баланс). */
    public static final float THREAT_PER_DAMAGE = 1.0f;

    /** Доп. множитель из статов (когда будет нужный стат — подключим здесь). */
    public static float threatGenMultiplier(Player source) {
        return 1.0f;
    }

    /** Урон → БАЗОВАЯ угроза. */
    public static void addThreatFromDamage(LivingEntity victim, Player attacker, float damage) {
        if (!(victim.level() instanceof ServerLevel) || attacker == null || damage <= 0f) return;
        MobThreatAttachment att = victim.getData(ModAttachments.MOB_THREAT.get());
        if (att == null) return;

        float mult = THREAT_PER_DAMAGE * threatGenMultiplier(attacker);
        att.addBaseThreat(attacker.getUUID(), damage * mult);
    }

    /** Постоянная (base) прибавка угрозы. */
    public static void addThreatFlat(LivingEntity victim, UUID playerId, float amount) {
        if (!(victim.level() instanceof ServerLevel) || playerId == null || amount <= 0f) return;
        MobThreatAttachment att = victim.getData(ModAttachments.MOB_THREAT.get());
        if (att != null) {
            att.addBaseThreat(playerId, amount);
        }
    }

    /** Временная (temp) угроза: исчезает через durationMs. */
    public static void addTempThreat(LivingEntity victim, UUID playerId, float amount, long durationMs) {
        if (!(victim.level() instanceof ServerLevel) || playerId == null || amount <= 0f || durationMs <= 0L) return;
        MobThreatAttachment att = victim.getData(ModAttachments.MOB_THREAT.get());
        if (att != null) {
            att.addTempThreat(playerId, amount, durationMs);
        }
    }

    /** Текущее total-значение угрозы по игроку. */
    public static float getThreat(LivingEntity victim, UUID playerId) {
        MobThreatAttachment att = victim.getData(ModAttachments.MOB_THREAT.get());
        return (att != null) ? att.totalThreatFor(playerId, System.currentTimeMillis()) : 0f;
    }

    /** Игрок с наибольшей актуальной угрозой. */
    public static UUID topThreatPlayer(LivingEntity victim) {
        MobThreatAttachment att = victim.getData(ModAttachments.MOB_THREAT.get());
        return (att != null) ? att.topThreatPlayer(System.currentTimeMillis()) : null;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\ThreatService.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java -----
package com.doomspire.grimcore.combat;

import com.doomspire.grimcore.stat.DamageTypes;
import net.minecraft.world.entity.LivingEntity;

import java.util.EnumMap;

/**
 * Контекст одного удара/заклинания.
 * Заполняется перед вызовом DamageEngine.
 */
public class DamageContext {
    public final LivingEntity attacker;
    public final LivingEntity target;
    public final EnumMap<DamageTypes, Float> damageMap = new EnumMap<>(DamageTypes.class);
    public boolean critical = false;

    public DamageContext(LivingEntity attacker, LivingEntity target) {
        this.attacker = attacker;
        this.target = target;
        for (DamageTypes t : DamageTypes.values()) damageMap.put(t, 0f);
    }

    public DamageContext add(DamageTypes type, float amount) {
        damageMap.put(type, damageMap.get(type) + amount);
        return this;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java -----
package com.doomspire.grimcore.combat;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.attach.ThreatService;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.DamageTypes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.ResistTypes;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;

import java.util.concurrent.ThreadLocalRandom;

// NOTE: Централизованный пайплайн урона — последовательность расчёта каждого hit.
// NOTE: Генерация угрозы тоже подключена здесь
public final class DamageEngine {
    private DamageEngine() {}

    public static float resolveAndApply(DamageContext ctx) {
        final LivingEntity target = ctx.target;

        // --- читаем снапшот цели (игрок или моб) ---
        StatSnapshot tSnap;
        boolean targetIsPlayer = target.getData(ModAttachments.PLAYER_STATS.get()) != null;
        if (targetIsPlayer) {
            PlayerStatsAttachment tAtt = target.getData(ModAttachments.PLAYER_STATS.get());
            if (tAtt == null) return 0f;
            // ВАЖНО: берём снапшот с аффиксами владельца
            tSnap = (target instanceof Player pT)
                    ? tAtt.getSnapshotWithAffixes(pT)
                    : tAtt.getSnapshot();
            // Evade
            if (ThreadLocalRandom.current().nextFloat() < tSnap.evasionChance) {
                return 0f;
            }
        } else {
            MobStatsAttachment tAtt = target.getData(ModAttachments.MOB_STATS.get());
            if (tAtt == null) return 0f;
            tSnap = tAtt.getSnapshot();
            if (ThreadLocalRandom.current().nextFloat() < tSnap.evasionChance) {
                return 0f;
            }
        }

        // --- снапшот атакера (для крита/воровства) ---
        StatSnapshot aSnap = null;
        if (ctx.attacker != null) {
            var aPlayer = ctx.attacker.getData(ModAttachments.PLAYER_STATS.get());
            if (aPlayer != null) {
                aSnap = (ctx.attacker instanceof Player pA)
                        ? aPlayer.getSnapshotWithAffixes(pA)
                        : aPlayer.getSnapshot();
            } else {
                var aMob = ctx.attacker.getData(ModAttachments.MOB_STATS.get());
                if (aMob != null) aSnap = aMob.getSnapshot();
            }
        }

        // --- базовый расчёт по типам: крит -> резисты ---
        float total = 0f;
        for (var entry : ctx.damageMap.entrySet()) {
            DamageTypes type = entry.getKey();
            float dmg = entry.getValue();
            if (dmg <= 0f) continue;

            // crit
            if (aSnap != null) {
                boolean rollCrit = ctx.critical || ThreadLocalRandom.current().nextFloat() < aSnap.critChance;
                if (rollCrit) {
                    dmg *= (1f + Math.max(0f, aSnap.critDamage)); // +50% => 0.5
                }
            }

            // resist mapping
            float resist = switch (type) {
                case PHYS_MELEE, PHYS_RANGED -> tSnap.resistances.getOrDefault(ResistTypes.PHYS, 0f);
                case FIRE -> tSnap.resistances.getOrDefault(ResistTypes.FIRE, 0f);
                case FROST -> tSnap.resistances.getOrDefault(ResistTypes.FROST, 0f);
                case LIGHTNING -> tSnap.resistances.getOrDefault(ResistTypes.LIGHTNING, 0f);
                case POISON -> tSnap.resistances.getOrDefault(ResistTypes.POISON, 0f);
            };
            resist = Math.max(0f, Math.min(resist, 0.90f)); // хард-кап 90%
            dmg *= (1f - resist);

            total += Math.max(0f, dmg);
        }

        int applied; // фактически нанесённый урон (после overshield и DR_all)

        // --- overshield (только у игрока) -> затем damage_reduction_all ---
        if (targetIsPlayer) {
            PlayerStatsAttachment tAtt = target.getData(ModAttachments.PLAYER_STATS.get());
            int incoming = Math.max(0, Math.round(total));

            // 1) Снять overshield ПЕРВЫМ
            int afterOS = tAtt.consumeOvershield(incoming);
            boolean osChanged = (afterOS != incoming);

            // 2) Применить глобальную редукцию
            float drAll = clamp01(readDamageReductionAll(tSnap), 0.90f);
            float afterDR = afterOS * (1f - drAll);

            applied = Math.max(0, Math.round(afterDR));

            // 3) Урон по здоровью
            if (applied > 0) {
                tAtt.setCurrentHealth(tAtt.getCurrentHealth() - applied);
            }

            if (osChanged || applied > 0) {
                tAtt.markDirty();
                if (target instanceof ServerPlayer spT) {
                    GrimcoreNetworking.syncPlayerStats(spT, tAtt); // мгновенный HUD-синк цели
                }
            }
        } else {
            // Мобы: только DR_all (если в снапшоте есть), без overshield
            float drAll = clamp01(readDamageReductionAll(tSnap), 0.90f);
            float afterDR = total * (1f - drAll);
            applied = Math.max(0, Math.round(afterDR));

            if (applied > 0) {
                MobStatsAttachment tAtt = target.getData(ModAttachments.MOB_STATS.get());
                tAtt.setCurrentHealth(tAtt.getCurrentHealth() - applied);
                tAtt.markDirty();
            }
        }

        // === НОВОЕ: генерация угрозы по фактически нанесённому урону ===
        if (applied > 0 && ctx.attacker instanceof Player pA) {
            ThreatService.addThreatFromDamage(target, pA, applied);
        }

        // --- lifesteal/manasteal по фактически нанесённому урону ---
        if (aSnap != null && applied > 0 && ctx.attacker instanceof LivingEntity attackerLe) {
            int heal = Math.round(applied * Math.max(0f, aSnap.lifesteal));
            int mana = Math.round(applied * Math.max(0f, aSnap.manasteal));

            var aPlayer = attackerLe.getData(ModAttachments.PLAYER_STATS.get());
            if (aPlayer != null) {
                boolean changed = false;
                if (heal > 0) {
                    aPlayer.setCurrentHealth(aPlayer.getCurrentHealth() + heal);
                    changed = true;
                }
                if (mana > 0) {
                    aPlayer.setCurrentMana(aPlayer.getCurrentMana() + mana);
                    changed = true;
                }
                if (changed) {
                    aPlayer.markDirty();
                    if (attackerLe instanceof ServerPlayer spA) {
                        GrimcoreNetworking.syncPlayerStats(spA, aPlayer);
                    }
                }
            } else {
                var aMob = attackerLe.getData(ModAttachments.MOB_STATS.get());
                if (aMob != null && heal > 0) {
                    aMob.setCurrentHealth(aMob.getCurrentHealth() + heal);
                    aMob.markDirty();
                }
            }
        }

        return applied;
    }

    // ===== helpers =====

    /** Чтение глобальной редукции урона. До того как поле появится в StatSnapshot — вернёт 0f. */
    private static float readDamageReductionAll(StatSnapshot snap) {
        try {
            var f = snap.getClass().getField("damageReductionAll"); // публичное поле
            Object v = f.get(snap);
            if (v instanceof Number n) return n.floatValue();
        } catch (Throwable ignored) {
            try { // попробуем геттер на всякий случай
                var m = snap.getClass().getMethod("damageReductionAll");
                Object v = m.invoke(snap);
                if (v instanceof Number n) return n.floatValue();
            } catch (Throwable ignored2) {}
        }
        return 0f;
    }

    private static float clamp01(float v, float hardCap) {
        if (Float.isNaN(v) || Float.isInfinite(v)) return 0f;
        if (hardCap <= 0f) hardCap = 1f;
        return Math.max(0f, Math.min(v, hardCap));
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java -----
package com.doomspire.grimcore.combat;

import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.damagesource.DamageTypes;

import java.util.Map;

public final class EnvironmentalDamage {
    private EnvironmentalDamage(){}

    // проценты от maxHP (0..1)
    private static final Map<net.minecraft.resources.ResourceKey<net.minecraft.world.damagesource.DamageType>, Float> PERCENTS = Map.of(
            DamageTypes.FALL, 0.15f,
            DamageTypes.DROWN, 0.10f,
            DamageTypes.LAVA, 0.25f,
            DamageTypes.ON_FIRE, 0.08f,
            DamageTypes.IN_FIRE, 0.12f,
            DamageTypes.HOT_FLOOR, 0.10f,
            DamageTypes.SWEET_BERRY_BUSH, 0.04f,
            DamageTypes.OUTSIDE_BORDER, 1.0f
    );

    public static Float percentFor(DamageSource src) {
        for (var e : PERCENTS.entrySet()) {
            if (src.is(e.getKey())) return e.getValue();
        }
        return null;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.commands.GrimfateCommands;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.RegisterCommandsEvent;

@EventBusSubscriber(modid = Grimcore.MODID)
public final class CommandBusHandlers {
    private CommandBusHandlers(){}

    @SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent e) {
        GrimfateCommands.register(e.getDispatcher());
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java -----
package com.doomspire.grimcore.commands;

import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;

import java.util.Collection;
import java.util.List;

public final class GrimfateCommands {
    private GrimfateCommands(){}

    public static void register(CommandDispatcher<CommandSourceStack> d) {
        d.register(
                Commands.literal("grimfate")
                        .requires(src -> src.hasPermission(2)) // только операторы по умолчанию
                        .then(Commands.literal("give")
                                .then(Commands.literal("exp")
                                        // вариант: /grimfate give exp <amount>
                                        .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                                .executes(ctx -> {
                                                    ServerPlayer target = ctx.getSource().getPlayerOrException();
                                                    int amount = IntegerArgumentType.getInteger(ctx, "amount");
                                                    return giveExp(ctx.getSource(), List.of(target), amount);
                                                })
                                                // вариант: /grimfate give exp <amount> <targets>
                                                .then(Commands.argument("targets", EntityArgument.players())
                                                        .executes(ctx -> {
                                                            Collection<ServerPlayer> targets = EntityArgument.getPlayers(ctx, "targets");
                                                            int amount = IntegerArgumentType.getInteger(ctx, "amount");
                                                            return giveExp(ctx.getSource(), targets, amount);
                                                        })
                                                )
                                        )
                                )
                        )
        );
    }

    private static int giveExp(CommandSourceStack src, Collection<ServerPlayer> targets, int amount) {
        int totalLevels = 0;

        for (ServerPlayer player : targets) {
            PlayerProgressAttachment prog = player.getData(ModAttachments.PLAYER_PROGRESS.get());
            PlayerStatsAttachment    stats= player.getData(ModAttachments.PLAYER_STATS.get());
            if (prog == null || stats == null) continue;

            int levels = prog.addExp(amount);
            if (levels > 0) {
                stats.addUnspentPoints(levels);
                stats.markDirty();
                GrimcoreNetworking.syncPlayerStats(player, stats);         // мгновенный HUD (очки/полосы)
            }
            ProgressNetworking.syncPlayerProgress(player, prog);            // мгновенный HUD (XP/уровень)

            totalLevels += levels;
            src.sendSuccess(() -> Component.literal(
                    "Given " + amount + " XP to " + player.getGameProfile().getName() +
                            (levels > 0 ? (" (+" + levels + " level)") : "")), true);
        }

        return Math.max(1, totalLevels);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java -----
package com.doomspire.grimcore.config;

import net.neoforged.neoforge.common.ModConfigSpec;

public final class CoreCommonConfig {
    //    public static final ModConfigSpec SPEC;
    //    public static final ModConfigSpec.BooleanValue PULL_ENABLED;
    //    public static final ModConfigSpec.IntValue PULL_RADIUS;     // 0..4
    //    public static final ModConfigSpec.IntValue MAX_CONTAINERS;  // safety cap
    //
            //    static {
        //        ModConfigSpec.Builder b = new ModConfigSpec.Builder();
        //        PULL_ENABLED   = b.comment("Enable QoL pulling from nearby containers").define("pullEnabled", true);
        //        PULL_RADIUS    = b.comment("Pull radius (0..4)").defineInRange("pullRadius", 3, 0, 4);
        //        MAX_CONTAINERS = b.comment("Safety cap for scanned containers").defineInRange("maxContainers", 24, 1, 128);
        //        SPEC = b.build();
        //    }

    private CoreCommonConfig() {}
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.spell.api.SpellSchool;
import com.mojang.serialization.Codec;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;

/**
 * Разрешённые дисциплины (школы), при которых предмет активирует бонусы/эффект.
 * Например: только WARCRY/TECHNIQUE.
 *
 * Иммутабельный компонент с корректными equals/hashCode.
 */
public final class ClassRestrictionComponent {
    private final EnumSet<SpellSchool> allowed; // внутреннее хранилище

    public ClassRestrictionComponent(Set<SpellSchool> allowed) {
        EnumSet<SpellSchool> s = allowed == null || allowed.isEmpty()
                ? EnumSet.noneOf(SpellSchool.class)
                : EnumSet.copyOf(allowed);
        this.allowed = s;
    }

    /** Пустой набор = разрешено всем. */
    public boolean isAllowed(SpellSchool school) {
        return allowed.isEmpty() || allowed.contains(school);
    }

    /** Неизменяемое представление. */
    public Set<SpellSchool> allowed() {
        return Collections.unmodifiableSet(allowed);
    }

    public static final Codec<SpellSchool> SCHOOL_CODEC =
            Codec.STRING.xmap(s -> SpellSchool.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<ClassRestrictionComponent> CODEC =
            SCHOOL_CODEC.listOf().xmap(list -> new ClassRestrictionComponent(Set.copyOf(list)),
                    c -> java.util.List.copyOf(c.allowed()));

    public static final StreamCodec<RegistryFriendlyByteBuf, ClassRestrictionComponent> STREAM_CODEC =
            StreamCodec.of(
                    (buf, c) -> {
                        ByteBufCodecs.VAR_INT.encode(buf, c.allowed.size());
                        for (var s : c.allowed) ByteBufCodecs.fromCodec(SCHOOL_CODEC).encode(buf, s);
                    },
                    buf -> {
                        int n = ByteBufCodecs.VAR_INT.decode(buf);
                        EnumSet<SpellSchool> set = EnumSet.noneOf(SpellSchool.class);
                        for (int i = 0; i < n; i++) set.add(ByteBufCodecs.fromCodec(SCHOOL_CODEC).decode(buf));
                        return new ClassRestrictionComponent(set);
                    }
            );

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ClassRestrictionComponent that)) return false;
        return Objects.equals(allowed, that.allowed);
    }

    @Override
    public int hashCode() {
        return Objects.hash(allowed);
    }

    @Override
    public String toString() {
        return "ClassRestrictionComponent" + allowed;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ResistBonusComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.stat.DamageTypes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.EnumMap;
import java.util.Map;

public record ResistBonusComponent(Map<DamageTypes, Float> byType) {
    public static final Codec<DamageTypes> TYPE_CODEC =
            Codec.STRING.xmap(s -> DamageTypes.valueOf(s.toUpperCase()), t -> t.name().toLowerCase());

    public static final Codec<Map<DamageTypes, Float>> MAP_CODEC = Codec.unboundedMap(TYPE_CODEC, Codec.FLOAT);

    public static final Codec<ResistBonusComponent> CODEC = RecordCodecBuilder.create(i -> i.group(
            MAP_CODEC.fieldOf("by_type").forGetter(ResistBonusComponent::byType)
    ).apply(i, ResistBonusComponent::new));

    public static final StreamCodec<RegistryFriendlyByteBuf, ResistBonusComponent> STREAM_CODEC =
            new StreamCodec<>() {
                @Override public ResistBonusComponent decode(RegistryFriendlyByteBuf buf) {
                    int n = buf.readVarInt();
                    Map<DamageTypes, Float> map = new EnumMap<>(DamageTypes.class);
                    for (int k = 0; k < n; k++) {
                        DamageTypes t = DamageTypes.valueOf(buf.readUtf().toUpperCase());
                        map.put(t, buf.readFloat());
                    }
                    return new ResistBonusComponent(map);
                }
                @Override public void encode(RegistryFriendlyByteBuf buf, ResistBonusComponent v) {
                    var m = v.byType();
                    buf.writeVarInt(m.size());
                    m.forEach((t, f) -> { buf.writeUtf(t.name().toLowerCase()); buf.writeFloat(f); });
                }
            };
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ResistBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.stat.Attributes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;
import java.util.Objects;

/**
 * Иммутабельный data-component с бонусами к атрибутам, напр.:
 * {"strength": 3, "intelligence": 2}
 *
 * Требования NeoForge к компонентам:
 *  - иммутабельность
 *  - корректные equals/hashCode
 */
public final class StatBonusComponent {

    private final EnumMap<Attributes, Integer> bonus; // иммутабельное содержимое

    public StatBonusComponent(Map<Attributes, Integer> map) {
        EnumMap<Attributes, Integer> tmp = new EnumMap<>(Attributes.class);
        if (map != null) {
            for (var e : map.entrySet()) {
                if (e.getKey() != null) {
                    int v = e.getValue() == null ? 0 : e.getValue();
                    if (v != 0) tmp.put(e.getKey(), v);
                }
            }
        }
        this.bonus = tmp.isEmpty() ? new EnumMap<>(Attributes.class) : new EnumMap<>(tmp);
    }

    /** Возвращает бонус для заданного атрибута (0 если не задан). */
    public int get(Attributes a) {
        Integer v = bonus.get(a);
        return v == null ? 0 : v;
    }

    /** Неизменяемое представление всех бонусов. */
    public Map<Attributes, Integer> all() {
        return Collections.unmodifiableMap(bonus);
    }

    // --- Codec/StreamCodec ---
    public static final Codec<Attributes> ATTR_CODEC =
            Codec.STRING.xmap(s -> Attributes.valueOf(s.toUpperCase()), a -> a.name().toLowerCase());

    public static final Codec<StatBonusComponent> CODEC =
            Codec.unboundedMap(ATTR_CODEC, Codec.INT)
                    .xmap(StatBonusComponent::new, c -> c.all());

    public static final StreamCodec<RegistryFriendlyByteBuf, StatBonusComponent> STREAM_CODEC =
            StreamCodec.of(
                    (buf, c) -> {
                        var map = c.bonus;
                        ByteBufCodecs.VAR_INT.encode(buf, map.size());
                        for (var e : map.entrySet()) {
                            ByteBufCodecs.fromCodec(ATTR_CODEC).encode(buf, e.getKey());
                            ByteBufCodecs.VAR_INT.encode(buf, e.getValue());
                        }
                    },
                    buf -> {
                        int n = ByteBufCodecs.VAR_INT.decode(buf);
                        EnumMap<Attributes, Integer> m = new EnumMap<>(Attributes.class);
                        for (int i = 0; i < n; i++) {
                            Attributes a = ByteBufCodecs.fromCodec(ATTR_CODEC).decode(buf);
                            int v = ByteBufCodecs.VAR_INT.decode(buf);
                            if (v != 0) m.put(a, v);
                        }
                        return new StatBonusComponent(m);
                    }
            );

    // --- equals/hashCode (по содержимому карты) ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof StatBonusComponent that)) return false;
        return Objects.equals(bonus, that.bonus);
    }

    @Override
    public int hashCode() {
        return Objects.hash(bonus);
    }

    @Override
    public String toString() {
        return "StatBonusComponent" + bonus;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java -----
package com.doomspire.grimcore.data;

import com.doomspire.grimcore.data.component.StatBonusComponent;
import com.doomspire.grimcore.stat.Attributes;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.player.Player;

public final class ItemBonusHelper {
    private ItemBonusHelper(){}

    public static int sum(Player p, Attributes attr) {
        int total = 0;
        for (var slot : EquipmentSlot.values()) {
            var stack = p.getItemBySlot(slot);
            if (stack.isEmpty()) continue;
            var comp = stack.get(ModDataComponents.STAT_BONUS.get());
            if (comp != null) total += comp.get(attr);
        }
        return total;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java -----
package com.doomspire.grimcore.data;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.data.component.ClassRestrictionComponent;
import com.doomspire.grimcore.data.component.StatBonusComponent;
import net.minecraft.core.registries.Registries;
import net.minecraft.core.component.DataComponentType;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModDataComponents {
    private ModDataComponents() {}

    public static final DeferredRegister<DataComponentType<?>> COMPONENT_TYPES =
            DeferredRegister.create(Registries.DATA_COMPONENT_TYPE, Grimcore.MODID);

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<StatBonusComponent>> STAT_BONUS =
            COMPONENT_TYPES.register("stat_bonus", () ->
                    DataComponentType.<StatBonusComponent>builder()
                            .persistent(StatBonusComponent.CODEC)
                            .networkSynchronized(StatBonusComponent.STREAM_CODEC)
                            .build()
            );

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<ClassRestrictionComponent>> CLASS_RESTRICTION =
            COMPONENT_TYPES.register("class_restriction", () ->
                    DataComponentType.<ClassRestrictionComponent>builder()
                            .persistent(ClassRestrictionComponent.CODEC)
                            .networkSynchronized(ClassRestrictionComponent.STREAM_CODEC)
                            .build()
            );

    public static void init(net.neoforged.bus.api.IEventBus modBus) {
        COMPONENT_TYPES.register(modBus);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import net.minecraft.resources.ResourceLocation;
import org.jetbrains.annotations.Nullable;

/** Глобальный снимок data-driven баланса (обновляется при перезагрузке датапаков). */
public final class Balance {
    private Balance() {}

    private static volatile LevelsCurve levels = LevelsCurve.defaults();
    private static volatile AttributesBalance attributes = AttributesBalance.defaults();
    private static volatile SpellTuning spells = SpellTuning.defaults();

    public static void set(LevelsCurve l, AttributesBalance a, SpellTuning s) {
        levels = (l != null) ? l : LevelsCurve.defaults();
        attributes = (a != null) ? a : AttributesBalance.defaults();
        spells = (s != null) ? s : SpellTuning.defaults();
    }

    public static LevelsCurve levels() { return levels; }
    public static AttributesBalance attributes() { return attributes; }
    public static SpellTuning spells() { return spells; }

    public static @Nullable SpellTuning.Entry getSpellEntry(ResourceLocation id) {
        return spells.byId().get(id);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.doomspire.grimcore.stat.Attributes;
import com.mojang.logging.LogUtils;
import org.slf4j.Logger;

import java.util.EnumMap;
import java.util.Map;

/**
 * Глобальный кэш загруженных из datapack'ов балансовых таблиц.
 * Потокобезопасность: доступ только с сервера-треда при reload/старте.
 */
public final class BalanceData {
    private static final Logger LOG = LogUtils.getLogger();

    // Текущие активные значения
    private static volatile LevelsCurve levelsCurve = LevelsCurve.defaults();
    private static volatile AttributesBalance attributes = AttributesBalance.defaults();
    private static volatile SpellTuning spellTuning = SpellTuning.defaults();

    private BalanceData() {}

    public static LevelsCurve levels() { return levelsCurve; }
    public static AttributesBalance attrs() { return attributes; }
    public static SpellTuning spells() { return spellTuning; }

    /** Вызывается из BalanceReloadListener после успешного парсинга JSON. */
    static void apply(LevelsCurve lv, AttributesBalance ab, SpellTuning st) {
        if (lv != null) levelsCurve = lv;
        if (ab != null) attributes = ab;
        if (st != null) spellTuning = st;
        LOG.info("[Grim] Balance data applied: levels={}, attrs={}, spells={}",
                levelsCurve.summary(), attributes.summary(), spellTuning.summary());
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.mojang.logging.LogUtils;
import com.mojang.serialization.Codec;
import com.mojang.serialization.JsonOps;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.packs.resources.ResourceManager;
import net.minecraft.server.packs.resources.SimplePreparableReloadListener;
import net.minecraft.util.profiling.ProfilerFiller;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.event.AddReloadListenerEvent;
import org.slf4j.Logger;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;

/**
 * Читает JSON из:
 *  - data/grimfate/balance/levels.json
 *  - data/grimfate/balance/attributes.json
 *  - data/grimfate/balance/spells.json
 * и применяет в BalanceData.
 *
 * 1.21.1 / NeoForge: регистрируемся через AddReloadListenerEvent.
 */
public final class BalanceReloadListener extends SimplePreparableReloadListener<BalanceReloadListener.Data> {
    private static final Logger LOG = LogUtils.getLogger();

    /** Снэпшот подготовленных данных. */
    public record Data(LevelsCurve levels, AttributesBalance attrs, SpellTuning spells) {}

    /** Регистрация серверного reload-listener’а. */
    @SubscribeEvent
    public static void onAddReloadListeners(AddReloadListenerEvent e) {
        e.addListener(new BalanceReloadListener());
    }

    @Override
    protected Data prepare(ResourceManager rm, ProfilerFiller profiler) {
        var levels = readJson(rm, "grimfate", "balance/levels.json", LevelsCurve.CODEC);
        var attrs  = readJson(rm, "grimfate", "balance/attributes.json", AttributesBalance.CODEC);
        var spells = readJson(rm, "grimfate", "balance/spells.json", SpellTuning.CODEC);
        com.doomspire.grimcore.datapack.Balance.set(levels, attrs, spells);
        return new Data(levels, attrs, spells);
    }

    @Override
    protected void apply(Data data, ResourceManager rm, ProfilerFiller profiler) {
        BalanceData.apply(
                data.levels() != null ? data.levels() : LevelsCurve.defaults(),
                data.attrs()  != null ? data.attrs()  : AttributesBalance.defaults(),
                data.spells() != null ? data.spells() : SpellTuning.defaults()
        );
        LOG.info("[Grim] BalanceReloadListener applied.");
    }

    // ---------- helpers ----------

    private static <T> T readJson(ResourceManager rm, String namespace, String path, Codec<T> codec) {
        try {
            ResourceLocation rl = ResourceLocation.fromNamespaceAndPath(namespace, path);
            var opt = rm.getResource(rl);
            if (opt.isEmpty()) return null;

            try (var in = opt.get().open();
                 var br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
                var json = com.google.gson.JsonParser.parseReader(br);
                var parsed = codec.parse(JsonOps.INSTANCE, json);
                return parsed.result().orElse(null);
            }
        } catch (Exception ex) {
            LOG.error("[Grim] Failed to read json {}/{}: {}", namespace, path, ex.toString());
            return null;
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java -----
package com.doomspire.grimcore.datapack.codec;

import com.doomspire.grimcore.stat.Attributes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

import java.util.EnumMap;
import java.util.Map;

public record AttributesBalance(Map<Attributes, Rule> byAttr) {

    public static final Codec<Rule> RULE_CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.optionalFieldOf("cap", 99).forGetter(Rule::cap),
            Codec.DOUBLE.optionalFieldOf("max_health_per", 5.0).forGetter(Rule::maxHealthPer),
            Codec.DOUBLE.optionalFieldOf("max_mana_per", 5.0).forGetter(Rule::maxManaPer),
            Codec.DOUBLE.optionalFieldOf("regen_hp_per", 0.05).forGetter(Rule::regenHpPer),
            Codec.DOUBLE.optionalFieldOf("regen_mp_per", 0.05).forGetter(Rule::regenMpPer),
            Codec.DOUBLE.optionalFieldOf("crit_chance_per", 0.0).forGetter(Rule::critChancePer),
            Codec.DOUBLE.optionalFieldOf("evasion_per", 0.0).forGetter(Rule::evasionPer),
            Codec.DOUBLE.optionalFieldOf("melee_damage_per", 0.0).forGetter(Rule::meleeDamagePer),
            Codec.DOUBLE.optionalFieldOf("spell_power_per", 0.0).forGetter(Rule::spellPowerPer),
            Codec.DOUBLE.optionalFieldOf("cast_speed_per", 0.0).forGetter(Rule::castSpeedPer)
    ).apply(i, Rule::new));

    public static final Codec<Attributes> ATTR_CODEC =
            Codec.STRING.xmap(s -> Attributes.valueOf(s.toUpperCase()), a -> a.name().toLowerCase());

    public static final Codec<Map<Attributes, Rule>> MAP_CODEC =
            Codec.unboundedMap(ATTR_CODEC, RULE_CODEC).xmap(m -> {
                EnumMap<Attributes, Rule> map = new EnumMap<>(Attributes.class);
                map.putAll(m);
                return map;
            }, m -> m);

    public static final Codec<AttributesBalance> CODEC =
            RecordCodecBuilder.create(i -> i.group(
                    MAP_CODEC.fieldOf("attributes").forGetter(AttributesBalance::byAttr)
            ).apply(i, AttributesBalance::new));

    public static AttributesBalance defaults() {
        EnumMap<Attributes, Rule> def = new EnumMap<>(Attributes.class);
        for (Attributes a : Attributes.values()) {
            int cap = (a == Attributes.EVASION) ? 100 : 99;

            double maxHealthPer = (a == Attributes.VITALITY) ? 6.0 : 0.0;
            double regenHpPer   = (a == Attributes.VITALITY) ? 0.06 : 0.0;

            double maxManaPer   = (a == Attributes.SPIRIT) ? 10.0 : 0.0;
            double regenMpPer   = (a == Attributes.SPIRIT) ? 0.08 : 0.0;

            double meleePer     = (a == Attributes.STRENGTH) ? 0.7 : 0.0;
            double spellPer     = (a == Attributes.INTELLIGENCE) ? 0.7 : 0.0;
            double castPer      = (a == Attributes.DEXTERITY) ? 0.5 : 0.0;
            double evasionPer   = (a == Attributes.EVASION) ? 0.5 : 0.0;

            def.put(a, new Rule(cap, maxHealthPer, maxManaPer, regenHpPer, regenMpPer,
                    0.0, evasionPer, meleePer, spellPer, castPer));
        }
        return new AttributesBalance(def);
    }

    public int cap(Attributes a) { return byAttr.getOrDefault(a, defaults().byAttr.get(a)).cap; }

    public String summary() { return "attrs=" + byAttr.size(); }

    public record Rule(
            int cap,
            double maxHealthPer,
            double maxManaPer,
            double regenHpPer,
            double regenMpPer,
            double critChancePer,
            double evasionPer,
            double meleeDamagePer,
            double spellPowerPer,
            double castSpeedPer
    ) {}
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java -----
package com.doomspire.grimcore.datapack.codec;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

public record LevelsCurve(int maxLevel, double base, double growth) {

    public static final Codec<LevelsCurve> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.fieldOf("max_level").forGetter(LevelsCurve::maxLevel),
            Codec.DOUBLE.fieldOf("base").forGetter(LevelsCurve::base),
            Codec.DOUBLE.fieldOf("growth").forGetter(LevelsCurve::growth)
    ).apply(i, LevelsCurve::new));

    public static LevelsCurve defaults() {
        return new LevelsCurve(50, 100.0, 1.10); // прежние дефолты, пока не пришли данные из датапака
    }

    public String summary() {
        return "max=" + maxLevel + ", base=" + base + ", growth=" + growth;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java -----
package com.doomspire.grimcore.datapack.codec;

import com.doomspire.grimcore.spell.api.SpellSchool;
import com.doomspire.grimcore.spell.api.SpellTag;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.resources.ResourceLocation;

import java.util.List;
import java.util.Map;

public record SpellTuning(Map<ResourceLocation, Entry> byId) {

    public static final Codec<ResourceLocation> RL_CODEC = ResourceLocation.CODEC;

    public static final Codec<SpellSchool> SCHOOL_CODEC =
            Codec.STRING.xmap(s -> SpellSchool.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<SpellTag> TAG_CODEC =
            Codec.STRING.xmap(s -> SpellTag.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<Scaling> SCALING_CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.DOUBLE.optionalFieldOf("vitality", 0.0).forGetter(Scaling::vitality),
            Codec.DOUBLE.optionalFieldOf("strength", 0.0).forGetter(Scaling::strength),
            Codec.DOUBLE.optionalFieldOf("intelligence", 0.0).forGetter(Scaling::intelligence),
            Codec.DOUBLE.optionalFieldOf("spirit", 0.0).forGetter(Scaling::spirit),
            Codec.DOUBLE.optionalFieldOf("dexterity", 0.0).forGetter(Scaling::dexterity),
            Codec.DOUBLE.optionalFieldOf("evasion", 0.0).forGetter(Scaling::evasion)
    ).apply(i, Scaling::new));

    public static final Codec<Entry> ENTRY_CODEC = RecordCodecBuilder.create(i -> i.group(
            SCHOOL_CODEC.fieldOf("school").forGetter(Entry::school),
            Codec.list(TAG_CODEC).optionalFieldOf("tags", List.of()).forGetter(Entry::tags),
            Codec.INT.optionalFieldOf("base_cost", 0).forGetter(Entry::baseCost),
            Codec.INT.optionalFieldOf("base_cooldown", 0).forGetter(Entry::baseCooldown),
            SCALING_CODEC.optionalFieldOf("scaling", Scaling.ZERO).forGetter(Entry::scaling),
            Codec.list(Codec.STRING).optionalFieldOf("forbidden_weapons", List.of()).forGetter(Entry::forbiddenWeapons),
            Codec.list(Codec.STRING).optionalFieldOf("allowed_armor_tags", List.of()).forGetter(Entry::allowedArmorTags)
    ).apply(i, Entry::new));

    public static final Codec<Map<ResourceLocation, Entry>> MAP_CODEC =
            Codec.unboundedMap(RL_CODEC, ENTRY_CODEC);

    public static final Codec<SpellTuning> CODEC =
            RecordCodecBuilder.create(i -> i.group(
                    MAP_CODEC.fieldOf("spells").forGetter(SpellTuning::byId)
            ).apply(i, SpellTuning::new));

    /** Значения по умолчанию — пустой набор. */
    public static SpellTuning defaults() {
        return new SpellTuning(Map.of());
    }

    /** Короткий summary для логов. */
    public String summary() {
        return "spells=" + (byId != null ? byId.size() : 0);
    }

    // --- types ---

    public record Entry(
            SpellSchool school,
            List<SpellTag> tags,
            int baseCost,
            int baseCooldown,
            Scaling scaling,
            List<String> forbiddenWeapons,
            List<String> allowedArmorTags
    ) {}

    public record Scaling(
            double vitality,
            double strength,
            double intelligence,
            double spirit,
            double dexterity,
            double evasion
    ) {
        public static final Scaling ZERO = new Scaling(0,0,0,0,0,0);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.attach.ThreatService;            // ← добавлено
import com.doomspire.grimcore.combat.DamageContext;
import com.doomspire.grimcore.combat.DamageEngine;
import com.doomspire.grimcore.combat.EnvironmentalDamage;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.DamageTypes;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;               // ← добавлено
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.living.LivingDamageEvent;

public final class CoreDamageEvents {

    private CoreDamageEvents() {}
    /**
     * Ядро обработки урона. Никакой предметной/спелл-логики здесь нет.
     * Сначала экологический урон (% от MaxHP), затем боевой пайплайн.
     */
    @SubscribeEvent
    public static void onLivingDamage(LivingDamageEvent.Pre event) {
        LivingEntity living = event.getEntity();
        if (living.level().isClientSide() || !living.isAlive()) return;

        // ---------- Экологический урон как % MaxHP ----------
        Float pct = EnvironmentalDamage.percentFor(event.getSource());
        if (pct != null) {
            if (living instanceof ServerPlayer sp) {
                PlayerStatsAttachment ps = sp.getData(ModAttachments.PLAYER_STATS.get());
                if (ps != null) {
                    int max = (int) Math.max(1, ps.getSnapshot().maxHealth);
                    int delta = Math.max(1, Math.round(max * pct));
                    ps.setCurrentHealth(ps.getCurrentHealth() - delta);
                    ps.markDirty();
                    // мгновенный синк HUD
                    GrimcoreNetworking.syncPlayerStats(sp, ps);
                    event.setNewDamage(0f);
                    if (ps.getCurrentHealth() <= 0) killByGeneric(sp);
                }
                return;
            } else {
                MobStatsAttachment ms = living.getData(ModAttachments.MOB_STATS.get());
                if (ms != null) {
                    int max = (int) Math.max(1, ms.getSnapshot().maxHealth);
                    int delta = Math.max(1, Math.round(max * pct));
                    ms.setCurrentHealth(ms.getCurrentHealth() - delta);
                    ms.markDirty();
                    event.setNewDamage(0f);
                    if (ms.getCurrentHealth() <= 0) killByGeneric(living);
                }
                return;
            }
        }

        float amountAfterContent = event.getNewDamage();
        if (amountAfterContent <= 0f) return;

        Entity src = event.getSource() != null ? event.getSource().getEntity() : null;

        // ---------- Цель — игрок: расчёт через DamageEngine ----------
        if (living instanceof ServerPlayer serverPlayer) {
            LivingEntity attacker = (src instanceof LivingEntity le) ? le : null;

            DamageContext ctx = new DamageContext(attacker, serverPlayer);
            if (attacker != null) {
                // если атакует моб с кастомными статами — берём его физический урон
                MobStatsAttachment aStats = attacker.getData(ModAttachments.MOB_STATS.get());
                if (aStats != null) {
                    float phys = aStats.getSnapshot().damage.getOrDefault(DamageTypes.PHYS_MELEE, amountAfterContent);
                    ctx.add(DamageTypes.PHYS_MELEE, phys);
                } else {
                    // иначе fallback на ванильное число
                    ctx.add(DamageTypes.PHYS_MELEE, amountAfterContent);
                }
            } else {
                ctx.add(DamageTypes.PHYS_MELEE, amountAfterContent);
            }

            DamageEngine.resolveAndApply(ctx);
            event.setNewDamage(0f);

            PlayerStatsAttachment att = serverPlayer.getData(ModAttachments.PLAYER_STATS.get());
            if (att != null && att.getCurrentHealth() <= 0) killByGeneric(serverPlayer);
            return;
        }

        // ---------- Цель — моб: прямое применение к кастомному HP ----------
        {
            float base = amountAfterContent;
            if (src instanceof LivingEntity le) {
                MobStatsAttachment aStats = le.getData(ModAttachments.MOB_STATS.get());
                if (aStats != null) {
                    base = aStats.getSnapshot().damage.getOrDefault(DamageTypes.PHYS_MELEE, base);
                }
            }
            MobStatsAttachment tStats = living.getData(ModAttachments.MOB_STATS.get());
            if (tStats != null) {
                int before = tStats.getCurrentHealth();
                int applied = Math.max(0, Math.min(before, Math.round(base))); // фактически нанесённый урон

                // === НОВОЕ: угроза от урона игрока ===
                if (applied > 0 && src instanceof Player pA) {
                    ThreatService.addThreatFromDamage(living, pA, applied);
                }

                tStats.setCurrentHealth(before - applied);
                tStats.markDirty();
                event.setNewDamage(0f);
                if ((before - applied) <= 0) killByGeneric(living);
            }
        }
    }

    private static void killByGeneric(LivingEntity entity) {
        entity.setHealth(0f);
        DamageSource genericKill = new DamageSource(
                entity.level().registryAccess()
                        .registryOrThrow(Registries.DAMAGE_TYPE)
                        .getHolderOrThrow(net.minecraft.world.damagesource.DamageTypes.GENERIC_KILL)
        );
        entity.hurt(genericKill, Float.MAX_VALUE);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatEffects;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.PlayerEvent;

public final class CorePlayerEvents {
    private CorePlayerEvents() {}

    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!(event.getEntity() instanceof ServerPlayer player)) return;

        PlayerStatsAttachment stats = player.getData(ModAttachments.PLAYER_STATS.get());
        if (stats == null) return;

        // первичная инициализация «текущих» ресурсов
        var snap = stats.getSnapshot();
        if (stats.getCurrentHealth() <= 0) stats.setCurrentHealth((int) snap.maxHealth);
        if (stats.getCurrentMana()   <= 0) stats.setCurrentMana((int) snap.maxMana);
        stats.markDirty();

        // синк клиенту, чтобы HUD сразу обновился
        GrimcoreNetworking.syncPlayerStats(player, stats);

        // применяем ВСЕ эффекты статов к ванильным атрибутам (DEX→скорость и т.д.)
        StatEffects.applyAll(player);
    }

    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!(event.getEntity() instanceof ServerPlayer player)) return;

        // после респауна: повторно применяем эффекты (могли слететь с нового Entity)
        StatEffects.applyAll(player);
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.EntityJoinLevelEvent;

public final class MobSpawnInit {
    private MobSpawnInit(){}

    @SubscribeEvent
    public static void onJoin(EntityJoinLevelEvent event) {
        if (event.getLevel().isClientSide()) return;
        if (!(event.getEntity() instanceof LivingEntity living)) return;
        if (living instanceof net.minecraft.world.entity.player.Player) return;

        MobStatsAttachment att = living.getData(ModAttachments.MOB_STATS.get());
        if (att == null) {
            att = new MobStatsAttachment();
            living.setData(ModAttachments.MOB_STATS.get(), att);
        }

        // Применяем data-driven оверрайд (если есть)
        MobTuning.applyPerEntityOverrides((ServerLevel) event.getLevel(), living, att);

        // Инициализируем HP от max
        int max = (int)Math.max(1, att.getSnapshot().maxHealth);
        if (att.getCurrentHealth() <= 0) att.setCurrentHealth(max);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;

/**
 * Заглушка-провайдер пер-мобных оверрайдов.
 * На следующем шаге подменим на чтение JSON из datapack.
 */
public final class MobTuning {
    private MobTuning(){}

    public static void applyPerEntityOverrides(ServerLevel level, LivingEntity mob, MobStatsAttachment att) {
        ResourceLocation id = mob.getType().builtInRegistryHolder().key().location();
        // Пример: зомби — пожирнее, паук — ловчее
        if ("minecraft".equals(id.getNamespace()) && "zombie".equals(id.getPath())) {
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.VITALITY, 3);
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.STRENGTH, 2);
        } else if ("minecraft".equals(id.getNamespace()) && "spider".equals(id.getPath())) {
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.EVASION, 5);
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.DEXTERITY, 3);
        }
        att.markDirty();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.PlayerEvent;
import net.neoforged.neoforge.event.tick.PlayerTickEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Простая серверная регенерация HP/MP с аккумуляторами.
 * - считает реген каждый тик
 * - применяет целые очки, дробную часть копит
 * - синкает на клиент не чаще, чем раз в 10 тиков и только при изменениях
 */
public final class RegenTicker {
    private RegenTicker(){}

    private static final class Accum {
        double hpFrac = 0.0;
        double mpFrac = 0.0;
        int    lastSyncedHp = Integer.MIN_VALUE;
        int    lastSyncedMp = Integer.MIN_VALUE;
        long   lastSyncGameTime = 0L;
    }

    private static final Map<UUID, Accum> ACCUMS = new HashMap<>();
    private static final int SYNC_COOLDOWN_TICKS = 10;

    @SubscribeEvent
    public static void onPlayerTick(PlayerTickEvent.Post e) {
        if (!(e.getEntity() instanceof ServerPlayer sp)) return;
        var level = sp.serverLevel();
        PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (att == null) return;

        StatSnapshot snap = att.getSnapshot();
        // реген/сек из снапшота → реген/тик
        double hpPerTick = Math.max(0.0, snap.regenHealth) / 20.0;
        double mpPerTick = Math.max(0.0, snap.regenMana)   / 20.0;

        var a = ACCUMS.computeIfAbsent(sp.getUUID(), k -> new Accum());
        a.hpFrac += hpPerTick;
        a.mpFrac += mpPerTick;

        int hpGain = (int) Math.floor(a.hpFrac);
        int mpGain = (int) Math.floor(a.mpFrac);
        if (hpGain != 0 || mpGain != 0) {
            a.hpFrac -= hpGain;
            a.mpFrac -= mpGain;

            // применяем к текущим ресурсам
            int beforeHp = att.getCurrentHealth();
            int beforeMp = att.getCurrentMana();
            att.setCurrentHealth(beforeHp + hpGain);
            att.setCurrentMana(beforeMp + mpGain);
            att.markDirty();

            // редкий синк: только если значения изменились и прошло >= cooldown
            boolean hpChanged = att.getCurrentHealth() != a.lastSyncedHp;
            boolean mpChanged = att.getCurrentMana()   != a.lastSyncedMp;
            long now = level.getGameTime();
            if ((hpChanged || mpChanged) && now - a.lastSyncGameTime >= SYNC_COOLDOWN_TICKS) {
                GrimcoreNetworking.syncPlayerStats(sp, att);
                a.lastSyncedHp = att.getCurrentHealth();
                a.lastSyncedMp = att.getCurrentMana();
                a.lastSyncGameTime = now;
            }
        }
    }

    @SubscribeEvent
    public static void onPlayerLoggedOut(PlayerEvent.PlayerLoggedOutEvent e) {
        if (e.getEntity() != null) {
            ACCUMS.remove(e.getEntity().getUUID());
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.LivingEntity;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.living.LivingDeathEvent;

public final class XpEvents {
    private XpEvents(){}

    public static void registerToBus() {
        NeoForge.EVENT_BUS.register(XpEvents.class);
    }

    @SubscribeEvent
    public static void onLivingDeath(LivingDeathEvent event) {
        if (event.getEntity().level().isClientSide()) return;

        LivingEntity dead = event.getEntity();
        if (dead instanceof ServerPlayer) return;

        ServerPlayer killer = null;
        if (event.getSource() != null && event.getSource().getEntity() instanceof ServerPlayer sp) {
            killer = sp;
        } else if (dead.getKillCredit() instanceof ServerPlayer sp2) {
            killer = sp2;
        }
        if (killer == null) return;

        // --- вычисляем "цену" моба ---
        int maxHp;
        MobStatsAttachment mobAtt = dead.getData(ModAttachments.MOB_STATS.get());
        if (mobAtt != null) {
            maxHp = Math.max(1, (int) mobAtt.getSnapshot().maxHealth);
        } else {
            maxHp = Math.max(1, (int) Math.ceil(dead.getMaxHealth()));
        }
        int xp = Math.max(1, Math.round((float) Math.pow(maxHp, 0.80) * 4f));

        // --- применяем на игроке ---
        PlayerProgressAttachment prog = killer.getData(ModAttachments.PLAYER_PROGRESS.get());
        PlayerStatsAttachment stats   = killer.getData(ModAttachments.PLAYER_STATS.get());
        if (prog == null || stats == null) return;

        int levels = prog.addExp(xp);

        if (levels > 0) {
            stats.addUnspentPoints(levels); // выдаём очки за ап-левел
            stats.markDirty();
            GrimcoreNetworking.syncPlayerStats(killer, stats); // мгновенно обновим HUD (очки можно показывать)
        }

        // прогресс: мгновенный клиентский синк (HUD увидит exp/level/cap)
        ProgressNetworking.syncPlayerProgress(killer, prog);
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.data.ModDataComponents;
import com.doomspire.grimcore.events.*;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;
import net.neoforged.neoforge.common.NeoForge;

@Mod(Grimcore.MODID)
public final class Grimcore {
    public static final String MODID = "grimcore";
    public Grimcore(IEventBus modEventBus, ModContainer container) {
        // attachments регистрируем на MOD bus
        com.doomspire.grimcore.stat.ModAttachments.ATTACHMENT_TYPES.register(modEventBus);
        ModDataComponents.init(modEventBus);
        // игровые события — на общий шина NeoForge
        NeoForge.EVENT_BUS.register(CoreDamageEvents.class);
        NeoForge.EVENT_BUS.register(CorePlayerEvents.class);
        NeoForge.EVENT_BUS.register(MobSpawnInit.class);
        NeoForge.EVENT_BUS.register(RegenTicker.class);


    }
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java -----
package com.doomspire.grimcore.item.comp;
// WIP: template for future extension (do not remove)
@org.jetbrains.annotations.ApiStatus.Experimental

public class BlockBonusComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java -----
package com.doomspire.grimcore.item.comp;
// WIP: template for future extension (do not remove)
@org.jetbrains.annotations.ApiStatus.Experimental

public class ClassRestrictionComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java -----
package com.doomspire.grimcore.item.comp;
// WIP: template for future extension (do not remove)
@org.jetbrains.annotations.ApiStatus.Experimental

public class StatBonusComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

@EventBusSubscriber(modid = Grimcore.MODID) // без bus = ...
public final class ModBusHandlers {
    private ModBusHandlers() {}

    @SubscribeEvent
    public static void onRegisterPayloads(RegisterPayloadHandlersEvent e) {
        GrimcoreNetworking.register(e);
        ProgressNetworking.register(e);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

public final class GrimcoreNetworking {
    private GrimcoreNetworking() {}

    public static void register(final RegisterPayloadHandlersEvent event) {
        var registrar = event.registrar(Grimcore.MODID);

        // 1.21.x: используем playToClient / playToServer и CustomPacketPayload.Type
        registrar.playToClient(
                S2C_SyncPlayerStats.TYPE,
                S2C_SyncPlayerStats.STREAM_CODEC,
                (payload, ctx) -> {
                    Player clientPlayer = Minecraft.getInstance().player;
                    if (clientPlayer != null) {
                        clientPlayer.setData(ModAttachments.PLAYER_STATS.get(), payload.att());
                    }
                }
        );
    }

    /** Вызывать на сервере после изменения HP/MP, чтобы HUD сразу обновился. */
    public static void syncPlayerStats(ServerPlayer target, PlayerStatsAttachment att) {
        PacketDistributor.sendToPlayer(target, new S2C_SyncPlayerStats(att));
    }

    // -------- payload (CLIENT-bound) --------
    public record S2C_SyncPlayerStats(PlayerStatsAttachment att) implements CustomPacketPayload {
        public static final Type<S2C_SyncPlayerStats> TYPE =
                new Type<>(ResourceLocation.fromNamespaceAndPath(Grimcore.MODID, "sync_player_stats"));

        public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncPlayerStats> STREAM_CODEC =
                StreamCodec.composite(
                        PlayerStatsAttachment.STREAM_CODEC, S2C_SyncPlayerStats::att,
                        S2C_SyncPlayerStats::new
                );

        @Override
        public Type<? extends CustomPacketPayload> type() {
            return TYPE;
        }
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

public final class ProgressNetworking {
    private ProgressNetworking(){}

    public static void register(final RegisterPayloadHandlersEvent event) {
        var registrar = event.registrar(Grimcore.MODID);
        registrar.playToClient(
                S2C_SyncPlayerProgress.TYPE,
                S2C_SyncPlayerProgress.STREAM_CODEC,
                (payload, ctx) -> {
                    var player = Minecraft.getInstance().player;
                    if (player != null) {
                        player.setData(ModAttachments.PLAYER_PROGRESS.get(), payload.att());
                    }
                }
        );
    }

    public static void syncPlayerProgress(ServerPlayer target, PlayerProgressAttachment att) {
        PacketDistributor.sendToPlayer(target, new S2C_SyncPlayerProgress(att));
    }

    public record S2C_SyncPlayerProgress(PlayerProgressAttachment att) implements CustomPacketPayload {
        public static final Type<S2C_SyncPlayerProgress> TYPE =
                new Type<>(ResourceLocation.fromNamespaceAndPath(Grimcore.MODID, "sync_player_progress"));

        public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncPlayerProgress> STREAM_CODEC =
                StreamCodec.composite(
                        PlayerProgressAttachment.STREAM_CODEC, S2C_SyncPlayerProgress::att,
                        S2C_SyncPlayerProgress::new
                );

        @Override
        public Type<? extends CustomPacketPayload> type() { return TYPE; }
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java -----
package com.doomspire.grimcore.runtime;

/**
 * Лёгкий runtime-хаб для каждого игрока.
 * Не сериализуется. Хранится в ConcurrentHashMap на сервере.
 */
public class PlayerRuntimeData {
    public double healthAccumulator = 0.0;
    public double manaAccumulator = 0.0;
    public long lastSyncTick = 0L; // gameTime последнего синка
    public boolean dirty = false;  // пометка для внешних систем
    // Кеши для тяжёлых вычислений
    public int cachedDamage = -1;
    public long cacheUntilTick = 0L;
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java -----
package com.doomspire.grimcore.runtime;

import net.minecraft.server.level.ServerPlayer;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Простой manager для runtime-данных (сервер).
 */
public final class PlayerRuntimeManager {
    private static final ConcurrentHashMap<UUID, PlayerRuntimeData> RUNTIME = new ConcurrentHashMap<>();

    private PlayerRuntimeManager() {}

    public static PlayerRuntimeData getOrCreate(ServerPlayer player) {
        return RUNTIME.computeIfAbsent(player.getUUID(), uuid -> new PlayerRuntimeData());
    }

    public static PlayerRuntimeData get(ServerPlayer player) {
        return RUNTIME.get(player.getUUID());
    }

    public static void remove(ServerPlayer player) {
        if (player != null) RUNTIME.remove(player.getUUID());
    }

    public static void remove(UUID uuid) {
        if (uuid != null) RUNTIME.remove(uuid);
    }

    public static void clearAll() {
        RUNTIME.clear();
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java -----
package com.doomspire.grimcore.spell.api;

public enum CastResult {
    OK,
    NOT_ENOUGH_MANA,
    ON_COOLDOWN,
    BLOCKED,
    FAIL
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.resources.ResourceLocation;

import java.util.Set;

/** Базовый контракт любого спелла. Реализации — stateless-singleton. */
public interface Spell {
    /** Уникальный id, например grimfate:fire_bolt */
    ResourceLocation id();

    /** Школа (для фильтров/баланса/синергий). */
    SpellSchool school();

    /** Стоимость маны (базовая, до модификаторов). */
    int manaCost(SpellContext ctx);

    /** Кулдаун в тиках (базовый, до модификаторов). */
    int cooldownTicks(SpellContext ctx);

    /** Основной вызов кастования. Возвращает результат (успешно/недостаточно ресурса/на кулдауне...). */
    CastResult cast(SpellContext ctx);

    Set<SpellTag> tags();
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.player.Player;
import org.jetbrains.annotations.Nullable;

/** Контекст вызова спелла (сервер). */
public final class SpellContext {
    public final ServerLevel level;
    public final Player caster;
    public final int slot;                  // слот хотбара спеллов; -1 если вне хотбара
    public final double aimX, aimY, aimZ;   // произвольные «наводочные» параметры
    @Nullable public final Object tuning;   // объект tюнинга (деcериализованный из SpellTuning), типизируем позже

    public SpellContext(ServerLevel level, Player caster, int slot, double aimX, double aimY, double aimZ, @Nullable Object tuning) {
        this.level = level;
        this.caster = caster;
        this.slot = slot;
        this.aimX = aimX;
        this.aimY = aimY;
        this.aimZ = aimZ;
        this.tuning = tuning;
    }

    public static SpellContext simple(ServerLevel lvl, Player caster) {
        return new SpellContext(lvl, caster, -1, 0, 0, 0, null);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java -----
package com.doomspire.grimcore.spell.api;

public enum SpellSchool {
    FIRE, FROST, LIGHTNING, POISON,
    TECHNIQUE, WARCRY, AURA, ARCANE, SHADOW,
    UTILITY
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java -----
package com.doomspire.grimcore.spell.api;

public enum SpellTag {
    MELEE, RANGED, BUFF, DEBUFF, MOVEMENT, PROJECTILE, AREA,
    CHANNELED, DOT, SHIELD, SUMMON, WEAPON_SKILL
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\WeaponGate.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.tags.TagKey;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;

import java.util.Objects;
import java.util.Set;
import java.util.function.BiFunction;

/**
 * Проверяет предмет в руках игрока против {@link WeaponRequirement}.
 * Учитывает теги, (опционально) двуручность и занятость offhand.
 */
public final class WeaponGate {

    /** Глобальный тег «двуручное» — grimfate:two_handed. */
    public static final TagKey<Item> TWO_HANDED =
            TagKey.create(Registries.ITEM, ResourceLocation.fromNamespaceAndPath("grimfate", "two_handed"));

    /** Внешний резолвер двуручности (например, читает WeaponProfileComponent в контент-модуле). */
    private static volatile BiFunction<ItemStack, Player, Boolean> TWO_HANDED_RESOLVER = null;

    private WeaponGate() {}

    /** Основная проверка: сначала main hand, затем offhand. */
    public static Result check(Player player, WeaponRequirement req) {
        Objects.requireNonNull(player, "player");
        Objects.requireNonNull(req, "requirement");

        ItemStack main = player.getMainHandItem();
        Result mainRes = checkStackAgainstRequirement(main, player, req, InteractionHand.MAIN_HAND, true);
        if (mainRes.ok) return mainRes;

        ItemStack off = player.getOffhandItem();
        Result offRes = checkStackAgainstRequirement(off, player, req, InteractionHand.OFF_HAND, true);
        if (offRes.ok) return offRes;

        return preferInformative(mainRes, offRes);
    }

    /**
     * Точечная проверка стака в конкретной руке.
     * @param enforceOffhandBlock если true — при двуручности запрещаем занятый offhand.
     */
    public static Result checkStackAgainstRequirement(ItemStack stack,
                                                      Player player,
                                                      WeaponRequirement req,
                                                      InteractionHand hand,
                                                      boolean enforceOffhandBlock) {
        if (stack.isEmpty()) {
            return Result.failKey("grimfate.msg.weapon_required",
                    "Требуется подходящее оружие в " + prettyHand(hand) + ".");
        }

        // Теги
        if (!matchesAny(stack, req.anyOfTags())) {
            return Result.failKey("grimfate.msg.weapon_required",
                    "Оружие в " + prettyHand(hand) + " не подходит (нет нужной категории).");
        }
        if (!matchesAll(stack, req.allOfTags())) {
            return Result.failKey("grimfate.msg.weapon_required",
                    "Оружие в " + prettyHand(hand) + " не подходит (не все требования выполнены).");
        }
        if (!matchesNone(stack, req.noneOfTags())) {
            return Result.failKey("grimfate.msg.weapon_forbidden",
                    "Оружие в " + prettyHand(hand) + " запрещено для этого умения.");
        }

        // Двуручность
        if (req.twoHandedOnly()) {
            boolean isTwoHanded = isTwoHanded(stack, player);
            if (!isTwoHanded) {
                return Result.failKey("grimfate.msg.two_handed_needed", "Нужно двуручное оружие.");
            }
            if (enforceOffhandBlock && !player.getOffhandItem().isEmpty()) {
                return Result.failKey("grimfate.msg.free_offhand", "Освободите вторую руку для двуручного оружия.");
            }
        }

        return Result.ok(hand);
    }

    // ---------- внешняя интеграция ----------
    /** Установить внешний резолвер двуручности. Возвращайте TRUE, если предмет двуручный. */
    public static void setTwoHandedResolver(BiFunction<ItemStack, Player, Boolean> resolver) {
        TWO_HANDED_RESOLVER = resolver;
    }

    // ---------- внутренняя логика ----------
    private static boolean isTwoHanded(ItemStack stack, Player player) {
        if (stack.is(TWO_HANDED)) return true;
        BiFunction<ItemStack, Player, Boolean> resolver = TWO_HANDED_RESOLVER;
        if (resolver != null) {
            try {
                Boolean r = resolver.apply(stack, player);
                if (Boolean.TRUE.equals(r)) return true;
            } catch (Throwable ignored) {}
        }
        return false;
    }

    private static boolean matchesAny(ItemStack stack, Set<TagKey<Item>> tags) {
        if (tags == null || tags.isEmpty()) return true;
        for (TagKey<Item> t : tags) if (stack.is(t)) return true;
        return false;
    }

    private static boolean matchesAll(ItemStack stack, Set<TagKey<Item>> tags) {
        if (tags == null || tags.isEmpty()) return true;
        for (TagKey<Item> t : tags) if (!stack.is(t)) return false;
        return true;
    }

    private static boolean matchesNone(ItemStack stack, Set<TagKey<Item>> tags) {
        if (tags == null || tags.isEmpty()) return true;
        for (TagKey<Item> t : tags) if (stack.is(t)) return false;
        return true;
    }

    private static String prettyHand(InteractionHand hand) {
        return hand == InteractionHand.MAIN_HAND ? "основной руке" : "второй руке";
    }

    private static Result preferInformative(Result a, Result b) {
        String ra = a.reason == null ? "" : a.reason;
        String rb = b.reason == null ? "" : b.reason;
        return (ra.length() >= rb.length()) ? a : b;
    }

    // ---------- результат ----------
    public static final class Result {
        public final boolean ok;
        /** Локализуемый ключ (если не null) — для UX сообщений на клиенте. */
        public final String reasonKey;
        /** Человекочитаемое пояснение (fallback, может быть на любом языке). */
        public final String reason;
        public final InteractionHand usedHand;

        private Result(boolean ok, String reasonKey, String reason, InteractionHand usedHand) {
            this.ok = ok;
            this.reasonKey = reasonKey;
            this.reason = reason;
            this.usedHand = usedHand;
        }

        public static Result ok(InteractionHand hand) {
            return new Result(true, null, null, hand);
        }

        public static Result failKey(String key, String fallbackText) {
            return new Result(false, key, fallbackText, null);
        }

        public static Result fail(String fallbackText) {
            return new Result(false, null, fallbackText, null);
        }

        @Override
        public String toString() {
            return ok ? "OK(" + usedHand + ")" : "FAIL(key=" + reasonKey + ", text=" + reason + ")";
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\WeaponGate.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\WeaponRequirement.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.tags.TagKey;
import net.minecraft.world.item.Item;

import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;

//NOTE: DTO c требованиями к оружию для кастов/навыков.* Опираемся на теги предметов (data/*/tags/items/...) и флаг двуручности.
/**
 * Семантика:
 *  - anyOfTags — хотя бы один из тегов должен совпасть;
 *  - allOfTags — каждый из тегов должен совпасть;
 *  - noneOfTags — ни один из тегов не должен совпасть (запрещённые категории);
 *  - twoHandedOnly — предмет должен быть двуручным (см. WeaponGate.TWO_HANDED и внешний резолвер).
 */

public final class WeaponRequirement {

    private final Set<TagKey<Item>> anyOfTags;
    private final Set<TagKey<Item>> allOfTags;
    private final Set<TagKey<Item>> noneOfTags;
    private final boolean twoHandedOnly;

    private WeaponRequirement(Set<TagKey<Item>> anyOf,
                              Set<TagKey<Item>> allOf,
                              Set<TagKey<Item>> noneOf,
                              boolean twoHandedOnly) {
        this.anyOfTags = anyOf == null ? Collections.emptySet() : Set.copyOf(anyOf);
        this.allOfTags = allOf == null ? Collections.emptySet() : Set.copyOf(allOf);
        this.noneOfTags = noneOf == null ? Collections.emptySet() : Set.copyOf(noneOf);
        this.twoHandedOnly = twoHandedOnly;
    }

    // ==== getters, которые ожидает WeaponGate ====
    public Set<TagKey<Item>> anyOfTags()   { return anyOfTags; }
    public Set<TagKey<Item>> allOfTags()   { return allOfTags; }
    public Set<TagKey<Item>> noneOfTags()  { return noneOfTags; }
    public boolean twoHandedOnly()         { return twoHandedOnly; }

    // ==== Builder API ====
    public static Builder builder() { return new Builder(); }

    public static final class Builder {
        private final LinkedHashSet<TagKey<Item>> any = new LinkedHashSet<>();
        private final LinkedHashSet<TagKey<Item>> all = new LinkedHashSet<>();
        private final LinkedHashSet<TagKey<Item>> none = new LinkedHashSet<>();
        private boolean twoHanded;

        /** Требуется совпасть ХОТЯ БЫ с одним из этих тегов. */
        public Builder anyOf(TagKey<Item> tag) { if (tag != null) any.add(tag); return this; }
        public Builder anyOf(ResourceLocation tagId) { return anyOf(tagKey(tagId)); }

        /** Требуется совпасть со ВСЕМИ этими тегами. */
        public Builder allOf(TagKey<Item> tag) { if (tag != null) all.add(tag); return this; }
        public Builder allOf(ResourceLocation tagId) { return allOf(tagKey(tagId)); }

        /** Предмет НЕ должен иметь ни один из этих тегов. */
        public Builder noneOf(TagKey<Item> tag) { if (tag != null) none.add(tag); return this; }
        public Builder noneOf(ResourceLocation tagId) { return noneOf(tagKey(tagId)); }

        /** Требовать двуручность. */
        public Builder requireTwoHanded(boolean v) { this.twoHanded = v; return this; }

        public WeaponRequirement build() {
            return new WeaponRequirement(any, all, none, twoHanded);
        }

        private static TagKey<Item> tagKey(ResourceLocation id) {
            Objects.requireNonNull(id, "tag id");
            return TagKey.create(Registries.ITEM, id);
        }
    }

    // ==== Удобные фабрики под наши теги ====
    public static WeaponRequirement stavesOnly() {
        return builder()
                .anyOf(ResourceLocation.fromNamespaceAndPath("grimfate", "staves"))
                .build();
    }

    public static WeaponRequirement bowsOnly() {
        return builder()
                .anyOf(ResourceLocation.fromNamespaceAndPath("grimfate", "bows"))
                .build();
    }

    public static WeaponRequirement twoHandedFrom(ResourceLocation... families) {
        Builder b = builder().requireTwoHanded(true);
        if (families != null) for (ResourceLocation id : families) b.anyOf(id);
        return b.build();
    }

    @Override
    public String toString() {
        return "WeaponRequirement{any=" + anyOfTags + ", all=" + allOfTags +
                ", none=" + noneOfTags + ", twoHanded=" + twoHandedOnly + "}";
    }
}
n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\WeaponRequirement.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltResult.java -----
package com.doomspire.grimcore.spell.autobolt;

public record AutoBoltResult(boolean ok, String reason, int cooldownTicks, float projectileSpeed) {
    public static AutoBoltResult ok(int cd, float speed) { return new AutoBoltResult(true, null, cd, speed); }
    public static AutoBoltResult denied(String why)       { return new AutoBoltResult(false, why, 0, 0.0f); }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltResult.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltService.java -----
package com.doomspire.grimcore.spell.autobolt;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.spell.autobolt.AutoBoltResult;
import com.doomspire.grimcore.spell.autobolt.AutoBoltTuning;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.item.ItemStack;

/**
 * Ядро авто-атаки посоха: валидация/баланс/списание ресурсов.
 * НИЧЕГО не спавним и не играем звуки — это задача grimfate.
 */
public final class AutoBoltService {

    public static AutoBoltResult computeAndConsume(ServerPlayer sp, ItemStack usedStaff) {
        // 1) Достаём статы игрока и их снапшот
        PlayerStatsAttachment stats = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (stats == null) return AutoBoltResult.denied("no_stats");

        StatSnapshot snap = stats.getSnapshot(); // кэшируемый снапшот из аттача

        // 2) Проверяем кулдаун именно на ЭТОТ предмет (пер-айтем)
        if (sp.getCooldowns().isOnCooldown(usedStaff.getItem())) {
            return AutoBoltResult.denied("cooldown");
        }

        // 3) Тюнинг авто-болта из datapack'а (mana cost / cd / projectile speed)
        AutoBoltTuning tuning = AutoBoltTuning.get();

        int manaCost = tuning.manaCost(snap, usedStaff);
        if (stats.getCurrentMana() < manaCost) {
            return AutoBoltResult.denied("not_enough_mana");
        }

        int cdTicks = tuning.cooldownTicks(snap, usedStaff);
        float projSpeed = tuning.projectileSpeed(snap, usedStaff);

        // 4) Списываем ману и синкаем
        stats.setCurrentMana(stats.getCurrentMana() - manaCost);
        stats.markDirty();
        GrimcoreNetworking.syncPlayerStats(sp, stats);

        // 5) Возвращаем параметры для контент-слоя
        return AutoBoltResult.ok(cdTicks, projSpeed);
    }

    private AutoBoltService() {}
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltService.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltTuning.java -----
package com.doomspire.grimcore.spell.autobolt;

import com.doomspire.grimcore.datapack.Balance;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;

//NOTE: Обёртка над data-тюнингом авто-болта.
/**
 * Все данные берутся из Balance/SpellTuning (datapack).
 *
 * ВАЖНО: поле projectile_speed читается «мягко»:
 *  - если SpellTuning.Entry уже поддерживает projectileSpeed() — используем его;
 *  - иначе пытаемся найти параметр "projectile_speed" в доп.полях (если таковые есть);
 *  - иначе берём безопасный дефолт (как у ванильной стрелы).
 *
 * Datapack-пример (data/grimfate/spells.json):
 * {
 *   "id": "grimfate:auto_bolt_staff",
 *   "baseCost": 3,
 *   "baseCooldown": 8,
 *   "projectile_speed": 1.6
 * }
 */
public final class AutoBoltTuning {

    /** ID записи авто-атаки посоха в spells.json */
    public static final ResourceLocation AUTO_BOLT_ID =
            ResourceLocation.fromNamespaceAndPath("grimfate", "auto_bolt_staff");

    /** Дефолт близок к ванильной стреле (+-). */
    private static final float DEFAULT_PROJECTILE_SPEED = 1.6f;

    /** Нижний «разумный» порог — чтобы болт не зависал в воздухе при багах данных. */
    private static final float MIN_PROJECTILE_SPEED = 0.4f;

    /** Верхний ограничитель на случай перебора в датапаке. */
    private static final float MAX_PROJECTILE_SPEED = 3.5f;

    public int manaCost(StatSnapshot snap, ItemStack staff) {
        SpellTuning.Entry e = Balance.getSpellEntry(AUTO_BOLT_ID);
        // Позже: модификаторы стоимости от статов/аффиксов.
        return (e != null) ? Math.max(0, e.baseCost()) : 0;
    }

    public int cooldownTicks(StatSnapshot snap, ItemStack staff) {
        SpellTuning.Entry e = Balance.getSpellEntry(AUTO_BOLT_ID);
        // Позже: учёт CDR/скорости атаки поверх baseCooldown.
        return (e != null) ? Math.max(0, e.baseCooldown()) : 0;
    }

    /**
     * Скорость снаряда (базовая). Баллистика (гравитация/drag) настраивается в сущности проектайла.
     * Здесь только базовый модуль скорости вылета.
     */
    public float projectileSpeed(StatSnapshot snap, ItemStack staff) {
        SpellTuning.Entry e = Balance.getSpellEntry(AUTO_BOLT_ID);

        float v = DEFAULT_PROJECTILE_SPEED;

        if (e != null) {
            // 1) Если в кодеке уже появилось строгое поле projectileSpeed()
            try {
                // Вызов через метод, если он существует (без жёсткой зависимости).
                var m = e.getClass().getMethod("projectileSpeed");
                Object ret = m.invoke(e);
                if (ret instanceof Number n) v = n.floatValue();
            } catch (NoSuchMethodException ignored) {
                // 2) Альтернатива: попытка вытащить из «экстра»-поля, если кодек хранит map/extra
                try {
                    var mExtra = e.getClass().getMethod("extra");
                    Object extra = mExtra.invoke(e); // ожидаем Map<String,Object> либо подобное
                    if (extra instanceof java.util.Map<?,?> map) {
                        Object val = map.get("projectile_speed");
                        if (val instanceof Number n) v = n.floatValue();
                        else if (val instanceof String s) v = Float.parseFloat(s);
                    }
                } catch (Throwable ignored2) {
                    // нет extra — ок
                }
            } catch (Throwable ignored) {
                // любые рефлексивные ошибки глушим — упадём на дефолт
            }
        }

        // Позже: модификаторы скорости от статов/аффиксов (ranged_speed, staff_mastery и т.п.)
        // v *= snap.getMul(Stats.PROJECTILE_SPEED); // пример

        if (Float.isNaN(v) || Float.isInfinite(v)) v = DEFAULT_PROJECTILE_SPEED;
        if (v < MIN_PROJECTILE_SPEED) v = MIN_PROJECTILE_SPEED;
        if (v > MAX_PROJECTILE_SPEED) v = MAX_PROJECTILE_SPEED;
        return v;
    }

    public static AutoBoltTuning get() { return new AutoBoltTuning(); }
    private AutoBoltTuning() {}
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\impl\AutoBoltSpell.java -----
package com.doomspire.grimcore.spell.autobolt.impl;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.spell.api.CastResult;
import com.doomspire.grimcore.spell.api.Spell;
import com.doomspire.grimcore.spell.api.SpellContext;
import com.doomspire.grimcore.spell.api.SpellSchool;
import com.doomspire.grimcore.spell.api.SpellTag;
import com.doomspire.grimcore.spell.api.WeaponGate;
import com.doomspire.grimcore.spell.api.WeaponRequirement;
import com.doomspire.grimcore.spell.autobolt.AutoBoltService;
import com.doomspire.grimcore.spell.autobolt.AutoBoltTuning;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;

import java.util.Collections;
import java.util.Set;

/**
 * Ядровой спелл авто-болта для посохов:
 * - требования к оружию: только #grimfate:staves;
 * - расход/кулдаун берутся из AutoBoltTuning;
 * - при cast выполняется только проверка + списание ресурсов через AutoBoltService;
 *   сам спавн снаряда делается на стороне grimfate.
 */
public final class AutoBoltSpell implements Spell {

    private static final ResourceLocation ID =
            ResourceLocation.fromNamespaceAndPath("grimfate", "auto_bolt_staff");

    private static final WeaponRequirement REQ_STAFF = WeaponRequirement.stavesOnly();
    private static final AutoBoltTuning TUNING = AutoBoltTuning.get();

    @Override
    public ResourceLocation id() {
        return ID;
    }

    @Override
    public SpellSchool school() {
        // Подбираем подходящую школу (можно завести отдельную SCHOOL:ARCANE или "STAFF").
        return SpellSchool.ARCANE;
    }

    @Override
    public Set<SpellTag> tags() {
        // Теги для фильтров/баланса — пока пусто, можно добавить LMB_SPELL / BASIC_ATTACK и т.п.
        return Collections.emptySet();
    }

    @Override
    public int manaCost(SpellContext ctx) {
        Player p = asPlayer(ctx.caster);
        if (p == null) return 0;

        ItemStack staff = findStaffInHands(p);
        StatSnapshot snap = PlayerStatsAttachment.get(p).getSnapshot();
        return TUNING.manaCost(snap, staff);
    }

    @Override
    public int cooldownTicks(SpellContext ctx) {
        Player p = asPlayer(ctx.caster);
        if (p == null) return 0;

        ItemStack staff = findStaffInHands(p);
        StatSnapshot snap = PlayerStatsAttachment.get(p).getSnapshot();
        return TUNING.cooldownTicks(snap, staff);
    }

    @Override
    public CastResult cast(SpellContext ctx) {
        if (!(ctx.caster instanceof ServerPlayer sp)) {
            return CastResult.FAIL;
        }

        WeaponGate.Result gate = WeaponGate.check(sp, REQ_STAFF);
        if (!gate.ok) return CastResult.FAIL;

        ItemStack staff = sp.getItemInHand(
                gate.usedHand != null ? gate.usedHand : InteractionHand.MAIN_HAND);

        var res = AutoBoltService.computeAndConsume(sp, staff);
        return res.ok() ? CastResult.OK : CastResult.FAIL;
    }

    // ---------- helpers ----------

    private static Player asPlayer(LivingEntity e) {
        return (e instanceof Player pl) ? pl : null;
    }

    private static ItemStack findStaffInHands(Player p) {
        ItemStack main = p.getMainHandItem();
        if (!main.isEmpty() && isStaff(main)) return main;
        ItemStack off = p.getOffhandItem();
        if (!off.isEmpty() && isStaff(off)) return off;
        return ItemStack.EMPTY;
    }

    private static boolean isStaff(ItemStack stack) {
        // Заглушка, заменим на тег #grimfate:staves
        return true;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\impl\AutoBoltSpell.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java -----
package com.doomspire.grimcore.spell;

import com.doomspire.grimcore.spell.api.Spell;
import net.minecraft.resources.ResourceLocation;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Простой реестр спеллов в рантайме.
 * Регистрация выполняется на общих инициализациях мода или при загрузке datapack-тюнинга (в т.ч. референс-спеллы).
 */
public final class GrimSpells {
    private GrimSpells() {}

    private static final Map<ResourceLocation, Spell> REGISTRY = new LinkedHashMap<>();

    public static void register(Spell spell) {
        REGISTRY.put(spell.id(), spell);
    }

    public static Spell get(ResourceLocation id) {
        return REGISTRY.get(id);
    }

    public static Map<ResourceLocation, Spell> all() {
        return Collections.unmodifiableMap(REGISTRY);
    }

    public static void clear() {
        REGISTRY.clear();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java -----
package com.doomspire.grimcore.stat;

/**
 * Базовые атрибуты, которые игрок получает и распределяет при повышении уровня.
 */
public enum Attributes {
    VITALITY,      // здоровье, реген, бонус к блоку
    STRENGTH,      // физический урон ближнего боя
    INTELLIGENCE,  // урон заклинаний и стихий
    SPIRIT,        // мана, реген маны
    DEXTERITY,     // физический урон дальнего боя
    EVASION,       // шанс уворота
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java -----
package com.doomspire.grimcore.stat;

/**
 * Типы урона. Используются в DamageContext и StatSnapshot.
 */
public enum DamageTypes {
    PHYS_MELEE,
    PHYS_RANGED,
    FIRE,
    FROST,
    LIGHTNING,
    POISON
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.*;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.NeoForgeRegistries;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.attachment.AttachmentType;

public final class ModAttachments {
    private ModAttachments() {}

    public static final DeferredRegister<AttachmentType<?>> ATTACHMENT_TYPES =
            DeferredRegister.create(NeoForgeRegistries.ATTACHMENT_TYPES, Grimcore.MODID);

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerStatsAttachment>> PLAYER_STATS =
            ATTACHMENT_TYPES.register("player_stats",
                    () -> AttachmentType.builder(PlayerStatsAttachment::new)
                            // персист сохранять позже, когда добавим Codec:
                            // .serialize(YourCodecHere)
                            .sync(PlayerStatsAttachment.STREAM_CODEC) // сеть ОК
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<MobStatsAttachment>> MOB_STATS =
            ATTACHMENT_TYPES.register("mob_stats",
                    () -> AttachmentType.builder(MobStatsAttachment::new)
                            .sync(MobStatsAttachment.STREAM_CODEC) // можно выключить, если на клиенте не нужно
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerProgressAttachment>> PLAYER_PROGRESS =
            ATTACHMENT_TYPES.register("player_progress", () ->
                    AttachmentType.builder(PlayerProgressAttachment::new)
                            .serialize(PlayerProgressAttachment.CODEC)        // автосейв в сейв игрока
                            .sync(PlayerProgressAttachment.STREAM_CODEC)      // авто-синк при замене
                            .build()
            );

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerLoadoutAttachment>> PLAYER_LOADOUT =
            ATTACHMENT_TYPES.register("player_loadout",
                    () -> AttachmentType.builder(PlayerLoadoutAttachment::new)
                            .serialize(PlayerLoadoutAttachment.CODEC)      // хот-бар сохраняется
                            .sync(PlayerLoadoutAttachment.STREAM_CODEC)     // ВАЖНО: клиент видит изменения
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<MobThreatAttachment>> MOB_THREAT =
            ATTACHMENT_TYPES.register("mob_threat",
                    () -> AttachmentType.builder(MobThreatAttachment::new)
                            .sync(MobThreatAttachment.STREAM_CODEC) // сеть
                            //.serialize(MobThreatAttachment.CODEC) // добавим позже, если нужно сохранять в сейв
                            .build());


}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java -----
package com.doomspire.grimcore.stat;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

/**
 * Чистые данные об уровне игрока.
 * Только хранение + сериализация в NBT/сеть.
 */
public record PlayerProgress(int level, int exp, int expCap) {

    public static final Codec<PlayerProgress> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.INT.fieldOf("level").forGetter(PlayerProgress::level),
            Codec.INT.fieldOf("exp").forGetter(PlayerProgress::exp),
            Codec.INT.fieldOf("exp_cap").forGetter(PlayerProgress::expCap)
    ).apply(instance, PlayerProgress::new));

    public static final StreamCodec<FriendlyByteBuf, PlayerProgress> STREAM_CODEC = StreamCodec.composite(
            ByteBufCodecs.INT, PlayerProgress::level,
            ByteBufCodecs.INT, PlayerProgress::exp,
            ByteBufCodecs.INT, PlayerProgress::expCap,
            PlayerProgress::new
    );

    public static final PlayerProgress DEFAULT = new PlayerProgress(1, 0, 100);

    /**
     * Вспомогательный метод для проверки прогресса на клиенте (HUD).
     */
    public String hudString() {
        return "Lvl " + level + " (" + exp + "/" + expCap + ")";
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java -----
package com.doomspire.grimcore.stat;

/**
 * Сопротивления урону. Применяются в DamageEngine.
 */
public enum ResistTypes {
    PHYS,
    FIRE,
    FROST,
    LIGHTNING,
    POISON
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.affix.AffixAggregator;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import net.minecraft.world.entity.LivingEntity;


//NOTE:Пересчитывает агрегированные статы (StatSnapshot) на основе атрибутов, предметов и бонусов.
//NOTE:Вызов: при изменении атрибутов/уровня/экипировки/эффектов.

public class StatCalculator {

    public static StatSnapshot calculate(PlayerStatsAttachment att) {
        StatSnapshot snapshot = new StatSnapshot();

        // Атрибуты
        int vit = att.getAttribute(Attributes.VITALITY);
        int str = att.getAttribute(Attributes.STRENGTH);
        int intl = att.getAttribute(Attributes.INTELLIGENCE);
        int spirit = att.getAttribute(Attributes.SPIRIT);
        int dex = att.getAttribute(Attributes.DEXTERITY);
        int eva = att.getAttribute(Attributes.EVASION);

        // Примеры формул (значения можно вынести в JSON balance/attributes.json)
        snapshot.maxHealth   = 100 + vit * 20;
        snapshot.regenHealth = 1 + vit * 1;

        snapshot.maxMana   = 100 + spirit * 30;
        snapshot.regenMana = 1 + spirit * 3;

        snapshot.damage.put(DamageTypes.PHYS_MELEE,  str * 0.03f);
        snapshot.damage.put(DamageTypes.PHYS_RANGED, dex * 0.03f);
        snapshot.damage.put(DamageTypes.FIRE,        intl * 0.02f);
        snapshot.damage.put(DamageTypes.FROST,       intl * 0.02f);
        snapshot.damage.put(DamageTypes.LIGHTNING,   intl * 0.02f);
        snapshot.damage.put(DamageTypes.POISON,      intl * 0.02f);

        snapshot.critChance     = 0f;       // 1% за очко — добавим позже при балансировке
        snapshot.critDamage     = 0.5f;     // +50% базово
        snapshot.lifesteal      = 0f;
        snapshot.manasteal      = 0f;
        snapshot.evasionChance  = eva * 0.01f;
        snapshot.moveSpeedPct   = dex * 0.25D; // 0.25% за 1 DEX

        // Глобальная редукция входящего урона.
        // Пока = 0, позже сюда добавим:
        //  - AffixAggregator (из экипировки/бижутерии/аур),
        //  - классовые/баф-эффекты,
        //  - возможные бонусы от атрибутов/скилл-дерева.
        snapshot.damageReductionAll = 0f;

        // Клампы безопасных диапазонов (если потребуется)
        snapshot.evasionChance = clamp01(snapshot.evasionChance);
        snapshot.damageReductionAll = clamp01(snapshot.damageReductionAll);

        return snapshot;
    }
    /**
     * Полный расчёт со всеми модификаторами предметов/аффиксов.
     * ВНИМАНИЕ: owner может быть null — тогда вернётся чистая версия без аффиксов.
     */
    public static StatSnapshot calculateWithAffixes(PlayerStatsAttachment att, LivingEntity owner) {
        StatSnapshot snap = calculate(att);
        if (owner != null) {
            AffixAggregator.applyAll(snap, owner);
        }
        return snap;
    }
    private static float clamp01(float v) {
        if (Float.isNaN(v) || Float.isInfinite(v)) return 0f;
        return Math.max(0f, Math.min(1f, v));
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;

/**
 * Применяет эффекты из статов к ванильным атрибутам игрока.
 * ЕДИНАЯ точка – тут же и снимаем/обновляем модификаторы.
 */
public final class StatEffects {
    private StatEffects() {}

    // Идентификаторы наших модификаторов (ResourceLocation в 1.21.1)
    public static final ResourceLocation MOVE_SPEED_ID =
            ResourceLocation.fromNamespaceAndPath("grimcore", "dex_move_speed");

    /**
     * Применяет все эффекты заново на основе текущего снапшота статов.
     * Вызывать после любого изменения статов/экипировки и при логине/респауне.
     */
    public static void applyAll(ServerPlayer sp) {
        PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (att == null) return;

        var snap = att.getSnapshot();

        // 1) Ловкость → скорость передвижения: +0.25% за 1 DEX
        applyMoveSpeed(sp, snap.moveSpeedPct);
        // 2) здесь же позже: сила → урон ближнего, интеллект → сила магии и т.п.
    }

    private static void applyMoveSpeed(ServerPlayer sp, double percent) {
        AttributeInstance inst = sp.getAttribute(Attributes.MOVEMENT_SPEED);
        if (inst == null) return;

        // снимаем старый наш модификатор
        inst.removeModifier(MOVE_SPEED_ID);

        // +X% к ИТОГОВОЙ скорости → ADD_MULTIPLIED_TOTAL с долей (0.075 для +7.5%)
        double addTotal = percent / 100.0;
        if (addTotal == 0.0) return;

        AttributeModifier mod = new AttributeModifier(
                MOVE_SPEED_ID,
                addTotal,
                AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL
        );
        inst.addPermanentModifier(mod);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java -----
package com.doomspire.grimcore.stat;

import java.util.EnumMap;
//NOTE: Кэшированное состояние всех характеристик игрока/моба
/**
 * Используется в боевом движке и GUI.
 */
public class StatSnapshot {
    // Ресурсы
    public float maxHealth;
    public float regenHealth;
    public float maxMana;
    public float regenMana;

    // Урон
    public EnumMap<DamageTypes, Float> damage = new EnumMap<>(DamageTypes.class);

    // Резисты
    public EnumMap<ResistTypes, Float> resistances = new EnumMap<>(ResistTypes.class);

    // Боевые модификаторы
    public float critChance;
    public float critDamage;
    public float lifesteal;
    public float manasteal;
    public float evasionChance;
    public double moveSpeedPct; // бонус к скорости в процентах (например 7.5 = +7.5%)

    /**
     * Глобальная редукция входящего урона (после резистов), 0..1.
     * Пример: 0.20f = -20% ко всему входящему урону.
     * Рассчитывается в StatCalculator из аффиксов/бафов/источников защиты.
     */
    public float damageReductionAll;

    public StatSnapshot() {
        for (DamageTypes type : DamageTypes.values()) {
            damage.put(type, 0f);
        }
        for (ResistTypes type : ResistTypes.values()) {
            resistances.put(type, 0f);
        }
        damageReductionAll = 0f;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java -----
package com.doomspire.grimcore.xp;

import com.doomspire.grimcore.datapack.BalanceData;

public final class LevelTable {
    private static final int MAX_LEVEL = 50; // временно, вынесем в конфиг
    private static final int BASE = 100;
    private static final double GROWTH = 1.10; // +10% к требованию на уровень

    private LevelTable() {}

    /** Сколько XP нужно, чтобы перейти с level → level+1 */
    public static int expForLevel(int level) {
        if (level <= 0) return BASE;
        return (int) Math.round(BASE * Math.pow(GROWTH, level - 1));
    }

    /** Сколько XP нужно всего, чтобы достичь этого уровня */
    public static int capForLevel(int level) {
        int sum = 0;
        for (int i = 1; i <= level; i++) {
            sum += expForLevel(i);
        }
        return sum;
    }

    public static int maxLevel() {
        return Math.max(1, BalanceData.levels().maxLevel());
    }

    /** Сколько XP нужно, чтобы достичь уровня L (с начала прогрессии). */
    public static long totalXpForLevel(int level) {
        var lv = BalanceData.levels();
        int L = Math.max(1, Math.min(level, lv.maxLevel()));
        double base = lv.base();
        double growth = lv.growth();
        // Геометрическая прогрессия: base * growth^(L-1) суммой от 1..L-1
        double sum = 0.0;
        double term = base;
        for (int i = 1; i < L; i++) {
            sum += term;
            term *= growth;
        }
        return Math.round(sum);
    }

    /** Сколько XP нужно от L до L+1 (инкрементальный шаг). */
    public static int xpForNextLevel(int level) {
        var lv = BalanceData.levels();
        int L = Math.max(1, Math.min(level, lv.maxLevel()));
        return (int)Math.round(lv.base() * Math.pow(lv.growth(), Math.max(0, L-1)));
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java -----
package com.doomspire.grimcore.xp;

public class Rewards {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java -----n
----- BEGIN FILE: .\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json -----
{
  "attributes": {
    "vitality": 3,
    "strength": 2,
    "dexterity": 0,
    "intelligence": 0,
    "evasion": 0
  },
  "resistances": {
    "phys": 0.10,
    "fire": 0.00,
    "frost": 0.00,
    "lightning": 0.00,
    "poison": 0.00
  },
  "damage": {
    "phys_melee": 25.0
  }
}

n----- END FILE: .\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\affix\GrimfateAffixExtraction.java -----
package com.doomspire.grimfate.affix;

import com.doomspire.grimcore.affix.Affix;
import com.doomspire.grimcore.affix.AffixAggregator;
import com.doomspire.grimfate.compat.curios.CuriosCompat;
import com.doomspire.grimfate.registry.ModDataComponents;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ItemStack;

import java.util.List;

//NOTE: Сторона контента: собираем аффиксы со всех источников сущности.
/**
 * Источники:
 *  - main hand / offhand (WEAPON/SHIELD),
 *  - броня по слотам (ARMOR),
 *  - Curios (JEWELRY), если мод загружен,
 *  - временные бафы/ауры (позже).
 */
public final class GrimfateAffixExtraction {
    private GrimfateAffixExtraction() {}

    public static List<AffixAggregator.AffixEntry> extractFromEntity(LivingEntity entity) {
        var b = new AffixAggregator.ListBuilder();

        // 1) Оружие/щит
        appendFromStack(entity.getMainHandItem(), b, Affix.Source.WEAPON);
        appendFromStack(entity.getOffhandItem(), b, guessOffhandSource(entity.getOffhandItem()));

        // 2) Броня
        for (ItemStack armor : entity.getArmorSlots()) {
            appendFromStack(armor, b, Affix.Source.ARMOR);
        }

        // 3) Curios (бижутерия), если мод загружен
        if (CuriosCompat.isLoaded()) {
            // как только появится реальный обход — раскомментировать и использовать
            // CuriosCompat.forEachEquipped(entity, (stack, slotId) -> {
            //     appendFromStack(stack, b, Affix.Source.JEWELRY);
            // });
        }

        // 4) Бафы/ауры — TODO позже

        return b.build();
    }

    private static Affix.Source guessOffhandSource(ItemStack offhand) {
        // Пока считаем оффхенд щитом, если предмет помечен тегом grimfate:shields — добавим позже.
        // До ввода тегов возвращаем SHIELD как безопасную эвристику.
        return Affix.Source.SHIELD;
    }

    private static void appendFromStack(ItemStack stack, AffixAggregator.ListBuilder b, Affix.Source src) {
        if (stack == null || stack.isEmpty()) return;
        readFromStack(stack, src, b);
    }

    /**
     * Чтение аффиксов из data-component'а {@link com.doomspire.grimfate.item.comp.AffixListComponent}.
     * Суммируем все роллы аффикса в единую величину (magnitude) и добавляем запись для агрегатора.
     *
     * Формат компонента:
     *   entries: [{ id: "namespace:affix_id", rolls: [ ...floats... ] }, ...]
     */
    private static void readFromStack(ItemStack stack, Affix.Source src, AffixAggregator.ListBuilder b) {
        var comp = stack.get(ModDataComponents.AFFIX_LIST.get());
        if (comp == null) return;

        for (var e : comp.entries()) {
            if (e == null) continue;

            // Парсим ID
            ResourceLocation id = ResourceLocation.tryParse(e.id());
            if (id == null) continue; // некорректный id — пропускаем

            // Сводим список роллов к одной величине (по умолчанию — сумма)
            float mag = 0f;
            var rolls = e.rolls();
            if (rolls != null) {
                for (Float r : rolls) {
                    if (r != null && !Float.isNaN(r) && !Float.isInfinite(r)) {
                        mag += r;
                    }
                }
            }

            // Пропускаем «пустые» величины
            if (mag == 0f) continue;

            b.add(id, mag, src);
        }
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\affix\GrimfateAffixExtraction.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\BowModelProperties.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimfate.item.weapons.Weapons;
import net.minecraft.client.multiplayer.ClientLevel;
import net.minecraft.client.renderer.item.ItemProperties;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ItemStack;

public final class BowModelProperties {
    private BowModelProperties() {}

    public static void register() {
        // Зарегистрируй для всех своих луков:
        registerBow(Weapons.WEAKLING_BOW.get());
        // Когда появятся другие луки — добавь сюда registerBow(...)
    }

    private static void registerBow(net.minecraft.world.item.Item item) {
        // "pull" — 0..1, насколько натянута тетива
        ItemProperties.register(item, ResourceLocation.withDefaultNamespace("pull"),
                (ItemStack stack, ClientLevel level, LivingEntity entity, int seed) -> {
                    if (entity == null) return 0.0F;
                    if (entity.getUseItem() != stack) return 0.0F;
                    // стабильная формула: сколько тиков тянем / 20.0F
                    int used = entity.getTicksUsingItem();
                    return Math.min(1.0F, used / 20.0F);
                });


        // "pulling" — 1.0 когда игрок тянет тетиву
        ItemProperties.register(item, ResourceLocation.withDefaultNamespace("pulling"),
                (ItemStack stack, ClientLevel level, LivingEntity entity, int seed) ->
                        (entity != null && entity.isUsingItem() && entity.getUseItem() == stack) ? 1.0F : 0.0F);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\BowModelProperties.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimfate.config.ClientConfig;
import com.doomspire.grimfate.core.Grimfate;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.client.event.RenderGuiEvent;
import net.neoforged.neoforge.client.event.RenderGuiLayerEvent;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.CLIENT)
public final class CustomHudOverlay {
    private CustomHudOverlay() {}

    // ---- текстуры ----
    private static final ResourceLocation HEALTH_BAR_EMPTY =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_bg.png");
    private static final ResourceLocation HEALTH_BAR_FULL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_fill.png");

    private static final ResourceLocation MANA_BAR_EMPTY =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_bg.png");
    private static final ResourceLocation MANA_BAR_FULL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/mana_bar_fill.png");

    private static final ResourceLocation XP_BG =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/xp_background.png");
    private static final ResourceLocation XP_FILL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/xp_fill.png");

    private static final ResourceLocation SPELL_CELL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/spellbar/spell_bar_cell.png");

    // ---- плавные значения ----
    private static final Map<UUID, Float> DISPLAYED_HEALTH = new ConcurrentHashMap<>();
    private static final Map<UUID, Float> DISPLAYED_MANA   = new ConcurrentHashMap<>();
    private static final Map<UUID, Float> DISPLAYED_XP     = new ConcurrentHashMap<>();
    private static final float LERP_ALPHA = 0.20f;

    // ---- хот-бар ----
    private static final int SPELL_CELL_W = 20;
    private static final int SPELL_CELL_H = 20;
    private static final int SPELL_CELL_PAD = 2;

    // ---- какие ванильные слои гасим ----
    private static final Set<ResourceLocation> VANILLA_LAYERS_TO_HIDE = Set.of(
            ResourceLocation.fromNamespaceAndPath("minecraft", "player_health"),
            ResourceLocation.fromNamespaceAndPath("minecraft", "armor_level")
    );

    /** Гасим ванильные слои, чтобы рисовать свои HP/броню/ману/XP. */
    @SubscribeEvent
    public static void onRenderGuiLayerPre(RenderGuiLayerEvent.Pre event) {
        if (VANILLA_LAYERS_TO_HIDE.contains(event.getName())) {
            event.setCanceled(true);
        }
    }

    /** Рисуем наш общий HUD и хот-бар. */
    @SubscribeEvent
    public static void onRenderGui(RenderGuiEvent.Post event) {
        Minecraft mc = Minecraft.getInstance();
        if (mc.player == null || mc.screen != null) return;

        var player = mc.player;

        // --- статы ---
        PlayerStatsAttachment statsAtt = player.getData(ModAttachments.PLAYER_STATS.get());
        if (statsAtt == null) return;

        var snap = statsAtt.getSnapshot();
        int health    = statsAtt.getCurrentHealth();
        int maxHealth = Math.max(1, (int) snap.maxHealth);
        int mana      = statsAtt.getCurrentMana();
        int maxMana   = Math.max(1, (int) snap.maxMana);

        // --- прогресс ---
        PlayerProgressAttachment progressAtt = player.getData(ModAttachments.PLAYER_PROGRESS.get());
        PlayerProgress progress = (progressAtt != null) ? progressAtt.toSnapshot() : PlayerProgress.DEFAULT;

        GuiGraphics gui = event.getGuiGraphics();
        int sw = mc.getWindow().getGuiScaledWidth();
        int sh = mc.getWindow().getGuiScaledHeight();
        UUID uuid = player.getUUID();

        // наши бары
        renderHealthBar(gui, mc, sw, sh, uuid, health, maxHealth);
        renderManaBar(gui, mc, sw, sh, uuid, mana, maxMana);
        renderXpIcon(gui, mc, sw, sh, uuid, progress);

        // хот-бар спеллов
        renderSpellHotbar(gui, mc, sw, sh);
    }

    // -------------------- отрисовка --------------------

    private static void renderHealthBar(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                        UUID uuid, int health, int maxHealth) {
        final int W = 120, H = 12;

        float disp = DISPLAYED_HEALTH.getOrDefault(uuid, (float) health);
        disp += (health - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, maxHealth));
        DISPLAYED_HEALTH.put(uuid, disp);

        int x = sw / 2 + ClientConfig.HEALTH_BAR_X.get();
        int y = sh + ClientConfig.HEALTH_BAR_Y.get();

        gui.blit(HEALTH_BAR_EMPTY, x, y, 0, 0, W, H, W, H);
        int filled = (int) (W * (disp / Math.max(1f, maxHealth)));
        if (filled > 0) gui.blit(HEALTH_BAR_FULL, x, y, 0, 0, filled, H, W, H);

        String text = health + "/" + maxHealth;
        gui.drawString(mc.font, Component.literal(text),
                x + W / 2 - mc.font.width(text) / 2,
                y + (H - mc.font.lineHeight) / 2,
                0xFFFFFF, true);
    }

    private static void renderManaBar(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                      UUID uuid, int mana, int maxMana) {
        final int W = 120, H = 12;

        float disp = DISPLAYED_MANA.getOrDefault(uuid, (float) mana);
        disp += (mana - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, maxMana));
        DISPLAYED_MANA.put(uuid, disp);

        int x = sw / 2 + ClientConfig.MANA_BAR_X.get();
        int y = sh + ClientConfig.MANA_BAR_Y.get();

        gui.blit(MANA_BAR_EMPTY, x, y, 0, 0, W, H, W, H);
        int filled = (int) (W * (disp / Math.max(1f, maxMana)));
        if (filled > 0) gui.blit(MANA_BAR_FULL, x, y, 0, 0, filled, H, W, H);

        String text = mana + "/" + maxMana;
        gui.drawString(mc.font, Component.literal(text),
                x + W / 2 - mc.font.width(text) / 2,
                y + (H - mc.font.lineHeight) / 2,
                0xFFFFFF, true);
    }

    private static void renderXpIcon(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                     UUID uuid, PlayerProgress progress) {
        final int W = 32, H = 32;

        int exp = progress.exp();
        int cap = Math.max(1, progress.expCap());

        float disp = DISPLAYED_XP.getOrDefault(uuid, (float) exp);
        disp += (exp - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, cap));
        DISPLAYED_XP.put(uuid, disp);

        int x = sw / 2 + ClientConfig.XP_ICON_X.get();
        int y = sh + ClientConfig.XP_ICON_Y.get();

        gui.blit(XP_BG, x, y, 0, 0, W, H, W, H);

        int filledH = (int) (H * (disp / (float) cap));
        if (filledH > 0) {
            gui.blit(XP_FILL, x, y + (H - filledH), 0, H - filledH, W, filledH, W, H);
        }

        String lvl = String.valueOf(progress.level());
        gui.drawString(mc.font, Component.literal(lvl),
                x + W / 2 - mc.font.width(lvl) / 2,
                y + H / 2 - mc.font.lineHeight / 2,
                0xFFFFFF, true);

        String expTxt = exp + "/" + cap;
        gui.drawString(mc.font, Component.literal(expTxt),
                x + W / 2 - mc.font.width(expTxt) / 2,
                y + H + 2,
                0xFFFFFF, false);
    }

    private static void renderSpellHotbar(GuiGraphics gg, Minecraft mc, int sw, int sh) {
        var p = mc.player;
        var loadout = p.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (loadout == null) return;

        final int CELLS = PlayerLoadoutAttachment.SLOTS; // 6
        final int CELL = 20; // 20x20, без отступов

        // 1) ширина полосы
        int totalW = CELLS * CELL;

        // 2) дефолт по X: центр экрана; по Y: ровно между прицелом (sh/2) и ванильным хотбаром (~sh - 22)
        int vanillaHotbarY = sh - 22;
        int midY = (sh / 2 + vanillaHotbarY) / 2;

        int x0 = (sw - totalW) / 2 + ClientConfig.SPELLBAR_X.get();
        int y0 = midY + ClientConfig.SPELLBAR_Y.get();

        // 3) рисуем все 6 ячеек
        for (int i = 0; i < CELLS; i++) {
            int x = x0 + i * CELL;
            int y = y0;

            // фон ячейки (твоя текстура 20x20)
            gg.blit(SPELL_CELL, x, y, 0, 0, CELL, CELL, CELL, CELL);

            var rl = loadout.get(i);

            // если слот пуст — ничего не пишем (ни хоткей, ни кд)
            if (rl == null) continue;

            // кулдаун
            int cd = loadout.getCooldown(i);
            if (cd > 0) {
                // тёмная маска поверх (оставим как заливку; если захочешь — заменим на текстуру маски)
                gg.fill(x + 1, y + 1, x + CELL - 1, y + CELL - 1, 0x80000000);
                String s = String.valueOf(cd / 20);
                gg.drawString(mc.font, s, x + (CELL - mc.font.width(s)) / 2, y + 5, 0xFFFFFFFF, false);
            }

            // хоткей (буква/цифра) — только если слот не пуст
            String hk = Hotkeys.spellKeyName(i);
            // рисуем в правом нижнем углу, вписываемся в ~8x9px
            int hkX = x + CELL - mc.font.width(hk) - 2;
            int hkY = y + CELL - 9;
            gg.drawString(mc.font, hk, hkX, hkY, 0xFFE6DDAA, false);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java -----
package com.doomspire.grimfate.client.gui;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.AbstractButton;
import net.minecraft.client.gui.components.Tooltip;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.client.event.ScreenEvent;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.CLIENT)
public final class InventoryTabsButtons {
    private InventoryTabsButtons() {}

    private static final ResourceLocation TAB_TEX =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/button_tab.png");
    private static final ResourceLocation ICON_STATS =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/icon_stats.png");
    private static final ResourceLocation ICON_SKILLS =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/icon_skills.png");

    // Держим ссылки для лайв-репозиционирования
    private static SpriteTabButton STATS_BTN;
    private static SpriteTabButton SKILLS_BTN;

    @SubscribeEvent
    public static void onInit(ScreenEvent.Init.Post e) {
        Screen screen = e.getScreen();
        if (!(screen instanceof InventoryScreen inv)) return;

        int left = inv.getGuiLeft();
        int top  = inv.getGuiTop();
        int w    = inv.getXSize();

        int xStats  = left + w + 2;
        int yStats  = top;
        int xSkills = xStats;
        int ySkills = yStats + 22;

        STATS_BTN = new SpriteTabButton(
                xStats, yStats,
                TAB_TEX, 20, 20, 60,
                ICON_STATS, 16, 48, 3, // 3 кадра у icon_stats
                () -> Minecraft.getInstance().setScreen(new InventoryWithStatsScreen(Minecraft.getInstance().player)));
        STATS_BTN.setTooltip(Tooltip.create(Component.translatable("grimfate.ui.stats.open")));

        SKILLS_BTN = new SpriteTabButton(
                xSkills, ySkills,
                TAB_TEX, 20, 20, 60,
                ICON_SKILLS, 16, 80, 5, // 5 кадров у icon_skills
                () -> {
                    var p = Minecraft.getInstance().player;
                    if (p != null) p.displayClientMessage(Component.literal("Древо не нарисовано, но открылось бы и все работает"), true);
                });

        SKILLS_BTN.setTooltip(Tooltip.create(Component.literal("Дерево навыков (WIP)")));

        e.addListener(STATS_BTN);
        e.addListener(SKILLS_BTN);
    }

    // Двигаем кнопки каждый кадр — они «клеятся» к инвентарю и при книге рецептов
    @SubscribeEvent
    public static void onRender(ScreenEvent.Render.Post e) {
        Screen screen = e.getScreen();
        if (!(screen instanceof InventoryScreen inv)) return;
        int left = inv.getGuiLeft();
        int top  = inv.getGuiTop();
        int w    = inv.getXSize();

        if (STATS_BTN != null) {
            STATS_BTN.setX(left + w + 2);
            STATS_BTN.setY(top);
        }
        if (SKILLS_BTN != null) {
            SKILLS_BTN.setX(left + w + 2);
            SKILLS_BTN.setY(top + 22);
        }
    }

    /** Кнопка-«таб»: фон 3 состояния, иконка — анимированный спрайт по времени. */
    static final class SpriteTabButton extends AbstractButton {
        private final ResourceLocation tabTex;
        private final int tabFrameW, tabFrameH, tabTexH;

        private final ResourceLocation iconTex;
        private final int iconFrame;   // размер кадра иконки (обычно 16)
        private final int iconTexH;    // высота текстуры иконки (для blit)
        private final int iconFrames;  // сколько кадров у иконки

        private boolean pressedVisual = false;
        private final Runnable onPress;

        SpriteTabButton(
                int x, int y,
                ResourceLocation tabTex, int tabFrameW, int tabFrameH, int tabTexH,
                ResourceLocation iconTex, int iconFrame, int iconTexH, int iconFrames,
                Runnable onPress
        ) {
            super(x, y, tabFrameW, tabFrameH, Component.empty());
            this.tabTex = tabTex;
            this.tabFrameW = tabFrameW;
            this.tabFrameH = tabFrameH;
            this.tabTexH = tabTexH;

            this.iconTex = iconTex;
            this.iconFrame = iconFrame;
            this.iconTexH = iconTexH;
            this.iconFrames = Math.max(1, iconFrames);

            this.onPress = onPress;
        }

        @Override
        protected void renderWidget(GuiGraphics g, int mouseX, int mouseY, float partialTick) {
            // Фон — по состоянию
            int state = this.isHovered() ? 1 : 0;
            if (pressedVisual) state = 2; // 0/1/2 = normal/hover/pressed
            int vTab = state * tabFrameH;
            g.blit(tabTex, getX(), getY(), 0, vTab, tabFrameW, tabFrameH, tabFrameW, tabTexH);

            // Иконка — анимируем по времени, независимо от состояния
            long ms = System.currentTimeMillis();
            int anim = (int)((ms / 200L) % iconFrames); // ~5 FPS
            int vIcon = anim * iconFrame;

            int ix = getX() + (tabFrameW - 16) / 2;
            int iy = getY() + (tabFrameH - 16) / 2;
            g.blit(iconTex, ix, iy, 0, vIcon, 16, 16, 16, iconTexH);
        }

        @Override
        public void onPress() {
            if (onPress != null) onPress.run();
        }

        @Override
        public boolean mouseClicked(double mx, double my, int button) {
            if (this.isMouseOver(mx, my)) pressedVisual = true;
            return super.mouseClicked(mx, my, button);
        }

        @Override
        public boolean mouseReleased(double mx, double my, int button) {
            pressedVisual = false;
            return super.mouseReleased(mx, my, button);
        }

        @Override
        protected void updateWidgetNarration(NarrationElementOutput narration) {
            this.defaultButtonNarrationText(narration);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java -----
package com.doomspire.grimfate.client.gui;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.network.ModNetworking;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Player;

import java.util.ArrayList;
import java.util.List;

public class InventoryWithStatsScreen extends InventoryScreen {

    // === Твой фон панели 160×224 ===
    private static final int PANEL_W = 160;
    private static final int PANEL_H = 224;
    // Насколько уезжает инвентарь влево, чтобы справа поместилась панель
    private static final int INV_SHIFT = 120;

    private static final ResourceLocation PANEL_BG =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/stats_panel_bg.png");

    // Иконки характеристик-атласа (подключатся, когда положишь PNG)
    private static final ResourceLocation ICONS_TEX =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/stats_icons.png");

    // Панель прижата к правому краю инвентаря
    private int panelX, panelY;

    // Прямоугольные кликабельные зоны «+»
    private final List<AttrBtn> attrButtons = new ArrayList<>();

    public InventoryWithStatsScreen(Player player) {
        super(player);
    }

    @Override
    protected void init() {
        super.init();

        // Сдвигаем инвентарь влево, чтобы справа было место под панель
        this.leftPos -= INV_SHIFT;

        // Инициализируем прямоугольники «+» по макету (координаты внутри панели)
        attrButtons.clear();
        // СТК
        attrButtons.add(makeAttrBtn(Attributes.VITALITY,     34, 22, 54, 22));
        // СИЛ
        attrButtons.add(makeAttrBtn(Attributes.STRENGTH,     34, 35, 54, 35));
        // ДУХ (SPIRIT)
        attrButtons.add(makeAttrBtn(Attributes.SPIRIT,       69, 22, 89, 22));
        // ИНТ
        attrButtons.add(makeAttrBtn(Attributes.INTELLIGENCE, 69, 35, 89, 35));
        // ЛВК
        attrButtons.add(makeAttrBtn(Attributes.DEXTERITY,   105, 22,125, 22));
        // УКЛ
        attrButtons.add(makeAttrBtn(Attributes.EVASION,     105, 35,125, 35));
    }

    private AttrBtn makeAttrBtn(Attributes id, int labelX, int labelY, int valueX, int valueY) {
        // ширина: от (labelX - 2) до valueX, высота 10, по Y прямо под надписью (labelY + 10)
        int x = labelX - 2;
        int y = labelY + 10;
        int w = valueX - x;
        int h = 10;
        return new AttrBtn(id, x, y, w, h);
    }

    @Override
    public void render(GuiGraphics g, int mouseX, int mouseY, float pt) {
        // ВАЖНО: каждый кадр привязываем панель к актуальному положению инвентаря
        panelX = this.leftPos + this.imageWidth + 2;
        panelY = this.topPos;

        // фон экрана
        this.renderBackground(g, mouseX, mouseY, pt);

        // отрисовка инвентаря
        super.render(g, mouseX, mouseY, pt);

        // фон панели 160×224
        g.blit(PANEL_BG, panelX, panelY, 0, 0, PANEL_W, PANEL_H, PANEL_W, PANEL_H);

        // данные игрока
        var p = this.minecraft.player;
        var progressAtt = p.getData(ModAttachments.PLAYER_PROGRESS.get());
        var statsAtt    = p.getData(ModAttachments.PLAYER_STATS.get());

        PlayerProgress prog = progressAtt != null ? progressAtt.toSnapshot() : PlayerProgress.DEFAULT;
        int unspent = statsAtt != null ? statsAtt.getUnspentPoints() : 0;

        // === Шапка (твои координаты) ===
        // "Уровень: X" (мы выводим "Уровень: N" одной строкой)
        String lvlText = "Уровень: " + prog.level();
        g.drawString(this.font, lvlText, panelX + 49, panelY + 7, 0xFFE6DDAA, false);

        // Нераспределённые очки — только число
        g.drawString(this.font, String.valueOf(unspent), panelX + 107, panelY + 7, 0xFFFFFF, false);

        // === Атрибуты (аббревиатуры и значения) ===
        // порядок: СТК, СИЛ, ДУХ, ИНТ, ЛВК, УКЛ
        AttrLine[] lines = new AttrLine[] {
                new AttrLine("СТК", Attributes.VITALITY,     34, 22, 54, 22),
                new AttrLine("СИЛ", Attributes.STRENGTH,     34, 35, 54, 35),
                new AttrLine("ДУХ", Attributes.SPIRIT,       69, 22, 89, 22),
                new AttrLine("ИНТ", Attributes.INTELLIGENCE, 69, 35, 89, 35),
                new AttrLine("ЛВК", Attributes.DEXTERITY,   105, 22,125, 22),
                new AttrLine("УКЛ", Attributes.EVASION,     105, 35,125, 35)
        };
        for (AttrLine L : lines) {
            g.drawString(this.font, L.label, panelX + L.labelX, panelY + L.labelY, 0xFFFFFF, false);
            int val = (statsAtt != null) ? statsAtt.getAttribute(L.id) : 0;
            g.drawString(this.font, String.valueOf(val), panelX + L.valueX, panelY + L.valueY, 0xFFFFFF, false);
        }

        // === Кнопки «+» под атрибутами (прямоугольники) ===
        for (AttrBtn b : attrButtons) {
            int ax = panelX + b.x;
            int ay = panelY + b.y;
            boolean hover = mouseX >= ax && mouseX < ax + b.w && mouseY >= ay && mouseY < ay + b.h;
            int bg = hover ? 0x66FFFFFF : 0x33FFFFFF; // подсветка на hover
            g.fill(ax, ay, ax + b.w, ay + b.h, (bg & 0x00FFFFFF) | 0x33000000);
            // тень верх-низ для псевдокнопки
            g.fill(ax, ay, ax + b.w, ay + 1, 0x55FFFFFF);
            g.fill(ax, ay + b.h - 1, ax + b.w, ay + b.h, 0x22000000);
            // маленький плюсик по центру
            int px = ax + (b.w - this.font.width("+")) / 2;
            int py = ay + (b.h - this.font.lineHeight) / 2 + 1;
            g.drawString(this.font, "+", px, py, 0xFFFFFFFF, false);
        }

        // === Заголовок "Характеристики" по центру в (80, 55) ===
        String hdr = "Характеристики";
        int hdrX = panelX + 80 - this.font.width(hdr) / 2;
        int hdrY = panelY + 55;
        g.drawString(this.font, hdr, hdrX, hdrY, 0xFFE6DDAA, false);

        // === Три колонки: иконка + значение (числа). Иконки подключу, когда положишь PNG. ===
        // Сетка колонок: левый 10px отступ, равные колонки
        final int col1L = panelX + 10,  col1R = panelX + 56;
        final int col2L = panelX + 60,  col2R = panelX + 106;
        final int col3L = panelX + 110, col3R = panelX + 156;
        final int firstY = panelY + 70;
        final int rowStep = 14;

        if (statsAtt != null) {
            var s = statsAtt.getSnapshot();

            // Колонка 1 (базовые): HP, HP/s, MP, MP/s, Speed, AttackSpeed(=0 пока)
            drawStatIconRow(g, "hp_max",        s.maxHealth,       col1L, col1R, firstY + rowStep * 0, ValueFmt.INT);
            drawStatIconRow(g, "hp_regen",      s.regenHealth,     col1L, col1R, firstY + rowStep * 1, ValueFmt.INT);
            drawStatIconRow(g, "mp_max",        s.maxMana,         col1L, col1R, firstY + rowStep * 2, ValueFmt.INT);
            drawStatIconRow(g, "mp_regen",      s.regenMana,       col1L, col1R, firstY + rowStep * 3, ValueFmt.INT);
            drawStatIconRow(g, "move_speed",    s.moveSpeedPct,    col1L, col1R, firstY + rowStep * 4, ValueFmt.PCT);
            drawStatIconRow(g, "attack_speed",  0.0,               col1L, col1R, firstY + rowStep * 5, ValueFmt.INT);

            // Колонка 2 (резисты): phys, fire, frost, lightning, poison, armor(=0 пока)
            drawStatIconRow(g, "res_phys",      s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.PHYS_MELEE, 0f) * 100.0, col2L, col2R, firstY + rowStep * 0, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_fire",      s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FIRE, 0f) * 100.0,       col2L, col2R, firstY + rowStep * 1, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_frost",     s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FROST, 0f) * 100.0,      col2L, col2R, firstY + rowStep * 2, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_lightning", s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.LIGHTNING, 0f) * 100.0,  col2L, col2R, firstY + rowStep * 3, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_poison",    s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.POISON, 0f) * 100.0,     col2L, col2R, firstY + rowStep * 4, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "armor",         0.0,               col2L, col2R, firstY + rowStep * 5, ValueFmt.INT);

            // Колонка 3 (уроны)
            drawStatIconRow(g, "dmg_melee",     s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.PHYS_MELEE, 0f),  col3L, col3R, firstY + rowStep * 0, ValueFmt.F1);
            drawStatIconRow(g, "dmg_ranged",    s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.PHYS_RANGED, 0f), col3L, col3R, firstY + rowStep * 1, ValueFmt.F1);
            drawStatIconRow(g, "dmg_fire",      s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FIRE, 0f),        col3L, col3R, firstY + rowStep * 2, ValueFmt.F1);
            drawStatIconRow(g, "dmg_frost",     s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FROST, 0f),       col3L, col3R, firstY + rowStep * 3, ValueFmt.F1);
            drawStatIconRow(g, "dmg_lightning", s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.LIGHTNING, 0f),   col3L, col3R, firstY + rowStep * 4, ValueFmt.F1);
            drawStatIconRow(g, "dmg_poison",    s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.POISON, 0f),      col3L, col3R, firstY + rowStep * 5, ValueFmt.F1);
        }

        // тултипы можно будет добавить по наведению на области иконок/значений
        this.renderTooltip(g, mouseX, mouseY);
    }

    // Рисуем (пока только число; иконку подключу, когда добавишь PNG)
    private void drawStatIconRow(GuiGraphics g, String iconName, double value,
                                 int colL, int colR, int y, ValueFmt fmt) {
        // Иконка (16×16) слева; если текстуры ещё нет — просто пропустим blit
        int iconX = colL;
        int valRight = colR; // правое выравнивание числа
        try {
            // расчёт кадра анимации: кадр вверх-вниз 16 px
            IconDef def = Icons.get(iconName);
            if (def != null) {
                int frame = def.frames > 1 ? (int)((System.currentTimeMillis() / def.frameMs) % def.frames) : 0;
                int u = def.u;
                int v = def.v + frame * def.h;
                g.blit(ICONS_TEX, iconX, y - 3, u, v, def.w, def.h);
            }
        } catch (Throwable ignored) {
            // если текстуры нет — тихо не рисуем
        }

        String txt = switch (fmt) {
            case INT     -> String.valueOf((int)Math.round(value));
            case F1      -> String.format(java.util.Locale.ROOT, "%.1f", value);
            case PCT     -> String.format(java.util.Locale.ROOT, "+%.2f%%", value);
            case PCT_RAW -> String.format(java.util.Locale.ROOT, "%.0f%%", value);
        };
        int vx = valRight - this.font.width(txt);
        g.drawString(this.font, txt, vx, y, 0xFFFFFF, false);
    }

    private enum ValueFmt { INT, F1, PCT, PCT_RAW }

    // === Клики по «плюсам» ===
    @Override
    public boolean mouseClicked(double mx, double my, int button) {
        // клики по прямоугольникам «+»
        for (AttrBtn b : attrButtons) {
            int ax = panelX + b.x;
            int ay = panelY + b.y;
            if (mx >= ax && mx < ax + b.w && my >= ay && my < ay + b.h) {
                ModNetworking.sendAllocatePoint(b.id.name());
                return true;
            }
        }
        return super.mouseClicked(mx, my, button);
    }

    // ===== Вспомогательные структуры =====

    private record AttrLine(String label, Attributes id, int labelX, int labelY, int valueX, int valueY) {}

    private static final class AttrBtn {
        final Attributes id;
        final int x, y, w, h;
        AttrBtn(Attributes id, int x, int y, int w, int h) {
            this.id = id; this.x = x; this.y = y; this.w = w; this.h = h;
        }
    }

    // ——— Иконки (подключатся, когда добавишь stats_icons.png) ———
    private static final class IconDef {
        final int u, v, w, h, frames, frameMs;
        IconDef(int u, int v, int w, int h, int frames, int frameMs) {
            this.u = u; this.v = v; this.w = w; this.h = h; this.frames = frames; this.frameMs = Math.max(frameMs, 1);
        }
    }
    private static final class Icons {
        private static final java.util.Map<String, IconDef> MAP = new java.util.HashMap<>();
        static {
            // колонка 1
            MAP.put("hp_max",       new IconDef(  0, 0,14,14, 1,0));
            MAP.put("hp_regen",     new IconDef( 16, 0,16,16, 6, 60));
            MAP.put("mp_max",       new IconDef( 32, 0,16,16, 8, 60));
            MAP.put("mp_regen",     new IconDef( 48, 0,16,16, 8, 60));
            MAP.put("move_speed",   new IconDef( 64, 0,16,16, 7,120));
            MAP.put("attack_speed", new IconDef( 80, 0,16,16,10, 20));
            // колонка 2
            MAP.put("res_phys",     new IconDef( 96, 0,16,16, 8, 60));
            MAP.put("res_fire",     new IconDef(112, 0,16,16, 6, 60));
            MAP.put("res_frost",    new IconDef(128, 0,16,16, 6, 60));
            MAP.put("res_lightning",new IconDef(144, 0,16,16, 6, 20));
            MAP.put("res_poison",   new IconDef(160, 0,16,16, 6, 60));
            MAP.put("armor",        new IconDef(176, 0,16,16, 1,  0));
            // колонка 3
            MAP.put("dmg_melee",    new IconDef(192, 0,16,16, 1,  0));
            MAP.put("dmg_ranged",   new IconDef(208, 0,16,16, 1,  0));
            MAP.put("dmg_fire",     new IconDef(224, 0,16,16, 1,  0));
            MAP.put("dmg_frost",    new IconDef(240, 0,16,16, 1,  0));
            MAP.put("dmg_lightning",new IconDef(256, 0,16,16, 1,  0));
            MAP.put("dmg_poison",   new IconDef(272, 0,16,16, 1,  0));
        }
        static IconDef get(String key) { return MAP.get(key); }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimfate.network.ModNetworking;
import net.minecraft.client.KeyMapping;
import net.minecraft.client.Minecraft;
import net.minecraft.client.player.LocalPlayer;
import net.neoforged.neoforge.client.event.ClientTickEvent;
import net.neoforged.neoforge.client.event.RegisterKeyMappingsEvent;
import org.lwjgl.glfw.GLFW;

public final class Hotkeys {
    private Hotkeys() {}

    private static final String CAT = "key.categories.grimfate";

    // Только слоты спеллов
    private static final String[] SPELL_IDS = {
            "key.grimfate.spellslot_1",
            "key.grimfate.spellslot_2",
            "key.grimfate.spellslot_3",
            "key.grimfate.spellslot_4",
            "key.grimfate.spellslot_5",
            "key.grimfate.spellslot_6"
    };
    private static final int[] DEFAULTS = {
            GLFW.GLFW_KEY_R, GLFW.GLFW_KEY_F, GLFW.GLFW_KEY_C,
            GLFW.GLFW_KEY_V, GLFW.GLFW_KEY_B, GLFW.GLFW_KEY_N
    };

    private static final KeyMapping[] SPELL_KEYS = new KeyMapping[6];

    private static boolean CREATED = false;
    private static boolean REGISTERED = false;

    private static void ensureCreated() {
        if (CREATED) return;
        CREATED = true;

        for (int i = 0; i < SPELL_KEYS.length; i++) {
            SPELL_KEYS[i] = new KeyMapping(SPELL_IDS[i], DEFAULTS[i], CAT);
        }
    }

    /** MOD-bus: регистрация key mappings. */
    public static void onRegisterKeys(RegisterKeyMappingsEvent e) {
        ensureCreated();
        if (REGISTERED) {
            // уже зарегистрировано
            return;
        }
        REGISTERED = true;

        for (KeyMapping km : SPELL_KEYS) e.register(km);
    }

    /** NeoForge-bus: обработка нажатий. */
    public static void onClientTick(ClientTickEvent.Post e) {
        Minecraft mc = Minecraft.getInstance();
        LocalPlayer p = mc.player;
        if (p == null) return;

        for (int i = 0; i < SPELL_KEYS.length; i++) {
            KeyMapping km = SPELL_KEYS[i];
            if (km != null && km.consumeClick()) {
                ModNetworking.sendCastSpellSlot(i);
            }
        }
    }

    public static String spellKeyName(int idx) {
        if (idx < 0 || idx >= SPELL_KEYS.length || SPELL_KEYS[idx] == null) return "?";
        return SPELL_KEYS[idx].getTranslatedKeyMessage().getString();
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\model\armor\BaseArmorGeoModel.java -----
package com.doomspire.grimfate.client.model.armor;

import com.doomspire.grimfate.item.armor.GenericGeoArmorItem;
import net.minecraft.resources.ResourceLocation;
import org.jetbrains.annotations.Nullable;
import software.bernie.geckolib.model.GeoModel;

public class BaseArmorGeoModel extends GeoModel<GenericGeoArmorItem> {

    @Override
    public ResourceLocation getModelResource(GenericGeoArmorItem animatable) {
        // Берём путь к GEO из Visual (пример: assets/grimfate/geo/armor/copper_armor_set.geo.json)
        return animatable.visual().geo();
    }

    @Override
    public ResourceLocation getTextureResource(GenericGeoArmorItem animatable) {
        // Берём путь к TEXTURE из Visual (пример: assets/grimfate/textures/armor/copper_set.png)
        return animatable.visual().texture();
    }

    @Override
    public @Nullable ResourceLocation getAnimationResource(GenericGeoArmorItem animatable) {
        // Если анимаций нет — можно вернуть null
        return null;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\model\armor\BaseArmorGeoModel.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\render\armor\BaseArmorRenderer.java -----
package com.doomspire.grimfate.client.render.armor;

import com.doomspire.grimfate.client.model.armor.BaseArmorGeoModel;
import com.doomspire.grimfate.item.armor.GenericGeoArmorItem;
import software.bernie.geckolib.renderer.GeoArmorRenderer;

/**
 * Базовый GeckoLib-рендерер брони для всех сетов Grimfate.
 * Работает с {@link GenericGeoArmorItem} и читает пути к geo/texture из его Visual.
 *
 * ВАЖНО: имена костей (bone ids) должны совпадать с теми, что в .geo.json.
 * Ниже указаны дефолтные/распространённые идентификаторы. Если в ваших моделях другие,
 * просто поправьте строки на ваши bone ids.
 */
public class BaseArmorRenderer extends GeoArmorRenderer<GenericGeoArmorItem> {

    public BaseArmorRenderer() {
        super(new BaseArmorGeoModel());
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\render\armor\BaseArmorRenderer.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponPredicates.java -----
package com.doomspire.grimfate.combat;

import com.doomspire.grimfate.registry.ModDataComponents;
import com.doomspire.grimfate.registry.ModItemTags;
import net.minecraft.world.item.ItemStack;

public final class WeaponPredicates {
    public static boolean isType(ItemStack stack, WeaponType t) {
        var prof = stack.get(ModDataComponents.WEAPON_PROFILE.get());
        if (prof != null) return prof.type() == t;
        return switch (t) {
            case STAFF  -> stack.is(ModItemTags.STAVES);
            case BOW    -> stack.is(ModItemTags.RANGED_WEAPONS);
            case DAGGER -> stack.is(ModItemTags.DAGGERS);
            case SWORD  -> stack.is(ModItemTags.MELEE_WEAPONS);
            case SHIELD -> stack.is(ModItemTags.SHIELDS);
            case GREATSWORD -> stack.is(ModItemTags.MELEE_WEAPONS);
            case HAMMER -> stack.is(ModItemTags.MELEE_WEAPONS);
            default     -> false;
        };
    }
    public static boolean isStaff(ItemStack s)  { return isType(s, WeaponType.STAFF); }
    public static boolean isRanged(ItemStack s) { return isType(s, WeaponType.BOW); }
    public static boolean isMelee(ItemStack s)  { return isType(s, WeaponType.SWORD) || isType(s, WeaponType.DAGGER) || isType(s, WeaponType.AXE)
            || isType(s, WeaponType.GREATSWORD) || isType(s, WeaponType.HAMMER); }
    public static boolean isShield(ItemStack s) { return isType(s, WeaponType.SHIELD); }
    private WeaponPredicates() {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponPredicates.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponType.java -----
package com.doomspire.grimfate.combat;
public enum WeaponType { SWORD, AXE, DAGGER, STAFF, BOW, SHIELD, HAMMER, GREATSWORD }


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponType.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java -----
package com.doomspire.grimfate.commands;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.commands.arguments.ResourceLocationArgument;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.exceptions.CommandSyntaxException;

import java.util.Collection;

public final class AddSpellCommand {

    private AddSpellCommand() {}

    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        dispatcher.register(Commands.literal("grimfate")
                .then(Commands.literal("addspell")
                        // /grimfate addspell <spell>  — для себя
                        .then(Commands.argument("spell", ResourceLocationArgument.id())
                                .executes(ctx -> {
                                    ServerPlayer self = ctx.getSource().getPlayerOrException();
                                    ResourceLocation rl = ResourceLocationArgument.getId(ctx, "spell");
                                    int added = addToPlayer(self, rl);
                                    if (added > 0) {
                                        ctx.getSource().sendSuccess(() ->
                                                Component.literal("Added spell " + rl + " to " + self.getGameProfile().getName()), true);
                                        return 1;
                                    } else {
                                        ctx.getSource().sendFailure(Component.literal("No free slot for " + rl + " on " + self.getGameProfile().getName()));
                                        return 0;
                                    }
                                }))
                        // /grimfate addspell <targets> <spell>
                        .then(Commands.argument("targets", EntityArgument.players())
                                .then(Commands.argument("spell", ResourceLocationArgument.id())
                                        .executes(ctx -> {
                                            Collection<ServerPlayer> targets = EntityArgument.getPlayers(ctx, "targets");
                                            ResourceLocation rl = ResourceLocationArgument.getId(ctx, "spell");
                                            int total = 0;
                                            for (ServerPlayer sp : targets) {
                                                total += addToPlayer(sp, rl);
                                            }
                                            if (total > 0) {
                                                final int count = total; // effectively final копия для лямбды
                                                ctx.getSource().sendSuccess(() ->
                                                        Component.literal("Added spell " + rl + " to " + count + " player(s)"), true);
                                                return total;
                                            } else {
                                                ctx.getSource().sendFailure(Component.literal("No recipients had a free slot for " + rl));
                                                return 0;
                                            }
                                        })))
                )
        );
    }

    /**
     * Пытается добавить спелл в первый свободный слот лоадаута игрока.
     * Возвращает 1 если добавлено, иначе 0.
     */
    private static int addToPlayer(ServerPlayer sp, ResourceLocation rl) throws CommandSyntaxException {
        PlayerLoadoutAttachment att = sp.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (att == null) {
            return 0;
        }
        for (int i = 0; i < PlayerLoadoutAttachment.SLOTS; i++) {
            if (att.get(i) == null) {
                att.set(i, rl);
                // Триггерим авто-синхронизацию (ModAttachments.PLAYER_LOADOUT должен быть зарегистрирован с .sync(...))
                sp.setData(ModAttachments.PLAYER_LOADOUT.get(), att);
                return 1;
            }
        }
        return 0;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\compat\bettercombat\BetterCombatBridge.java -----
package com.doomspire.grimfate.compat.bettercombat;

import com.mojang.logging.LogUtils;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.tags.TagKey;
import net.minecraft.world.item.Item;
import net.neoforged.fml.ModList;
import org.slf4j.Logger;

//NOTE: Мягкая интеграция с Better Combat (без жёсткой зависимости)
/**
 * Задача «моста» — централизовать:
 *  1) проверку наличия мода,
 *  2) константы с их тегами (Item Tags), чтобы удобно маппить наши теги в data-ресурсах,
 *  3) место для будущих утилит, если понадобится.
 *
 * ВАЖНО:
 *  - Реальная привязка к анимациям происходит через data-теги (JSON),
 *    где мы включаем наши теги (#grimfate:daggers, #grimfate:swords, #grimfate:two_handed …)
 *    в их теги (bettercombat:daggers, bettercombat:swords, …).
 *  - Этот класс НЕ тянет никаких API Better Combat во время компиляции.
 */
public final class BetterCombatBridge {
    private static final Logger LOGGER = LogUtils.getLogger();
    public static final String MODID = "bettercombat";

    private BetterCombatBridge() {}

    /** Есть ли установлен Better Combat. */
    public static boolean isLoaded() {
        return ModList.get().isLoaded(MODID);
    }

    /** Вызвать из commonSetup для логов диагностики. */
    public static void init() {
        if (isLoaded()) {
            LOGGER.info("[Grimfate] Better Combat detected. Weapon tags will be bridged via data pack.");
        } else {
            LOGGER.warn("[Grimfate] Better Combat NOT detected. Using vanilla/Gecko animations only.");
        }
    }

    // ---------- Их основные item-теги (называем ровно как у них; используем только как ссылки в ресурсах) ----------

    public static final TagKey<Item> BC_SWORDS      = itemTag("swords");
    public static final TagKey<Item> BC_DAGGERS     = itemTag("daggers");
    public static final TagKey<Item> BC_AXES        = itemTag("axes");
    public static final TagKey<Item> BC_MACES       = itemTag("maces");
    public static final TagKey<Item> BC_HAMMERS     = itemTag("hammers");
    public static final TagKey<Item> BC_SPEARS      = itemTag("spears");
    public static final TagKey<Item> BC_POLEARMS    = itemTag("polearms");
    public static final TagKey<Item> BC_GREATSWORDS = itemTag("greatswords");
    public static final TagKey<Item> BC_GREATAXES   = itemTag("greataxes");
    public static final TagKey<Item> BC_STAVES      = itemTag("staves"); // если у них есть такой набор (покрываем на будущее)

    /** Наш общий флаг-свойство (двуручность) — маппится в группы greatswords/greataxes/spears/… через data. */
    public static final TagKey<Item> GF_TWO_HANDED  =
            TagKey.create(net.minecraft.core.registries.Registries.ITEM,
                    ResourceLocation.fromNamespaceAndPath("grimfate", "two_handed"));

    private static TagKey<Item> itemTag(String path) {
        return TagKey.create(net.minecraft.core.registries.Registries.ITEM,
                ResourceLocation.fromNamespaceAndPath(MODID, path));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\compat\bettercombat\BetterCombatBridge.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\compat\curios\CuriosCompat.java -----
package com.doomspire.grimfate.compat.curios;

import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ItemStack;
import net.neoforged.fml.ModList;

import java.util.function.BiConsumer;

/**
 * Мягкая интеграция с Curios. Сейчас содержит только проверку наличия.
 * Позже сюда добавим реальное чтение экипированных curios-предметов,
 * чтобы складывать их StatBonus-компоненты в агрегатор статов.
 */
public final class CuriosCompat {
    public static final String MODID = "curios";

    private CuriosCompat() {}

    public static boolean isLoaded() {
        return ModList.get().isLoaded(MODID);
    }

    /**
     * Заглушка: когда подключим API-вызовы Curios, сюда добавим обход всех слотов Curios
     * и вызов consumer.accept(stack, slotId).
     */
    public static void forEachEquipped(LivingEntity entity, BiConsumer<ItemStack, String> consumer) {
        if (!isLoaded()) return;
        // TODO: реализовать через CuriosApi при добавлении API в компиляцию агрегатора
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\compat\curios\CuriosCompat.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java -----
package com.doomspire.grimfate.config;

import net.neoforged.fml.config.ModConfig;
import net.neoforged.neoforge.common.ModConfigSpec;

public class ClientConfig {
    public static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();

    public static final ModConfigSpec.IntValue HEALTH_BAR_X;
    public static final ModConfigSpec.IntValue HEALTH_BAR_Y;

    public static final ModConfigSpec.IntValue MANA_BAR_X;
    public static final ModConfigSpec.IntValue MANA_BAR_Y;

    public static final ModConfigSpec.IntValue XP_ICON_X;
    public static final ModConfigSpec.IntValue XP_ICON_Y;

    public static final ModConfigSpec.IntValue SPELLBAR_X;
    public static final ModConfigSpec.IntValue SPELLBAR_Y;

    static {
        SPELLBAR_X = BUILDER
                .comment("Смещение спелбара по X")
                .defineInRange("hud.spellbar_x", -60, -500, 500);

        SPELLBAR_Y = BUILDER
                .comment("Смещение спелбара по X")
                .defineInRange("hud.spellbar_y", -78, -500, 500);

        HEALTH_BAR_X = BUILDER
                .comment("Смещение полоски здоровья по X")
                .defineInRange("hud.health_bar_x", -60, -500, 500);

        HEALTH_BAR_Y = BUILDER
                .comment("Смещение полоски здоровья по Y")
                .defineInRange("hud.health_bar_y", -78, -500, 500);

        MANA_BAR_X = BUILDER
                .comment("Смещение полоски маны по X")
                .defineInRange("hud.mana_bar_x", -60, -500, 500);

        MANA_BAR_Y = BUILDER
                .comment("Смещение полоски маны по Y")
                .defineInRange("hud.mana_bar_y", -65, -500, 500);

        XP_ICON_X = BUILDER
                .comment("Смещение иконки опыта по X")
                .defineInRange("hud.xp_icon_x", -30, -500, 500);

        XP_ICON_Y = BUILDER
                .comment("Смещение иконки опыта по Y")
                .defineInRange("hud.xp_icon_y", -100, -500, 500);
    }

    public static final ModConfigSpec SPEC = BUILDER.build();
}



n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java -----
package com.doomspire.grimfate.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * 🔧 ModConfig — централизованный конфиг мода
 * В будущем:
 *  - хранение базовых статов для игроков и мобов
 *  - множители регена/урона
 *  - настройка аффиксов
 *  - редактирование через JSON без пересборки
 */
public class ModConfig {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final File CONFIG_FILE = new File("config/grimfate.json");

    // ===== Пример будущих параметров (пока закомментированы) =====

    // Базовые статы игрока
    // public int basePlayerHealth = 100;
    // public float basePlayerRegen = 0.5f; // 0.5 хп в сек.
    // public int basePlayerMana = 50;
    // public float manaRegenMultiplier = 1.0f;

    // Базовые статы мобов
    // public int baseMobHealth = 50;
    // public float baseMobRegen = 1.0f;

    // Множители урона/защиты
    // public float damageMultiplier = 1.0f;
    // public float defenseMultiplier = 1.0f;

    // Система аффиксов (позже)
    // public float affixDropChance = 0.1f;

    // =============================================================

    private static ModConfig INSTANCE = new ModConfig();

    public static ModConfig get() {
        return INSTANCE;
    }

    /** Загружаем конфиг из JSON */
    public static void load() {
        if (!CONFIG_FILE.exists()) {
            save(); // если файла нет, создаём дефолт
            return;
        }

        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            INSTANCE = GSON.fromJson(reader, ModConfig.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /** Сохраняем конфиг в JSON */
    public static void save() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(INSTANCE, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java -----
package com.doomspire.grimfate.core;

import java.util.List;

import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.neoforge.common.ModConfigSpec;

// An example config class. This is not required, but it's a good idea to have one to keep your config organized.
// Demonstrates how to use Neo's config APIs
public class Config {
    private static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();

    public static final ModConfigSpec.BooleanValue LOG_DIRT_BLOCK = BUILDER
            .comment("Whether to log the dirt block on common setup")
            .define("logDirtBlock", true);

    public static final ModConfigSpec.IntValue MAGIC_NUMBER = BUILDER
            .comment("A magic number")
            .defineInRange("magicNumber", 42, 0, Integer.MAX_VALUE);

    public static final ModConfigSpec.ConfigValue<String> MAGIC_NUMBER_INTRODUCTION = BUILDER
            .comment("What you want the introduction message to be for the magic number")
            .define("magicNumberIntroduction", "The magic number is... ");

    // a list of strings that are treated as resource locations for items
    public static final ModConfigSpec.ConfigValue<List<? extends String>> ITEM_STRINGS = BUILDER
            .comment("A list of items to log on common setup.")
            .defineListAllowEmpty("items", List.of("minecraft:iron_ingot"), () -> "", Config::validateItemName);

    static final ModConfigSpec SPEC = BUILDER.build();

    private static boolean validateItemName(final Object obj) {
        return obj instanceof String itemName && BuiltInRegistries.ITEM.containsKey(ResourceLocation.parse(itemName));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java -----
package com.doomspire.grimfate.core;

import com.doomspire.grimcore.affix.AffixAggregator;
import com.doomspire.grimcore.affix.ModAffixes;
import com.doomspire.grimfate.commands.AddSpellCommand;
import com.doomspire.grimfate.config.ClientConfig;
import com.doomspire.grimfate.item.armor.Armors;
import com.doomspire.grimfate.item.jewelry.Jewelry;
import com.doomspire.grimfate.item.materials.Materials;
import com.doomspire.grimfate.item.weapons.Weapons;
import com.doomspire.grimfate.network.ModNetworking;
import com.doomspire.grimfate.registry.*;
import com.mojang.logging.LogUtils;
import net.minecraft.core.Registry;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.core.registries.Registries;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;
import net.neoforged.fml.config.ModConfig;
import net.neoforged.fml.event.lifecycle.FMLCommonSetupEvent;
import net.neoforged.fml.loading.FMLEnvironment;
import net.neoforged.neoforge.event.BuildCreativeModeTabContentsEvent;
import net.neoforged.neoforge.event.RegisterCommandsEvent;
import net.neoforged.neoforge.event.server.ServerStartingEvent;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;
import org.slf4j.Logger;

@Mod(Grimfate.MODID)
public class Grimfate {
    public static final String MODID = "grimfate";
    public static final Logger LOGGER = LogUtils.getLogger();

    public static final DeferredRegister<CreativeModeTab> CREATIVE_MODE_TABS =
            DeferredRegister.create(Registries.CREATIVE_MODE_TAB, MODID);

    // Вкладка 1: Снаряжение (оружие/броня/бижутерия)
    public static final DeferredHolder<CreativeModeTab, CreativeModeTab> TAB_EQUIPMENT =
            CREATIVE_MODE_TABS.register("equipment", () -> CreativeModeTab.builder()
                    .title(Component.translatable("itemGroup.grimfate.equipment"))
                    .icon(() -> new ItemStack(Weapons.COPPER_SWORD.get()))
                    .withSearchBar()
                    .build());

    // Вкладка 2: Материалы и блоки
    public static final DeferredHolder<CreativeModeTab, CreativeModeTab> TAB_MATERIALS =
            CREATIVE_MODE_TABS.register("materials", () -> CreativeModeTab.builder()
                    .title(Component.translatable("itemGroup.grimfate.materials"))
                    // Иконка — попытаемся взять fiber, если нет — fallback на медный меч
                    .icon(() -> new ItemStack(Materials.RAWHIDE.get()))
                    .withSearchBar()
                    .build());

    // Вкладка 3: Мобы (пока пусто, но таб будет готов)
    public static final DeferredHolder<CreativeModeTab, CreativeModeTab> TAB_MOBS =
            CREATIVE_MODE_TABS.register("mobs", () -> CreativeModeTab.builder()
                    .title(Component.translatable("itemGroup.grimfate.mobs"))
                    .icon(() -> new ItemStack(Materials.PORK_FAT.get()))
                    .withSearchBar()
                    .build());

    public Grimfate(IEventBus modEventBus, ModContainer modContainer) {
        // Конфиги
        modContainer.registerConfig(ModConfig.Type.CLIENT, ClientConfig.SPEC);
        modContainer.registerConfig(ModConfig.Type.COMMON, Config.SPEC);

        // Сеть
        modEventBus.addListener(ModNetworking::register);

        // Контент
        CREATIVE_MODE_TABS.register(modEventBus);
        ModItems.init(modEventBus);
        ModEntityTypes.init(modEventBus);
        ModArmorMaterials.ARMOR_MATERIALS.register(modEventBus);
        com.doomspire.grimfate.loot.ModLootModifiers.init(modEventBus);
        ModDataComponents.DATA_COMPONENT_TYPES.register(modEventBus);

        com.doomspire.grimfate.item.weapons.Weapons.init(modEventBus);
        com.doomspire.grimfate.item.armor.Armors.init(modEventBus);
        com.doomspire.grimfate.item.materials.Materials.init(modEventBus);
        com.doomspire.grimfate.item.jewelry.Jewelry.init(modEventBus);

        // Фазы
        modEventBus.addListener(this::commonSetup);
        modEventBus.addListener(this::addCreative);

        // Клиент — все клиентские MOD-бус листенеры
        if (FMLEnvironment.dist.isClient()) {
            GrimfateClient.registerModBusListeners(modEventBus);
        }
    }

    private void commonSetup(final FMLCommonSetupEvent e) {
        e.enqueueWork(() -> {
            // Two-hand резолвер для WeaponGate (читает профили из data-компонента)
            com.doomspire.grimcore.spell.api.WeaponGate.setTwoHandedResolver((stack, player) -> {
                var comp = stack.get(com.doomspire.grimfate.registry.ModDataComponents.WEAPON_PROFILE.get());
                return comp != null && comp.twoHanded();
            });

            // Интеграции
            com.doomspire.grimfate.compat.bettercombat.BetterCombatBridge.init();
            com.doomspire.grimfate.registry.ModCurios.init();

            // Аффиксы
            ModAffixes.bootstrap();
            AffixAggregator.setExtractor(com.doomspire.grimfate.affix.GrimfateAffixExtraction::extractFromEntity);

            LOGGER.info("[Grimfate] Creative tabs registered; AffixAggregator hooked; integrations bootstrapped.");
        });
    }

    // Наполнение вкладок
    private void addCreative(final BuildCreativeModeTabContentsEvent e) {
        if (e.getTab() == TAB_EQUIPMENT.get()) {

            safeAdd(e, Weapons.COPPER_SWORD);
            safeAdd(e, Weapons.SCHOLAR_STAFF);
            safeAdd(e, Weapons.WEAKLING_BOW);
            safeAdd(e, Weapons.COPPERFORCED_SHIELD);
            safeAdd(e, Armors.COPPER_BOOTS);
            safeAdd(e, Armors.COPPER_CHESTPLATE);
            safeAdd(e, Armors.COPPER_LEGGINGS);
            safeAdd(e, Armors.COPPER_HELMET);
            safeAdd(e, Jewelry.COPPER_RING);
            safeAdd(e, Jewelry.COPPER_NECKLACE);
            safeAdd(e, Jewelry.BRONZE_RING);
            safeAdd(e, Jewelry.BRONZE_NECKLACE);
            safeAdd(e, Armors.LINEN_SHOES);
            safeAdd(e, Armors.LINEN_CAPE);
            safeAdd(e, Armors.LINEN_PANTS);
            safeAdd(e, Armors.LINEN_HAT);
            safeAdd(e, Armors.RAWHIDE_BOOTS);
            safeAdd(e, Armors.RAWHIDE_JACKET);
            safeAdd(e, Armors.RAWHIDE_WRAPS);
            safeAdd(e, Armors.RAWHIDE_HOOD);

        }
        else if (e.getTab() == TAB_MATERIALS.get()) {
            // Материалы по id (без жёсткой зависимости на класс подмодуля)
            acceptIfPresent(e, rl("fiber"));
            acceptIfPresent(e, rl("canvas_fabric.json"));
            acceptIfPresent(e, rl("pork_fat"));
            acceptIfPresent(e, rl("rawhide"));
            // Блоки добавим позже, когда появятся
        }
        else if (e.getTab() == TAB_MOBS.get()) {
            // Пока пусто — добавим яйца призыва и дропы, когда появятся сущности
        }
    }

    // ==== Helpers ============================================================

    private static void safeAdd(BuildCreativeModeTabContentsEvent e, DeferredHolder<Item, ? extends Item> h) {
        if (h != null && h.isBound()) e.accept(h.get());
    }

    private static void acceptIfPresent(BuildCreativeModeTabContentsEvent e, ResourceLocation id) {
        Item item = lookupItem(id);
        if (item != null) e.accept(item);
    }

    private static ItemStack stackOrFallback(ResourceLocation prefer, Item fallback) {
        Item item = lookupItem(prefer);
        return new ItemStack(item != null ? item : fallback);
    }

    private static Item lookupItem(ResourceLocation id) {
        return BuiltInRegistries.ITEM.getOptional(id).orElse(null);
    }


    @net.neoforged.bus.api.SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent e) {
        AddSpellCommand.register(e.getDispatcher());
    }

    public static ResourceLocation rl(String path) {
        return ResourceLocation.fromNamespaceAndPath(MODID, path);
    }

    @net.neoforged.bus.api.SubscribeEvent
    public void onServerStarting(ServerStartingEvent event) { /* ... */ }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java -----
package com.doomspire.grimfate.core;

import com.doomspire.grimfate.client.Hotkeys;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import com.doomspire.grimfate.registry.ModEntityTypes;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.entity.ThrownItemRenderer;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.client.event.EntityRenderersEvent;
import net.neoforged.neoforge.client.event.RegisterKeyMappingsEvent;
import net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;
import net.neoforged.neoforge.common.NeoForge;

public final class GrimfateClient {
    private GrimfateClient() {}

    public static void registerModBusListeners(IEventBus modBus) {
        modBus.addListener(GrimfateClient::onRegisterRenderers);
        modBus.addListener(GrimfateClient::onClientSetup);
        // Ключевая строка: регистрируем KeyMappings только отсюда
        modBus.addListener(Hotkeys::onRegisterKeys);
        modBus.addListener((net.neoforged.fml.event.lifecycle.FMLClientSetupEvent e) ->
                e.enqueueWork(com.doomspire.grimfate.client.BowModelProperties::register));

    }

    static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers e) {
        e.registerEntityRenderer(ModEntityTypes.BOLT.get(),
                ctx -> new ThrownItemRenderer<BoltProjectileEntity>(ctx, 1.0f, false));
    }

    static void onClientSetup(FMLClientSetupEvent e) {
        Grimfate.LOGGER.info("Client setup OK. User={}", Minecraft.getInstance().getUser().getName());
        // Forge-bus listener для тиков — ровно один раз
        NeoForge.EVENT_BUS.addListener(Hotkeys::onClientTick);
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java -----
package com.doomspire.grimfate.entity;

import net.minecraft.core.particles.ParticleTypes;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.projectile.ThrowableItemProjectile;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.Level;
import net.minecraft.world.phys.HitResult;
import net.minecraft.world.phys.Vec3;

public class BoltProjectileEntity extends ThrowableItemProjectile {

    public BoltProjectileEntity(EntityType<? extends BoltProjectileEntity> type, Level level) {
        super(type, level);
        this.setNoGravity(true);
    }

    public BoltProjectileEntity(Level level, LivingEntity shooter) {
        this(com.doomspire.grimfate.registry.ModEntityTypes.BOLT.get(), level);
        this.setOwner(shooter);
        this.setNoGravity(true);
    }

    /** Отдаём клиенту предмет для ThrownItemRenderer. */
    @Override
    protected Item getDefaultItem() {
        // TODO: заменить на собственный bolt_item для посоха
        return net.minecraft.world.item.Items.AIR;
    }

    /** Старт с небольшим смещением от глаз + задание скорости. */
    public void shootForward(LivingEntity shooter, float speed) {
        Vec3 look = shooter.getLookAngle();
        // смещение на полблока вперёд, чтобы не цеплять свой хитбокс
        this.setPos(
                shooter.getX() + look.x * 0.5,
                shooter.getEyeY() - 0.1 + look.y * 0.5,
                shooter.getZ() + look.z * 0.5
        );
        this.setDeltaMovement(look.normalize().scale(speed));
    }

    @Override
    protected void onHit(HitResult result) {
        super.onHit(result);

        if (!level().isClientSide) {
            // Небольшая частица в месте попадания
            ((ServerLevel) level()).sendParticles(ParticleTypes.CRIT, getX(), getY(), getZ(), 4, 0, 0, 0, 0.0);

            // Урон по цели, если есть «живая» цель
            if (result.getType() == HitResult.Type.ENTITY && getOwner() instanceof LivingEntity owner) {
                var hit = ((net.minecraft.world.phys.EntityHitResult) result).getEntity();
                if (hit instanceof LivingEntity target) {
                    // наш физ-ранжед, простой урон через ванильный DamageSource (ядро боя подключим позже)
                    DamageSource src = level().damageSources().indirectMagic(this, owner); // пока нейтральный DS
                    target.hurt(src, 5.0f); // базовый урон; позже подменим на DamageEngine
                }
            }
            discard();
        }
    }

    @Override
    public void tick() {
        super.tick();
        // Жизнь ~36 блоков при скорости ~1.8 => 20 тиков * 2 сек достаточно
        if (this.tickCount > 40) this.discard();
        if (level().isClientSide) {
            level().addParticle(ParticleTypes.CRIT, getX(), getY(), getZ(), 0, 0, 0);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java -----
package com.doomspire.grimfate.events;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.world.entity.player.Player;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.tick.PlayerTickEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.DEDICATED_SERVER) // слушаем только на сервере
public final class LoadoutTickEvents {
    private LoadoutTickEvents() {}

    private static final Map<UUID, Long> LAST_SYNC_TICK = new HashMap<>();
    private static final Map<UUID, Integer> LAST_SUM = new HashMap<>();
    private static final int SYNC_COOLDOWN_TICKS = 10; // ~0.5с при 20 TPS

    @SubscribeEvent
    public static void onPlayerTick(PlayerTickEvent.Post e) {
        Player p = e.getEntity();
        if (p.level().isClientSide) return;

        PlayerLoadoutAttachment att = p.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (att == null) return;

        // 1) уменьшаем кулдауны
        att.tickDown();

        // 2) считаем «суммарный кулдаун», чтобы дешево понимать, изменилось ли что-то
        int sum = 0;
        for (int i = 0; i < PlayerLoadoutAttachment.SLOTS; i++) {
            sum += att.getCooldown(i);
        }

        long now = p.level().getGameTime();
        UUID id = p.getUUID();
        long last = LAST_SYNC_TICK.getOrDefault(id, 0L);
        int prev = LAST_SUM.getOrDefault(id, -1);

        // 3) синкаем только если:
        //  - прошло >= SYNC_COOLDOWN_TICKS тиков
        //  - изменилась агрегированная сумма (включая переход в ноль)
        if ((now - last) >= SYNC_COOLDOWN_TICKS && sum != prev) {
            p.setData(ModAttachments.PLAYER_LOADOUT.get(), att); // триггерит .sync(...) из ModAttachments
            LAST_SYNC_TICK.put(id, now);
            LAST_SUM.put(id, sum);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\armor\Armors.java -----
package com.doomspire.grimfate.item.armor;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.item.armor.GenericGeoArmorItem;
import com.doomspire.grimfate.registry.ModArmorMaterials;
import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.Item;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;

//NOTE: Подмодуль регистрации брони.

public final class Armors {
    private Armors() {}

    // ===== VISUALS =====
    private static GenericGeoArmorItem.Visual copperVisual() {
        return new GenericGeoArmorItem.Visual(
                Grimfate.rl("geo/armor/copper_armor_set.geo.json"),
                Grimfate.rl("textures/armor/copper_armor_set_texture.png")
        );
    }

    private static GenericGeoArmorItem.Visual rawhideVisual() {
        return new GenericGeoArmorItem.Visual(
                Grimfate.rl("geo/armor/rawhide_armor_set.geo.json"),
                Grimfate.rl("textures/armor/rawhide_armor_set.png")
        );
    }

    private static GenericGeoArmorItem.Visual linenVisual() {
        return new GenericGeoArmorItem.Visual(
                Grimfate.rl("geo/armor/linen_armor_set.geo.json"),
                Grimfate.rl("textures/armor/linen_armor_set.png")
        );
    }

    // ===== COPPER =====
    public static final DeferredHolder<Item, Item> COPPER_HELMET =
            ModItems.ITEMS.register("copper_helmet",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.copperHolder(),
                            ArmorItem.Type.HELMET, new Item.Properties(), copperVisual()));

    public static final DeferredHolder<Item, Item> COPPER_CHESTPLATE =
            ModItems.ITEMS.register("copper_chestplate",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.copperHolder(),
                            ArmorItem.Type.CHESTPLATE, new Item.Properties(), copperVisual()));

    public static final DeferredHolder<Item, Item> COPPER_LEGGINGS =
            ModItems.ITEMS.register("copper_leggings",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.copperHolder(),
                            ArmorItem.Type.LEGGINGS, new Item.Properties(), copperVisual()));

    public static final DeferredHolder<Item, Item> COPPER_BOOTS =
            ModItems.ITEMS.register("copper_boots",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.copperHolder(),
                            ArmorItem.Type.BOOTS, new Item.Properties(), copperVisual()));

    // ===== RAWHIDE =====
    public static final DeferredHolder<Item, Item> RAWHIDE_HOOD =
            ModItems.ITEMS.register("rawhide_hood",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.rawhideHolder(),
                            ArmorItem.Type.HELMET, new Item.Properties(), rawhideVisual()));

    public static final DeferredHolder<Item, Item> RAWHIDE_JACKET =
            ModItems.ITEMS.register("rawhide_jacket",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.rawhideHolder(),
                            ArmorItem.Type.CHESTPLATE, new Item.Properties(), rawhideVisual()));

    public static final DeferredHolder<Item, Item> RAWHIDE_WRAPS =
            ModItems.ITEMS.register("rawhide_wraps",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.rawhideHolder(),
                            ArmorItem.Type.LEGGINGS, new Item.Properties(), rawhideVisual()));

    public static final DeferredHolder<Item, Item> RAWHIDE_BOOTS =
            ModItems.ITEMS.register("rawhide_boots",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.rawhideHolder(),
                            ArmorItem.Type.BOOTS, new Item.Properties(), rawhideVisual()));

    // ===== LINEN =====
    public static final DeferredHolder<Item, Item> LINEN_HAT =
            ModItems.ITEMS.register("linen_hat",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.linenHolder(),
                            ArmorItem.Type.HELMET, new Item.Properties(), linenVisual()));

    public static final DeferredHolder<Item, Item> LINEN_CAPE =
            ModItems.ITEMS.register("linen_cape",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.linenHolder(),
                            ArmorItem.Type.CHESTPLATE, new Item.Properties(), linenVisual()));

    public static final DeferredHolder<Item, Item> LINEN_PANTS =
            ModItems.ITEMS.register("linen_pants",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.linenHolder(),
                            ArmorItem.Type.LEGGINGS, new Item.Properties(), linenVisual()));

    public static final DeferredHolder<Item, Item> LINEN_SHOES =
            ModItems.ITEMS.register("linen_shoes",
                    () -> new GenericGeoArmorItem(
                            ModArmorMaterials.linenHolder(),
                            ArmorItem.Type.BOOTS, new Item.Properties(), linenVisual()));

    /** Вызывается из ModItems.init(modBus) при необходимости; регистрации статичны. */
    public static void init(IEventBus modBus) {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\armor\Armors.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\armor\GenericGeoArmorItem.java -----
package com.doomspire.grimfate.item.armor;

import net.minecraft.core.Holder;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ArmorMaterial;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import org.jetbrains.annotations.Nullable;

import software.bernie.geckolib.animatable.GeoItem;
import software.bernie.geckolib.animatable.client.GeoRenderProvider;
import software.bernie.geckolib.animatable.instance.AnimatableInstanceCache;
import software.bernie.geckolib.animation.AnimatableManager;
import software.bernie.geckolib.animation.AnimationController;
import software.bernie.geckolib.animation.PlayState;
import software.bernie.geckolib.constant.DefaultAnimations;
import software.bernie.geckolib.renderer.GeoArmorRenderer;
import software.bernie.geckolib.util.GeckoLibUtil;

import java.util.function.Consumer;

public class GenericGeoArmorItem extends ArmorItem implements GeoItem {
    // <— это нужно ModItems.copperVisual()
    public record Visual(net.minecraft.resources.ResourceLocation geo,
                         net.minecraft.resources.ResourceLocation texture) {}

    private final Visual visual;
    private final AnimatableInstanceCache cache = GeckoLibUtil.createInstanceCache(this);

    public GenericGeoArmorItem(Holder<ArmorMaterial> material, Type type, Properties props, Visual visual) {
        super(material, type, props);
        this.visual = visual;
    }

    public Visual visual() { return visual; }

    @Override
    public AnimatableInstanceCache getAnimatableInstanceCache() { return cache; }

    // Новый API GeckoLib 4.5+: регистрируем провайдера рендера брони
    @Override
    public void createGeoRenderer(Consumer<GeoRenderProvider> consumer) {
        consumer.accept(new GeoRenderProvider() {
            private GeoArmorRenderer<?> renderer;

            @Override
            public <T extends LivingEntity> net.minecraft.client.model.HumanoidModel<?> getGeoArmorRenderer(
                    @Nullable T living, ItemStack stack, @Nullable EquipmentSlot slot,
                    @Nullable net.minecraft.client.model.HumanoidModel<T> original) {
                if (renderer == null) {
                    renderer = new com.doomspire.grimfate.client.render.armor.BaseArmorRenderer();
                }
                return renderer;
            }
        });
    }

    @Override
    public void registerControllers(AnimatableManager.ControllerRegistrar controllers) {
        controllers.add(new AnimationController<>(this, 20, state -> {
            // базовая "idle" анимация предмета брони — если будет нужна
            state.setAnimation(DefaultAnimations.IDLE);

            // Правка: armorSlots есть только у LivingEntity
            var e = state.getData(software.bernie.geckolib.constant.DataTickets.ENTITY);
            if (!(e instanceof LivingEntity living)) return PlayState.STOP;

            // Можно включать всегда, либо доделать проверку полного сета позже
            for (ItemStack s : living.getArmorSlots()) {
                // no-op: проверка на пустоту при желании
            }
            return PlayState.CONTINUE;
        }));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\armor\GenericGeoArmorItem.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\BaseBowItem.java -----
package com.doomspire.grimfate.item;

import net.minecraft.world.item.BowItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.UseAnim;

//NOTE: База для всех луков Grimfate
/**
 * Поведение:
 * - Стрельба, натяжение, зачарования (Infinity и т.п.) — как у ванильного BowItem.
 * - Визуальные стадии натяжения (pull0/1/2) настраиваются ТОЛЬКО ресурсами (JSON overrides).
 * - 3D-в руках и 2D-в инвентаре задаются через loader "neoforge:separate_transforms".
 *
 * Зачем класс:
 * - Точка для будущих расширений (подключение WeaponProfileComponent, статов, перков).
 * - Единый тип для наших реестров/тегов (если понадобится специфичное поведение позже).
 */
public class BaseBowItem extends BowItem {
    public BaseBowItem(Properties props) { super(props); }

    @Override
    public UseAnim getUseAnimation(ItemStack stack) {
        // Оставляем анимацию как у обычного лука (нужно для предикатов "pull"/"pulling")
        return UseAnim.BOW;
    }

    // Если понадобится — здесь будет хук под WeaponProfileComponent/аффиксы/прочее.
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\BaseBowItem.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\AffixListComponent.java -----
package com.doomspire.grimfate.item.comp;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.ArrayList;
import java.util.List;

/** Хранилище выбранных аффиксов (id + роллы). Эффекты подключим позже. */
public record AffixListComponent(List<Entry> entries) {

    public record Entry(String id, List<Float> rolls) {
        public static final Codec<Entry> CODEC = RecordCodecBuilder.create(i -> i.group(
                Codec.STRING.fieldOf("id").forGetter(Entry::id),
                Codec.FLOAT.listOf().fieldOf("rolls").forGetter(Entry::rolls)
        ).apply(i, Entry::new));
    }

    public static final Codec<AffixListComponent> CODEC =
            Entry.CODEC.listOf().xmap(AffixListComponent::new, AffixListComponent::entries);

    /** Для сетевой синхронизации data-component. */
    public static final StreamCodec<RegistryFriendlyByteBuf, AffixListComponent> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public AffixListComponent decode(RegistryFriendlyByteBuf buf) {
                    int n = buf.readVarInt();
                    List<Entry> list = new ArrayList<>(n);
                    for (int i = 0; i < n; i++) {
                        String id = buf.readUtf();
                        int m = buf.readVarInt();
                        List<Float> rolls = new ArrayList<>(m);
                        for (int j = 0; j < m; j++) rolls.add(buf.readFloat());
                        list.add(new Entry(id, rolls));
                    }
                    return new AffixListComponent(list);
                }
                @Override
                public void encode(RegistryFriendlyByteBuf buf, AffixListComponent v) {
                    List<Entry> list = v.entries();
                    buf.writeVarInt(list.size());
                    for (Entry e : list) {
                        buf.writeUtf(e.id());
                        List<Float> rolls = e.rolls();
                        buf.writeVarInt(rolls.size());
                        for (Float r : rolls) buf.writeFloat(r);
                    }
                }
            };
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\AffixListComponent.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\WeaponProfileComponent.java -----
package com.doomspire.grimfate.item.comp;

import com.doomspire.grimfate.combat.WeaponType;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

public record WeaponProfileComponent(
        WeaponType type,
        boolean twoHanded,
        float baseSpeed,
        float baseDamageMod,
        int affixSlots
) {
    public static final Codec<WeaponProfileComponent> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.STRING.xmap(WeaponType::valueOf, WeaponType::name).fieldOf("type").forGetter(WeaponProfileComponent::type),
            Codec.BOOL.fieldOf("two_handed").forGetter(WeaponProfileComponent::twoHanded),
            Codec.FLOAT.fieldOf("base_speed").forGetter(WeaponProfileComponent::baseSpeed),
            Codec.FLOAT.fieldOf("base_damage_mod").forGetter(WeaponProfileComponent::baseDamageMod),
            Codec.INT.fieldOf("affix_slots").forGetter(WeaponProfileComponent::affixSlots)
    ).apply(i, WeaponProfileComponent::new));

    /** Для сетевой синхронизации data-component (NeoForge 1.21.1). */
    public static final StreamCodec<RegistryFriendlyByteBuf, WeaponProfileComponent> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public WeaponProfileComponent decode(RegistryFriendlyByteBuf buf) {
                    WeaponType t = WeaponType.valueOf(buf.readUtf());
                    boolean two = buf.readBoolean();
                    float sp = buf.readFloat();
                    float dm = buf.readFloat();
                    int slots = buf.readVarInt();
                    return new WeaponProfileComponent(t, two, sp, dm, slots);
                }
                @Override
                public void encode(RegistryFriendlyByteBuf buf, WeaponProfileComponent v) {
                    buf.writeUtf(v.type().name());
                    buf.writeBoolean(v.twoHanded());
                    buf.writeFloat(v.baseSpeed());
                    buf.writeFloat(v.baseDamageMod());
                    buf.writeVarInt(v.affixSlots());
                }
            };
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\WeaponProfileComponent.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\jewelry\Jewelry.java -----
package com.doomspire.grimfate.item.jewelry;

import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.world.item.Item;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;

//NOTE: Подмодуль регистрации бижутерии (Curios-слоты).

public final class Jewelry {
    private Jewelry() {}

    // ===== Rings =====

    public static final DeferredHolder<Item, Item> COPPER_RING =
            ModItems.ITEMS.register("copper_ring",
                    () -> new Item(new Item.Properties().stacksTo(1)));

    public static final DeferredHolder<Item, Item> BRONZE_RING =
            ModItems.ITEMS.register("bronze_ring",
                    () -> new Item(new Item.Properties().stacksTo(1)));

    // ===== Amulets =====
    public static final DeferredHolder<Item, Item> COPPER_NECKLACE =
            ModItems.ITEMS.register("copper_necklace",
                    () -> new Item(new Item.Properties().stacksTo(1)));

    public static final DeferredHolder<Item, Item> BRONZE_NECKLACE =
            ModItems.ITEMS.register("bronze_necklace",
                    () -> new Item(new Item.Properties().stacksTo(1)));

    // ===== Belt =====
   // public static final DeferredHolder<Item, Item> LEATHER_BELT =
   //         ModItems.ITEMS.register("leather_belt",
   //                 () -> new Item(new Item.Properties().stacksTo(1)));

    /** Вызов из ModItems.init(modBus); регистрации статические. */
    public static void init(IEventBus modBus) {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\jewelry\Jewelry.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\materials\Materials.java -----
package com.doomspire.grimfate.item.materials;

import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.world.item.Item;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;

//NOTE: Подмодуль регистрации материалов крафта.

public final class Materials {
    private Materials() {}

    public static final DeferredHolder<Item, Item> FIBER =
            ModItems.ITEMS.register("fiber", () -> new Item(new Item.Properties()));

    public static final DeferredHolder<Item, Item> CANVAS_FABRIC =
            ModItems.ITEMS.register("canvas_fabric.json", () -> new Item(new Item.Properties()));

    public static final DeferredHolder<Item, Item> RAWHIDE =
            ModItems.ITEMS.register("rawhide", () -> new Item(new Item.Properties()));

    public static final DeferredHolder<Item, Item> PORK_FAT =
            ModItems.ITEMS.register("pork_fat", () -> new Item(new Item.Properties()));

    /** Вызов из ModItems.init(modBus) при необходимости; регистрации статические. */
    public static void init(IEventBus modBus) {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\materials\Materials.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java -----
package com.doomspire.grimfate.item;

import com.doomspire.grimfate.network.payload.C2SCastAutoBoltPayload;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResultHolder;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.UseAnim;
import net.minecraft.world.level.Level;
import net.neoforged.neoforge.network.PacketDistributor;

public class StaffItem extends Item {
    public StaffItem(Properties props) { super(props); }

    @Override
    public int getUseDuration(ItemStack stack, LivingEntity entity) {
        return 72000; // удержание ПКМ
    }

    @Override
    public UseAnim getUseAnimation(ItemStack stack) {
        // анимация «натягивания» как у лука, чтобы была понятна механика удержания
        return UseAnim.BOW;
    }

    @Override
    public InteractionResultHolder<ItemStack> use(Level level, Player player, InteractionHand hand) {
        player.startUsingItem(hand); // удержание ПКМ
        return InteractionResultHolder.consume(player.getItemInHand(hand));
    }

    private static long lastMsMain = 0, lastMsOff = 0;

    @Override
    public void onUseTick(Level level, LivingEntity entity, ItemStack stack, int remainingUseDuration) {
        if (!level.isClientSide) return;

        // нам нужна рука и рейтконтроль — только для игроков
        if (!(entity instanceof Player player)) return;
        InteractionHand hand = player.getUsedItemHand();
        if (hand == null) return;

        int elapsed = getUseDuration(stack, entity) - remainingUseDuration;
        if (elapsed <= 0) return;

        long now = System.currentTimeMillis();
        long last = (hand == InteractionHand.MAIN_HAND) ? lastMsMain : lastMsOff;
        if (now - last < 80) return; // ~каждые 5–6 тиков
        if (hand == InteractionHand.MAIN_HAND) lastMsMain = now; else lastMsOff = now;

        PacketDistributor.sendToServer(new C2SCastAutoBoltPayload(hand));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\weapons\Weapons.java -----
package com.doomspire.grimfate.item.weapons;

import com.doomspire.grimfate.item.BaseBowItem;
import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.world.item.Item;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;

//NOTE: Подмодуль регистрации оружия/щита. Объявляем RegistryObject/DeferredHolder. Сюда прокидываем новые пушки
/**
 * ВАЖНО: сам DeferredRegister<Item> хранится в ModItems.
 * Здесь мы только объявляем RegistryObject/DeferredHolder и регистрируем через ModItems.ITEMS.register(...).
 */
public final class Weapons {
    private Weapons() {}

    // ===== Оружие / щит (PHASE_PLAN) =====
    public static final DeferredHolder<Item, Item> COPPER_SWORD =
            ModItems.ITEMS.register("copper_sword",
                    () -> new Item(new Item.Properties().stacksTo(1)));

    public static final DeferredHolder<Item, Item> SCHOLAR_STAFF =
            ModItems.ITEMS.register("scholar_staff",
                    () -> new com.doomspire.grimfate.item.StaffItem(new Item.Properties().stacksTo(1)));

    public static final DeferredHolder<Item, Item> WEAKLING_BOW =
            ModItems.ITEMS.register("weakling_bow",
                    () -> new BaseBowItem(new Item.Properties().stacksTo(1)));

    public static final DeferredHolder<Item, Item> COPPERFORCED_SHIELD =
            ModItems.ITEMS.register("copperforced_shield",
                    () -> new Item(new Item.Properties().stacksTo(1)));

    /** Вызывается из ModItems.init(modBus) для явной инициализации подмодуля (на будущее). */
    public static void init(IEventBus modBus) {
        // Ничего: все регистрации делаются статически через ModItems.ITEMS.register(...)
        // Метод оставлен для единообразия вызовов из ModItems/Grimfate.
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\weapons\Weapons.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java -----
package com.doomspire.grimfate.loot;

import com.doomspire.grimfate.core.Grimfate;
import com.mojang.serialization.MapCodec;
import net.neoforged.neoforge.common.loot.IGlobalLootModifier;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.NeoForgeRegistries;

public final class ModLootModifiers {
    private ModLootModifiers() {}

    // Регистрируем КОДЕКИ модификаторов лута
    public static final DeferredRegister<MapCodec<? extends IGlobalLootModifier>> GLM_SERIALIZERS =
            DeferredRegister.create(NeoForgeRegistries.Keys.GLOBAL_LOOT_MODIFIER_SERIALIZERS, Grimfate.MODID);


    public static void init(net.neoforged.bus.api.IEventBus modBus) {
        GLM_SERIALIZERS.register(modBus);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\AutoBoltServer.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimfate.entity.BoltProjectileEntity;
import com.doomspire.grimcore.spell.autobolt.AutoBoltResult;
import com.doomspire.grimcore.spell.autobolt.AutoBoltService;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;

public final class AutoBoltServer {
    private AutoBoltServer() {}

    public static void tryCast(ServerPlayer sp, InteractionHand hand) {
        if (sp == null) return;

        ServerLevel level = sp.serverLevel();
        ItemStack used = sp.getItemInHand(hand);
        if (used.isEmpty()) return;

        // Все проверки/расходы делает сервис ядра
        AutoBoltResult result = AutoBoltService.computeAndConsume(sp, used);
        if (result == null || !result.ok()) {
            // при желании можно отправить локализованный отказ по result.reason()
            return;
        }

        // Спавним снаряд
        BoltProjectileEntity bolt = new BoltProjectileEntity(level, sp);
        bolt.shootFromRotation(sp, sp.getXRot(), sp.getYRot(), 0.0f, result.projectileSpeed(), 0.0f);
        level.addFreshEntity(bolt);

        // Кулдаун на использованный предмет
        Item usedItem = used.getItem();
        int cd = result.cooldownTicks();
        if (cd > 0) {
            sp.getCooldowns().addCooldown(usedItem, cd);
        }

        // Звук
        level.playSound(null, sp.getX(), sp.getY(), sp.getZ(),
                SoundEvents.WITHER_SHOOT, SoundSource.PLAYERS, 0.6f, 1.0f);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\AutoBoltServer.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.spell.GrimSpells;
import com.doomspire.grimcore.spell.api.CastResult;
import com.doomspire.grimcore.spell.api.SpellContext;
import com.doomspire.grimcore.spell.api.WeaponGate;
import com.doomspire.grimcore.spell.api.WeaponRequirement;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatEffects;
import com.doomspire.grimfate.network.payload.*;
import net.minecraft.client.Minecraft;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;
import net.neoforged.neoforge.network.handling.IPayloadContext;

public final class ModNetworking {
    private ModNetworking() {}
    private static boolean REGISTERED = false;

    public static void register(RegisterPayloadHandlersEvent e) {
        if (REGISTERED) return;
        REGISTERED = true;
        var reg = e.registrar("grimfate");

        reg.playToServer(C2SAllocatePointPayload.TYPE, C2SAllocatePointPayload.STREAM_CODEC,
                ModNetworking::handleAllocatePoint);

        reg.playToClient(S2CAllocateResultPayload.TYPE, S2CAllocateResultPayload.STREAM_CODEC,
                ModNetworking::handleAllocateResult);

        reg.playToServer(C2SCastSpellSlotPayload.TYPE, C2SCastSpellSlotPayload.STREAM_CODEC,
                ModNetworking::handleCastSpellSlot);

        // ПКМ авто-болт со стаффа
        reg.playToServer(C2SCastAutoBoltPayload.TYPE, C2SCastAutoBoltPayload.STREAM_CODEC, (msg, ctx) -> {
            ctx.enqueueWork(() -> {
                ServerPlayer sp = (ServerPlayer) ctx.player();
                if (sp == null) return;

                // Требуется посох (WeaponGate + локализация причины)
                var gate = WeaponGate.check(sp, WeaponRequirement.stavesOnly());
                if (!gate.ok) {
                    showGateFailure(sp, gate);
                    return;
                }

                // Ядро: ресурсы/кд/скорость
                var hand = gate.usedHand != null ? gate.usedHand : net.minecraft.world.InteractionHand.MAIN_HAND;
                var stack = sp.getItemInHand(hand);
                var result = com.doomspire.grimcore.spell.autobolt.AutoBoltService.computeAndConsume(sp, stack);
                if (!result.ok()) return;

                // Контент: прожектайл
                var proj = new com.doomspire.grimfate.entity.BoltProjectileEntity(sp.level(), sp);
                proj.shootForward(sp, result.projectileSpeed());
                sp.level().addFreshEntity(proj);

                // Звук
                sp.level().playSound(null, sp.getX(), sp.getY(), sp.getZ(),
                        SoundEvents.WITHER_SHOOT, SoundSource.PLAYERS, 0.6f, 1.0f);

                // КД — на предмет
                sp.getCooldowns().addCooldown(stack.getItem(), result.cooldownTicks());
            });
        });
    }

    public static void sendAllocatePoint(String attrId) {
        PacketDistributor.sendToServer(new C2SAllocatePointPayload(attrId));
    }

    // === handlers ===

    private static void handleAllocatePoint(C2SAllocatePointPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (att == null) return;

            Attributes attr = PlayerStatsAttachment.parseAttrId(msg.attributeId());
            if (attr == null) return;

            boolean ok = att.tryAllocatePoint(attr);
            int allocated = att.getAttribute(attr);
            int unspent   = att.getUnspentPoints();

            PacketDistributor.sendToPlayer(sp, new S2CAllocateResultPayload(attr.name(), allocated, unspent));

            att.markDirty();
            GrimcoreNetworking.syncPlayerStats(sp, att);

            // ядро-эффекты
            StatEffects.applyAll(sp);
        });
    }

    private static void handleAllocateResult(S2CAllocateResultPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            var mc = Minecraft.getInstance();
            if (mc.player == null) return;

            var att = mc.player.getData(ModAttachments.PLAYER_STATS.get());
            if (att != null) {
                Attributes attr = PlayerStatsAttachment.parseAttrId(msg.attributeId());
                if (attr != null) {
                    att.setAttribute(attr, msg.newAllocated());
                }
                att.setUnspentPoints(msg.unspent());
                att.markDirty();
            }
        });
    }

    private static void handleCastSpellSlot(C2SCastSpellSlotPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            int slot = msg.slot();
            if (slot < 0 || slot >= PlayerLoadoutAttachment.SLOTS) return;

            PlayerLoadoutAttachment loadout = sp.getData(ModAttachments.PLAYER_LOADOUT.get());
            if (loadout == null) return;
            if (loadout.getCooldown(slot) > 0) return;

            ResourceLocation spellId = loadout.get(slot);
            if (spellId == null) return;

            var spell = GrimSpells.get(spellId);
            if (spell == null) return;

            // Оружейные требования спелла
            var req = com.doomspire.grimfate.spell.SpellRequirements.require(spellId);
            if (req != null) {
                var gate = WeaponGate.check(sp, req);
                if (!gate.ok) {
                    showGateFailure(sp, gate);
                    return;
                }
            }

            var lvl = sp.serverLevel();
            var ctxSpell = new SpellContext(lvl, sp, slot, 0, 0, 0, null);

            int cost = Math.max(0, spell.manaCost(ctxSpell));
            int cd   = Math.max(0, spell.cooldownTicks(ctxSpell));

            var stats = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (stats == null) return;
            if (stats.getCurrentMana() < cost) return;

            CastResult result = spell.cast(ctxSpell);
            if (result == CastResult.OK) {
                stats.setCurrentMana(stats.getCurrentMana() - cost);
                stats.markDirty();
                GrimcoreNetworking.syncPlayerStats(sp, stats);

                loadout.setCooldown(slot, cd);
                sp.setData(ModAttachments.PLAYER_LOADOUT.get(), loadout);
            }
        });
    }

    public static void sendCastSpellSlot(int slot) {
        PacketDistributor.sendToServer(new C2SCastSpellSlotPayload(slot));
    }

    // === UX helper ===
    private static void showGateFailure(ServerPlayer sp, WeaponGate.Result gate) {
        if (gate.reasonKey != null) {
            sp.displayClientMessage(Component.translatable(gate.reasonKey), true);
        } else if (gate.reason != null && !gate.reason.isBlank()) {
            sp.displayClientMessage(Component.literal(gate.reason), true);
        } else {
            sp.displayClientMessage(Component.translatable("grimfate.msg.weapon_required"), true);
        }
        sp.level().playSound(null, sp.getX(), sp.getY(), sp.getZ(),
                SoundEvents.VILLAGER_NO, SoundSource.PLAYERS, 0.7f, 1.0f);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SAllocatePointPayload(String attributeId) implements CustomPacketPayload {
    public static final Type<C2SAllocatePointPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_allocate_point"));

    public static final StreamCodec<RegistryFriendlyByteBuf, C2SAllocatePointPayload> STREAM_CODEC =
            StreamCodec.composite(
                    ByteBufCodecs.STRING_UTF8, C2SAllocatePointPayload::attributeId,
                    C2SAllocatePointPayload::new
            );

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastAutoBoltPayload.java -----
package com.doomspire.grimfate.network.payload;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.InteractionHand;

public record C2SCastAutoBoltPayload(InteractionHand hand) implements CustomPacketPayload {
    public static final Type<C2SCastAutoBoltPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "c2s_cast_auto_bolt"));

    public static final StreamCodec<RegistryFriendlyByteBuf, C2SCastAutoBoltPayload> STREAM_CODEC =
            new StreamCodec<>() {
                @Override public C2SCastAutoBoltPayload decode(RegistryFriendlyByteBuf buf) {
                    return new C2SCastAutoBoltPayload(buf.readEnum(InteractionHand.class));
                }
                @Override public void encode(RegistryFriendlyByteBuf buf, C2SCastAutoBoltPayload v) {
                    buf.writeEnum(v.hand());
                }
            };

    @Override public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastAutoBoltPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SCastSpellSlotPayload(int slot) implements CustomPacketPayload {
    public static final Type<C2SCastSpellSlotPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_cast_spell_slot"));
    public static final StreamCodec<RegistryFriendlyByteBuf, C2SCastSpellSlotPayload> STREAM_CODEC =
            StreamCodec.of((buf, msg) -> ByteBufCodecs.VAR_INT.encode(buf, msg.slot),
                    buf -> new C2SCastSpellSlotPayload(ByteBufCodecs.VAR_INT.decode(buf)));

    @Override public Type<? extends CustomPacketPayload> type() { return TYPE; }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record S2CAllocateResultPayload(String attributeId, int newAllocated, int unspent)
        implements CustomPacketPayload {

    public static final Type<S2CAllocateResultPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "s2c_allocate_result"));

    public static final StreamCodec<RegistryFriendlyByteBuf, S2CAllocateResultPayload> STREAM_CODEC =
            StreamCodec.composite(
                    ByteBufCodecs.STRING_UTF8, S2CAllocateResultPayload::attributeId,
                    ByteBufCodecs.VAR_INT,    S2CAllocateResultPayload::newAllocated,
                    ByteBufCodecs.VAR_INT,    S2CAllocateResultPayload::unspent,
                    S2CAllocateResultPayload::new
            );

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\SpellCastClient.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimfate.network.payload.C2SCastAutoBoltPayload;
import net.minecraft.world.InteractionHand;
import net.neoforged.neoforge.network.PacketDistributor;

public final class SpellCastClient {
    private SpellCastClient() {}

    /** Вызов авто-болта с указанием руки (используется там, где не хочется лезть в Item.onUseTick). */
    public static void tryCastAutoBoltFromStaff(InteractionHand hand) {
        PacketDistributor.sendToServer(new C2SCastAutoBoltPayload(hand));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\SpellCastClient.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModArmorMaterials.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.Util;
import net.minecraft.core.Holder;
import net.minecraft.core.registries.Registries;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ArmorMaterial;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.crafting.Ingredient;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

public final class ModArmorMaterials {
    public static final DeferredRegister<ArmorMaterial> ARMOR_MATERIALS =
            DeferredRegister.create(Registries.ARMOR_MATERIAL, Grimfate.MODID);

    private static Map<ArmorItem.Type, Integer> def(int helm, int chest, int legs, int boots) {
        var m = new EnumMap<ArmorItem.Type, Integer>(ArmorItem.Type.class);
        m.put(ArmorItem.Type.HELMET, helm);
        m.put(ArmorItem.Type.CHESTPLATE, chest);
        m.put(ArmorItem.Type.LEGGINGS, legs);
        m.put(ArmorItem.Type.BOOTS, boots);
        return m;
    }
//TODO: Сбалансировать
    public static final DeferredHolder<ArmorMaterial, ArmorMaterial> COPPER = ARMOR_MATERIALS.register("copper",
            () -> new ArmorMaterial(
                    /* defense map */ def(2, 6, 5, 2),
                    /* enchantability */ 12,
                    /* equip sound (Holder) */ SoundEvents.ARMOR_EQUIP_GENERIC,
                    /* repair ingredient (Supplier) */ (Supplier<Ingredient>) () -> Ingredient.of(Items.COPPER_INGOT),
                    /* vanilla 2D layers (не нужны для GeckoLib) */ List.<ArmorMaterial.Layer>of(),
                    /* toughness */ 0.0f,
                    /* knockback  */ 0.0f
            ));

    public static final DeferredHolder<ArmorMaterial, ArmorMaterial> LINEN = ARMOR_MATERIALS.register(
            "linen", () -> new ArmorMaterial(
                    /* defense map */ def(2, 6, 5, 2),
                    /* enchantability */ 12,
                    /* equip sound (Holder) */ SoundEvents.ARMOR_EQUIP_GENERIC,
                    /* repair ingredient (Supplier) */ (Supplier<Ingredient>) () -> Ingredient.of(Items.COPPER_INGOT),
                    /* vanilla 2D layers (не нужны для GeckoLib) */ List.<ArmorMaterial.Layer>of(),
                    /* toughness */ 0.0f,
                    /* knockback  */ 0.0f
            ));

    public static final DeferredHolder<ArmorMaterial, ArmorMaterial> RAWHIDE = ARMOR_MATERIALS.register(
            "rawhide", () -> new ArmorMaterial(
                    /* defense map */ def(2, 6, 5, 2),
                    /* enchantability */ 12,
                    /* equip sound (Holder) */ SoundEvents.ARMOR_EQUIP_GENERIC,
                    /* repair ingredient (Supplier) */ (Supplier<Ingredient>) () -> Ingredient.of(Items.COPPER_INGOT),
                    /* vanilla 2D layers (не нужны для GeckoLib) */ List.<ArmorMaterial.Layer>of(),
                    /* toughness */ 0.0f,
                    /* knockback  */ 0.0f
            ));

    public static Holder<ArmorMaterial> copperHolder() {
        return COPPER.getDelegate();
    }
    public static Holder<ArmorMaterial> linenHolder() {
        return LINEN.getDelegate();
    }
    public static Holder<ArmorMaterial> rawhideHolder() {
        return RAWHIDE.getDelegate();
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModArmorMaterials.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModCurios.java -----
package com.doomspire.grimfate.registry;

import com.mojang.logging.LogUtils;
import org.slf4j.Logger;
import net.neoforged.fml.ModList;

//NOTE: Мост к Curios: проверка наличия, константы слотов, потенциальные хелперы
/**
 * Слоты в Curios 9.5.x регистрируются через data/curios/... (см. ресурсы нашего мода).
 */
public final class ModCurios {
    private static final Logger LOGGER = LogUtils.getLogger();

    public static final String SLOT_RING = "ring";
    public static final String SLOT_NECKLACE = "necklace";
    public static final String SLOT_BELT = "belt";

    private ModCurios() {}

    /** true, если Curios присутствует. */
    public static boolean isLoaded() {
        return ModList.get().isLoaded("curios");
    }

    /** Позвать из commonSetup для логов и ранней диагностики. */
    public static void init() {
        if (isLoaded()) {
            LOGGER.info("[Grimfate] Curios detected. Slot types are provided via data files (curios/slots).");
        } else {
            LOGGER.warn("[Grimfate] Curios NOT detected. Jewelry slots will be unavailable.");
        }
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModCurios.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModDataComponents.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.item.comp.AffixListComponent;
import com.doomspire.grimfate.item.comp.WeaponProfileComponent;
import net.minecraft.core.component.DataComponentType;
import net.minecraft.core.registries.Registries;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModDataComponents {
    private ModDataComponents() {}

    public static final DeferredRegister<DataComponentType<?>> DATA_COMPONENT_TYPES =
            DeferredRegister.create(Registries.DATA_COMPONENT_TYPE, Grimfate.MODID);

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<WeaponProfileComponent>> WEAPON_PROFILE =
            DATA_COMPONENT_TYPES.register("weapon_profile",
                    () -> DataComponentType.<WeaponProfileComponent>builder()
                            .persistent(WeaponProfileComponent.CODEC)
                            .networkSynchronized(WeaponProfileComponent.STREAM_CODEC)
                            .build());

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<AffixListComponent>> AFFIX_LIST =
            DATA_COMPONENT_TYPES.register("affix_list",
                    () -> DataComponentType.<AffixListComponent>builder()
                            .persistent(AffixListComponent.CODEC)
                            .networkSynchronized(AffixListComponent.STREAM_CODEC)
                            .build());

    public static void init(IEventBus modBus) {
        DATA_COMPONENT_TYPES.register(modBus);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModDataComponents.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.MobCategory;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModEntityTypes {
    private ModEntityTypes(){}

    public static final DeferredRegister<EntityType<?>> ENTITIES =
            DeferredRegister.create(Registries.ENTITY_TYPE, Grimfate.MODID);

    public static final DeferredHolder<EntityType<?>, EntityType<BoltProjectileEntity>> BOLT =
            ENTITIES.register("bolt", () -> EntityType.Builder
                    .<BoltProjectileEntity>of(BoltProjectileEntity::new, MobCategory.MISC)
                    .sized(0.25f, 0.25f)
                    .clientTrackingRange(64)
                    .updateInterval(2)
                    .build(Grimfate.MODID + ":bolt"));

    public static void init(IEventBus modBus) {
        ENTITIES.register(modBus);
    }
}



n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.item.Item;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredRegister;

//NOTE: Регистрация предметов grimfate из подмодулей

/**
 * Все конкретные предметы объявляются и регистрируются в подмодулях:
 *  - item/weapons/Weapons
 *  - item/armor/Armors
 *  - item/materials/Materials
 *  - item/jewelry/Jewelry
 */

public final class ModItems {
    private ModItems() {}

    public static final DeferredRegister<Item> ITEMS =
            DeferredRegister.create(Registries.ITEM, Grimfate.MODID);

    public static void init(IEventBus modBus) {
        ITEMS.register(modBus);
        // Подмодулям не требуется отдельный вызов — их поля регистрируются статически через ModItems.ITEMS
        // (Метод оставлен на будущее, если появится дополнительная логика инициализации.)
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItemTags.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.tags.TagKey;
import net.minecraft.world.item.Item;
//TODO: Привести к существующим в data тэгам, поправить WeaponPredicates.java
public final class ModItemTags {
    public static final TagKey<Item> MELEE_WEAPONS  = tag("melee_weapons");
    public static final TagKey<Item> STAVES         = tag("staves");
    public static final TagKey<Item> RANGED_WEAPONS = tag("ranged_weapons");
    public static final TagKey<Item> DAGGERS        = tag("daggers");
    public static final TagKey<Item> SHIELDS        = tag("shields");

    private static TagKey<Item> tag(String path) {
        return TagKey.create(Registries.ITEM, ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, path));
    }
    private ModItemTags() {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItemTags.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\spell\SpellRequirements.java -----
package com.doomspire.grimfate.spell;

import com.doomspire.grimcore.spell.api.WeaponRequirement;
import net.minecraft.resources.ResourceLocation;

/**
 * Централизованная таблица: какой спелл требует какое оружие.
 * На старте держим тут только то, что уже есть; позже расширим при добавлении новых спеллов.
 */
public final class SpellRequirements {
    private SpellRequirements() {}

    /**
     * Вернёт требования к оружию для указанного спелла, либо null если требований нет.
     */
    public static WeaponRequirement require(ResourceLocation spellId) {
        if (spellId == null) return null;

        // Примеры (раскомментировать/добавлять по мере готовности спеллов):
        // if (spellId.equals(ResourceLocation.fromNamespaceAndPath("grimfate", "hunter_mark"))) {
        //     return WeaponRequirement.builder().allowTag("grimfate:bows").build();
        // }
        // if (spellId.equals(ResourceLocation.fromNamespaceAndPath("grimfate", "mage_bolt"))) {
        //     return WeaponRequirement.builder().allowTag("grimfate:staves").build();
        // }

        return null; // по умолчанию — без требований
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\spell\SpellRequirements.java -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\copper_armor_set.geo.json -----
{
	"format_version": "1.12.0",
	"minecraft:geometry": [
		{
			"description": {
				"identifier": "geometry.copper_armor_set",
				"texture_width": 128,
				"texture_height": 128,
				"visible_bounds_width": 2,
				"visible_bounds_height": 3.5,
				"visible_bounds_offset": [0, 1.25, 0]
			},
			"bones": [
				{
					"name": "bipedHead",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorHead",
					"parent": "bipedHead",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-5, 29, -5], "size": [10, 4, 10], "pivot": [0, 31, 0], "rotation": [-7.5, 0, 0], "uv": [0, 0]},
						{"origin": [-1, 27, -6], "size": [2, 5, 1], "pivot": [0, 28, -5], "rotation": [-7.5, 0, 0], "uv": [38, 30]}
					]
				},
				{
					"name": "bipedBody",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorBody",
					"parent": "bipedBody",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-1.7, 18, -3], "size": [5, 5, 6], "pivot": [-0.7, 21, -2], "rotation": [0, 0, 45], "uv": [28, 37]},
						{"origin": [1.3, 14, -3], "size": [2, 2, 1], "pivot": [-0.7, 17, -2], "rotation": [0, 0, 45], "uv": [22, 43]},
						{"origin": [3, 10.75, -2.5], "size": [2, 14.25, 5], "pivot": [4, 23, 0], "rotation": [0, 0, 45], "uv": [0, 43]},
						{"origin": [-6.5, 23, -2.5], "size": [14.25, 2, 5], "pivot": [-5.5, 23, 0], "rotation": [0, 0, 45], "uv": [0, 30]},
						{"origin": [-4.5, 13, -2.5], "size": [9.25, 1, 5], "uv": [0, 37]}
					]
				},
				{
					"name": "bipedRightArm",
					"pivot": [-5, 22, 0]
				},
				{
					"name": "armorRightArm",
					"parent": "bipedRightArm",
					"pivot": [-5, 22, 0]
				},
				{
					"name": "bipedLeftArm",
					"pivot": [5, 22, 0]
				},
				{
					"name": "armorLeftArm",
					"parent": "bipedLeftArm",
					"pivot": [5, 22, 0]
				},
				{
					"name": "bipedLeftLeg",
					"pivot": [2, 12, 0]
				},
				{
					"name": "armorLeftLeg",
					"parent": "bipedLeftLeg",
					"pivot": [2, 12, 0],
					"cubes": [
						{"origin": [0.25, 6, -3], "size": [2, 2, 2], "pivot": [1.25, 6, -2], "rotation": [0, 0, 45], "uv": [40, 8]},
						{"origin": [-0.5, 5.75, -2.5], "size": [5, 2, 5], "uv": [56, 16]}
					]
				},
				{
					"name": "armorLeftBoot",
					"parent": "bipedLeftLeg",
					"pivot": [2, 12, 0],
					"cubes": [
						{"origin": [-0.5, 0, -3.5], "size": [5, 2, 6], "uv": [56, 8]}
					]
				},
				{
					"name": "bipedRightLeg",
					"pivot": [-2, 12, 0]
				},
				{
					"name": "armorRightLeg",
					"parent": "bipedRightLeg",
					"pivot": [-2, 12, 0],
					"cubes": [
						{"origin": [-3.75, 6, -3], "size": [2, 2, 2], "pivot": [-2.75, 6, -2], "rotation": [0, 0, 45], "uv": [40, 8]},
						{"origin": [-4.5, 5.75, -2.5], "size": [5, 2, 5], "uv": [56, 16]}
					]
				},
				{
					"name": "armorRightBoot",
					"parent": "bipedRightLeg",
					"pivot": [-2, 12, 0],
					"cubes": [
						{"origin": [-4.5, 0, -3.5], "size": [5, 2, 6], "uv": [56, 8]}
					]
				}
			]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\copper_armor_set.geo.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\linen_armor_set.geo.json -----
{
	"format_version": "1.12.0",
	"minecraft:geometry": [
		{
			"description": {
				"identifier": "geometry.linen_armor_set",
				"texture_width": 128,
				"texture_height": 128,
				"visible_bounds_width": 3,
				"visible_bounds_height": 3.5,
				"visible_bounds_offset": [0, 1.25, 0]
			},
			"bones": [
				{
					"name": "bipedHead",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorHead",
					"parent": "bipedHead",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-6, 28, -6], "size": [12, 2, 12], "pivot": [0, 28, 0], "rotation": [-5, 0, 0], "uv": [0, 0]},
						{"origin": [-4.5, 30, -4.25], "size": [9, 4, 9], "pivot": [0, 31, -0.25], "rotation": [-5, 0, 0], "uv": [0, 14]}
					]
				},
				{
					"name": "bipedBody",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorBody",
					"parent": "bipedBody",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-5.5, 23, -3], "size": [11, 3, 8], "pivot": [0, 24, 4], "rotation": [7.5, 0, 0], "uv": [0, 27]},
						{"origin": [-5, 12, 1.25], "size": [10, 11, 3], "pivot": [0, 19, 2.25], "rotation": [7.5, 0, 0], "uv": [32, 45]},
						{"origin": [-4.5, 11.75, -2.5], "size": [9, 11.25, 5], "uv": [38, 14]}
					]
				},
				{
					"name": "bipedRightArm",
					"pivot": [-5, 22, 0]
				},
				{
					"name": "armorRightArm",
					"parent": "bipedRightArm",
					"pivot": [-5, 22, 0],
					"cubes": [
						{"origin": [-8.5, 16, -2.5], "size": [4.5, 8.5, 5], "uv": [62, 29]}
					]
				},
				{
					"name": "bipedLeftArm",
					"pivot": [5, 22, 0]
				},
				{
					"name": "armorLeftArm",
					"parent": "bipedLeftArm",
					"pivot": [30, 22, 0],
					"cubes": [
						{"origin": [4, 16, -2.5], "size": [4.5, 8.5, 5], "uv": [0, 67]}
					]
				},
				{
					"name": "bipedLeftLeg",
					"pivot": [2, 12, 0]
				},
				{
					"name": "armorLeftLeg",
					"parent": "bipedLeftLeg",
					"pivot": [6, 12, 0],
					"cubes": [
						{"origin": [-0.5, 4.75, -2.5], "size": [5, 8, 5], "uv": [0, 54]}
					]
				},
				{
					"name": "armorLeftBoot",
					"parent": "bipedLeftLeg",
					"pivot": [6, 12, 0],
					"cubes": [
						{"origin": [-0.5, -0.25, -3.5], "size": [5, 3, 6], "uv": [68, 0]}
					]
				},
				{
					"name": "bipedRightLeg",
					"pivot": [-2, 12, 0]
				},
				{
					"name": "armorRightLeg",
					"parent": "bipedRightLeg",
					"pivot": [-6, 12, 0],
					"cubes": [
						{"origin": [-4.5, 4.75, -2.5], "size": [5, 8, 5], "uv": [0, 54]}
					]
				},
				{
					"name": "armorRightBoot",
					"parent": "bipedRightLeg",
					"pivot": [-6, 2, 0],
					"cubes": [
						{"origin": [-4.5, -0.25, -3.5], "size": [5, 3, 6], "uv": [68, 0]}
					]
				}
			]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\linen_armor_set.geo.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\rawhide_armor_set.geo.json -----
{
	"format_version": "1.12.0",
	"minecraft:geometry": [
		{
			"description": {
				"identifier": "geometry.rawhide_armor_set",
				"texture_width": 128,
				"texture_height": 128,
				"visible_bounds_width": 3,
				"visible_bounds_height": 3.5,
				"visible_bounds_offset": [0, 1.25, 0]
			},
			"bones": [
				{
					"name": "bipedHead",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorHead",
					"parent": "bipedHead",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-5, 23, -6], "size": [10, 11, 11], "pivot": [0, 32, 0], "rotation": [10, 0, 0], "uv": [0, 0]},
						{"origin": [-4.5, 29.5, 1.25], "size": [9, 5, 8], "pivot": [0, 29.5, 2.25], "rotation": [-22.5, 0, 0], "uv": [32, 22]}
					]
				},
				{
					"name": "bipedBody",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorBody",
					"parent": "bipedBody",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-4.5, 12, -2.5], "size": [9, 4, 5], "uv": [42, 0]},
						{"origin": [-5, 15, -1], "size": [10, 10, 5], "pivot": [-3.5, 16, 1], "rotation": [10, 0, 0], "uv": [32, 35]},
						{"origin": [-5, 15, -4], "size": [10, 9, 4], "pivot": [-3.5, 16, -1], "rotation": [-10, 0, 0], "uv": [0, 38]},
						{"origin": [-5, 10, -4], "size": [4, 4, 1], "pivot": [0, 10, -3], "rotation": [-22.5, 0, 0], "uv": [16, 60]},
						{"origin": [1, 10, -4], "size": [4, 4, 1], "pivot": [7, 10, -3], "rotation": [-22.5, 0, 0], "uv": [66, 29]},
						{"origin": [-5.5, 12, -2.5], "size": [1, 4, 5], "pivot": [-9.5, 12, -3], "rotation": [0, 0, 22.5], "uv": [16, 51]},
						{"origin": [5.5, 8.5, -2.5], "size": [1, 4, 5], "pivot": [1.5, 8.5, -3], "rotation": [0, 0, -25], "uv": [60, 66]},
						{"origin": [-5, 10.5, 3], "size": [10, 4, 1], "pivot": [0, 10.5, 4], "rotation": [22.5, 0, 0], "uv": [62, 43]}
					]
				},
				{
					"name": "bipedRightArm",
					"pivot": [-5, 22, 0]
				},
				{
					"name": "armorRightArm",
					"parent": "bipedRightArm",
					"pivot": [-5, 22, 0],
					"cubes": [
						{"origin": [-9, 23, -3], "size": [5, 2, 6], "pivot": [-7, 22, 0], "rotation": [0, 0, -10], "uv": [62, 35]}
					]
				},
				{
					"name": "bipedLeftArm",
					"pivot": [5, 22, 0]
				},
				{
					"name": "armorLeftArm",
					"parent": "bipedLeftArm",
					"pivot": [5, 22, 0],
					"cubes": [
						{"origin": [4, 23, -3], "size": [5, 2, 6], "pivot": [7, 22, 0], "rotation": [0, 0, 10], "uv": [16, 66]}
					]
				},
				{
					"name": "bipedLeftLeg",
					"pivot": [2, 12, 0]
				},
				{
					"name": "armorLeftLeg",
					"parent": "bipedLeftLeg",
					"pivot": [6, 12, 0],
					"cubes": [
						{"origin": [-0.5, 5, -2.5], "size": [5, 7, 5], "uv": [62, 9]}
					]
				},
				{
					"name": "armorLeftBoot",
					"parent": "bipedLeftLeg",
					"pivot": [2, 4, 0],
					"cubes": [
						{"origin": [-0.5, 0, -3.5], "size": [5, 2, 6], "uv": [66, 21]}
					]
				},
				{
					"name": "bipedRightLeg",
					"pivot": [-2, 12, 0]
				},
				{
					"name": "armorRightLeg",
					"parent": "bipedRightLeg",
					"pivot": [-2, 12, 0],
					"cubes": [
						{"origin": [-4.5, 5, -2.5], "size": [5, 7, 5], "uv": [62, 9]}
					]
				},
				{
					"name": "armorRightBoot",
					"parent": "bipedRightLeg",
					"pivot": [-8, 4, 0],
					"cubes": [
						{"origin": [-4.5, 0, -3.5], "size": [5, 2, 6], "uv": [66, 21]}
					]
				}
			]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\rawhide_armor_set.geo.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\lang\en_us.json -----
{
  "key.categories.grimfate": "Grimfate",
  "key.grimfate.open_stats": "Open Stats",

  "key.grimfate.spellslot_1": "Spell Slot 1",
  "key.grimfate.spellslot_2": "Spell Slot 2",
  "key.grimfate.spellslot_3": "Spell Slot 3",
  "key.grimfate.spellslot_4": "Spell Slot 4",
  "key.grimfate.spellslot_5": "Spell Slot 5",
  "key.grimfate.spellslot_6": "Spell Slot 6",

  "screen.grimfate.stats_hub": "Attributes",
  "screen.grimfate.unspent": "Unspent points: %s",

  "attr.grimfate.vitality": "Vitality",
  "attr.grimfate.strength": "Strength",
  "attr.grimfate.intelligence": "Intelligence",
  "attr.grimfate.spirit": "Spirit",
  "attr.grimfate.dexterity": "Dexterity",
  "attr.grimfate.evasion": "Evasion",

  "attr.tip.vitality": "Increases health and regen.",
  "attr.tip.strength": "Increases physical melee damage.",
  "attr.tip.intelligence": "Increases spell power.",
  "attr.tip.spirit": "Increases max mana and mana regen.",
  "attr.tip.dexterity": "Increases physical ranged damage.",
  "attr.tip.evasion": "Dodge chance.",

  "grimfate.ui.stats.open": "Open Attributes",

"item.grimfate.rusty_ring": "Rusty Ring"
}


n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\lang\en_us.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json -----
{
  "key.categories.grimfate": "GrimFate",
  "key.grimfate.open_stats": "Открыть характеристики",

  "key.grimfate.spellslot_1": "Слот умения 1",
  "key.grimfate.spellslot_2": "Слот умения 2",
  "key.grimfate.spellslot_3": "Слот умения 3",
  "key.grimfate.spellslot_4": "Слот умения 4",
  "key.grimfate.spellslot_5": "Слот умения 5",
  "key.grimfate.spellslot_6": "Слот умения 6",

  "screen.grimfate.stats_hub": "Attributes",
  "screen.grimfate.unspent": "Unspent points: %s",

  "attr.grimfate.vitality": "Vitality",
  "attr.grimfate.strength": "Strength",
  "attr.grimfate.intelligence": "Intelligence",
  "attr.grimfate.spirit": "Spirit",
  "attr.grimfate.dexterity": "Dexterity",
  "attr.grimfate.evasion": "Evasion",

  "attr.tip.vitality": "Increases health and regen.",
  "attr.tip.strength": "Increases physical melee damage.",
  "attr.tip.intelligence": "Increases spell power.",
  "attr.tip.spirit": "Increases max mana and mana regen.",
  "attr.tip.dexterity": "Increases physical ranged damage.",
  "attr.tip.evasion": "Dodge chance.",

  "grimfate.ui.stats.open": "Открыть атрибуты",

  "item.grimfate.rusty_ring": "Rusty Ring"
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\bronze_necklace.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/bronze_necklace"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\bronze_necklace.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\bronze_ring.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/bronze_ring"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\bronze_ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\canvas_fabric.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/canvas_fabric"
  }
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\canvas_fabric.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_boots.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_boots" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_boots.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_chestplate.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_chestplate" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_chestplate.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_helmet.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_helmet" } }

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_helmet.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_leggings.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_leggings" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_leggings.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_necklace.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/copper_necklace"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_necklace.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_ring.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/copper_ring"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword.json -----
{
  "parent": "minecraft:item/handheld",
  "loader": "neoforge:separate_transforms",
  "base":   { "parent": "grimfate:item/copper_sword_3d" },
  "perspectives": {
    "gui":    { "parent": "grimfate:item/copper_sword_2d" },
    "fixed":  { "parent": "grimfate:item/copper_sword_2d" },
    "ground": { "parent": "grimfate:item/copper_sword_2d" },
    "head":   { "parent": "grimfate:item/copper_sword_2d" }
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword_2d.json -----
{
  "parent": "minecraft:item/generated",
  "textures": {
    "layer0": "grimfate:item/copper_sword_2d"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword_2d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword_3d.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [32, 32],
	"textures": {
		"0": "grimfate:item/copper_sword_3d",
		"particle": "block/copper_sword_3d"
	},
	"elements": [
		{
			"from": [7, 0, 7],
			"to": [9, 2, 9],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 0, 7]},
			"faces": {
				"north": {"uv": [6, 6, 7, 7], "texture": "#0"},
				"east": {"uv": [0, 6.5, 1, 7.5], "texture": "#0"},
				"south": {"uv": [1.5, 6.5, 2.5, 7.5], "texture": "#0"},
				"west": {"uv": [3, 6.5, 4, 7.5], "texture": "#0"},
				"up": {"uv": [5.5, 7.5, 4.5, 6.5], "texture": "#0"},
				"down": {"uv": [8.5, 3, 7.5, 4], "texture": "#0"}
			}
		},
		{
			"from": [7.5, 2, 7.5],
			"to": [8.5, 6, 8.5],
			"rotation": {"angle": 0, "axis": "y", "origin": [6.5, 2, 6.5]},
			"faces": {
				"north": {"uv": [7.5, 4.5, 8, 6.5], "texture": "#0"},
				"east": {"uv": [6, 7.5, 6.5, 9.5], "texture": "#0"},
				"south": {"uv": [7, 7.5, 7.5, 9.5], "texture": "#0"},
				"west": {"uv": [0, 8, 0.5, 10], "texture": "#0"},
				"up": {"uv": [9.5, 3.5, 9, 3], "texture": "#0"},
				"down": {"uv": [4.5, 9, 4, 9.5], "texture": "#0"}
			}
		},
		{
			"from": [6, 6, 7],
			"to": [10, 7, 9],
			"rotation": {"angle": 0, "axis": "z", "origin": [10, 5, 6]},
			"faces": {
				"north": {"uv": [1, 8, 3, 8.5], "texture": "#0"},
				"east": {"uv": [1, 9, 2, 9.5], "texture": "#0"},
				"south": {"uv": [3.5, 8, 5.5, 8.5], "texture": "#0"},
				"west": {"uv": [2.5, 9, 3.5, 9.5], "texture": "#0"},
				"up": {"uv": [8, 1, 6, 0], "texture": "#0"},
				"down": {"uv": [8, 1.5, 6, 2.5], "texture": "#0"}
			}
		},
		{
			"from": [6.5, 7, 7.5],
			"to": [9.5, 19, 8.5],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 7, 6.5]},
			"faces": {
				"north": {"uv": [0, 0, 1.5, 6], "texture": "#0"},
				"east": {"uv": [4, 0, 4.5, 6], "texture": "#0"},
				"south": {"uv": [2, 0, 3.5, 6], "texture": "#0"},
				"west": {"uv": [5, 0, 5.5, 6], "texture": "#0"},
				"up": {"uv": [9.5, 7.5, 8, 7], "texture": "#0"},
				"down": {"uv": [9.5, 8, 8, 8.5], "texture": "#0"}
			}
		},
		{
			"from": [5.775, 19.2, 7.525],
			"to": [7.875, 21.3, 8.475],
			"rotation": {"angle": -45, "axis": "z", "origin": [5.9, 18.2, 14.4]},
			"faces": {
				"north": {"uv": [6, 3, 7, 4], "texture": "#0"},
				"east": {"uv": [8.5, 0, 9, 1], "texture": "#0"},
				"south": {"uv": [6, 4.5, 7, 5.5], "texture": "#0"},
				"west": {"uv": [8.5, 1.5, 9, 2.5], "texture": "#0"},
				"up": {"uv": [9.5, 5, 8.5, 4.5], "texture": "#0"},
				"down": {"uv": [9.5, 5.5, 8.5, 6], "texture": "#0"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"rotation": [0, 90, 0],
			"translation": [0, 2, 1]
		},
		"thirdperson_lefthand": {
			"rotation": [0, 90, 0],
			"translation": [0, 2, 1]
		},
		"firstperson_righthand": {
			"rotation": [0, 90, 0],
			"translation": [1.25, 3, -0.25]
		},
		"firstperson_lefthand": {
			"rotation": [0, 90, 0],
			"translation": [1.25, 3, -0.25]
		},
		"ground": {
			"rotation": [0, 0, 150],
			"translation": [0, 5, 0]
		},
		"gui": {
			"rotation": [0, 0, -45],
			"translation": [-1.25, -1.5, 0]
		},
		"fixed": {
			"rotation": [0, 0, 45],
			"translation": [1, -1, 0]
		}
	},
	"groups": [
		{
			"name": "copper_sword_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2, 3, 4]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_sword_3d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield.json -----
{
  "parent": "minecraft:item/handheld",
  "loader": "neoforge:separate_transforms",
  "base":   { "parent": "grimfate:item/copperforced_shield_3d" },
  "perspectives": {
    "gui":    { "parent": "grimfate:item/copperforced_shield_2d" },
    "fixed":  { "parent": "grimfate:item/copperforced_shield_2d" },
    "ground": { "parent": "grimfate:item/copperforced_shield_2d" },
    "head":   { "parent": "grimfate:item/copperforced_shield_2d" }
  }
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield_2d.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/copperforced_shield_2d"
  }
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield_2d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield_3d.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [64, 64],
	"textures": {
		"0": "grimfate:item/copperforced_shield_3d",
		"particle": "block/copperforced_shield_3d"
	},
	"elements": [
		{
			"from": [2, 2, 7],
			"to": [14, 14, 9],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 0, 7]},
			"faces": {
				"north": {"uv": [4, 0, 7, 3], "texture": "#0"},
				"east": {"uv": [4, 6, 4.5, 9], "texture": "#0"},
				"south": {"uv": [4, 3, 7, 6], "texture": "#0"},
				"west": {"uv": [4.5, 6, 5, 9], "texture": "#0"},
				"up": {"uv": [8, 6.5, 5, 6], "texture": "#0"},
				"down": {"uv": [8, 6.5, 5, 7], "texture": "#0"}
			}
		},
		{
			"from": [5.55, 7, 6],
			"to": [9.55, 11, 8],
			"rotation": {"angle": -45, "axis": "z", "origin": [6.6, 8, 6]},
			"faces": {
				"north": {"uv": [7, 0, 8, 1], "texture": "#0"},
				"east": {"uv": [7, 4.5, 7.5, 5.5], "texture": "#0"},
				"south": {"uv": [7, 1, 8, 2], "texture": "#0"},
				"west": {"uv": [5, 7, 5.5, 8], "texture": "#0"},
				"up": {"uv": [6.5, 7.5, 5.5, 7], "texture": "#0"},
				"down": {"uv": [8, 5.5, 7, 6], "texture": "#0"}
			}
		},
		{
			"from": [7.5, 5.5, 9],
			"to": [8.5, 10.5, 12],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 9, 9]},
			"faces": {
				"north": {"uv": [6.5, 7, 6.75, 8.25], "texture": "#0"},
				"east": {"uv": [7, 2, 7.75, 3.25], "texture": "#0"},
				"south": {"uv": [6.75, 7, 7, 8.25], "texture": "#0"},
				"west": {"uv": [7, 3.25, 7.75, 4.5], "texture": "#0"},
				"up": {"uv": [7.25, 7.75, 7, 7], "texture": "#0"},
				"down": {"uv": [7.5, 7, 7.25, 7.75], "texture": "#0"}
			}
		},
		{
			"from": [0, 0, 8],
			"to": [16, 16, 8],
			"rotation": {"angle": 0, "axis": "y", "origin": [0, 0, 8]},
			"faces": {
				"north": {"uv": [0, 0, 4, 4], "texture": "#0"},
				"east": {"uv": [0, 0, 0, 4], "texture": "#0"},
				"south": {"uv": [0, 4, 4, 8], "texture": "#0"},
				"west": {"uv": [0, 0, 0, 4], "texture": "#0"},
				"up": {"uv": [4, 0, 0, 0], "texture": "#0"},
				"down": {"uv": [4, 0, 0, 0], "texture": "#0"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"rotation": [0, -90, 0],
			"translation": [3, -2, 1.5]
		},
		"thirdperson_lefthand": {
			"rotation": [0, -90, 0],
			"translation": [3, -2, 1.5]
		},
		"firstperson_righthand": {
			"rotation": [23, 26, 30],
			"translation": [2, -3, -2]
		},
		"firstperson_lefthand": {
			"rotation": [17, -21, 12],
			"translation": [2, -3.5, -2]
		},
		"ground": {
			"translation": [0, 3.5, 0]
		},
		"gui": {
			"rotation": [-26, -138, -5],
			"scale": [0.9, 0.9, 0.9]
		},
		"head": {
			"translation": [0, 0, -6.5]
		},
		"fixed": {
			"translation": [0, 0, -5],
			"scale": [4, 4, 4]
		}
	},
	"groups": [
		{
			"name": "copperforced_shield_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2, 3]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copperforced_shield_3d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\fiber.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/fiber"
  }
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\fiber.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_cape.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/linen_cape" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_cape.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_hat.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/linen_hat" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_hat.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_pants.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/linen_pants" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_pants.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_shoes.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/linen_shoes" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\linen_shoes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\pork_fat.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/pork_fat"
  }
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\pork_fat.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/rawhide"
  }
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_boots.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/rawhide_boots" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_boots.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_hood.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/rawhide_hood" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_hood.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_jacket.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/rawhide_jacket" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_jacket.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_wraps.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/rawhide_wraps" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rawhide_wraps.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff.json -----
{
  "parent": "minecraft:item/handheld",
  "loader": "neoforge:separate_transforms",
  "base":   { "parent": "grimfate:item/scholar_staff_3d" },
  "perspectives": {
    "gui":    { "parent": "grimfate:item/scholar_staff_2d" },
    "fixed":  { "parent": "grimfate:item/scholar_staff_2d" },
    "ground": { "parent": "grimfate:item/scholar_staff_2d" },
    "head":   { "parent": "grimfate:item/scholar_staff_2d" }
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff_2d.json -----
{
  "parent": "minecraft:item/generated",
  "textures": {
    "layer0": "grimfate:item/scholar_staff_2d"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff_2d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff_3d.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [64, 64],
	"textures": {
		"0": "grimfate:item/scholar_staff_3d",
		"particle": "block/scholar_staff_3d"
	},
	"elements": [
		{
			"from": [7, 0, 7],
			"to": [9, 25, 9],
			"rotation": {"angle": 0, "axis": "x", "origin": [7, 0, 7]},
			"faces": {
				"north": {"uv": [5.5, 0, 6, 6.25], "texture": "#0"},
				"east": {"uv": [6.25, 0, 6.75, 6.25], "texture": "#0"},
				"south": {"uv": [5.5, 6.5, 6, 12.75], "texture": "#0"},
				"west": {"uv": [6.25, 6.5, 6.75, 12.75], "texture": "#0"},
				"up": {"uv": [7.5, 0.5, 7, 0], "texture": "#0"},
				"down": {"uv": [7.5, 0.75, 7, 1.25], "texture": "#0"}
			}
		},
		{
			"from": [3, 9, 8],
			"to": [13, 29, 8],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 22, 8]},
			"faces": {
				"north": {"uv": [0, 0, 2.5, 5], "texture": "#0"},
				"east": {"uv": [7, 1.5, 7, 6.5], "texture": "#0"},
				"south": {"uv": [2.75, 0, 5.25, 5], "texture": "#0"},
				"west": {"uv": [7, 6.75, 7, 11.75], "texture": "#0"},
				"up": {"uv": [9.75, 1.5, 7.25, 1.5], "texture": "#0"},
				"down": {"uv": [9.75, 1.75, 7.25, 1.75], "texture": "#0"}
			}
		},
		{
			"from": [8, 9, 3],
			"to": [8, 29, 13],
			"rotation": {"angle": 0, "axis": "y", "origin": [8, 22, 7]},
			"faces": {
				"north": {"uv": [7.25, 2, 7.25, 7], "texture": "#0"},
				"east": {"uv": [0, 5.25, 2.5, 10.25], "texture": "#0"},
				"south": {"uv": [7.25, 7.25, 7.25, 12.25], "texture": "#0"},
				"west": {"uv": [2.75, 5.25, 5.25, 10.25], "texture": "#0"},
				"up": {"uv": [7.5, 4.5, 7.5, 2], "texture": "#0"},
				"down": {"uv": [7.5, 4.75, 7.5, 7.25], "texture": "#0"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"rotation": [20, 0, 0],
			"translation": [-0.25, 0, 1.5]
		},
		"thirdperson_lefthand": {
			"rotation": [20, 0, 0],
			"translation": [-0.25, 0, 1.25]
		},
		"firstperson_righthand": {
			"rotation": [-10, 0, 0],
			"translation": [2, -2.5, 0]
		},
		"firstperson_lefthand": {
			"rotation": [-10, 0, 0],
			"translation": [2, -2.5, 0]
		},
		"ground": {
			"rotation": [30, 0, 0],
			"translation": [0, 4, 0]
		},
		"gui": {
			"rotation": [0, 0, -45],
			"translation": [-3.5, -3.75, 0]
		},
		"fixed": {
			"rotation": [0, 0, 45],
			"translation": [4, -3.75, -0.25]
		}
	},
	"groups": [
		{
			"name": "scholar_staff_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\scholar_staff_3d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow.json -----
{
  "parent": "minecraft:item/handheld",
  "loader": "neoforge:separate_transforms",
  "base":   {
    "parent": "grimfate:item/weakling_bow_3d"
  },
  "perspectives": {
    "gui":    { "parent": "grimfate:item/weakling_bow_2d" },
    "fixed":  { "parent": "grimfate:item/weakling_bow_2d" },
    "ground": { "parent": "grimfate:item/weakling_bow_2d" },
    "head":   { "parent": "grimfate:item/weakling_bow_2d" }
  },
  "overrides": [
    { "predicate": { "pull": 0.65, "pulling": 1 }, "model": "grimfate:item/weakling_bow_3dpull2" },
    { "predicate": { "pull": 0.10, "pulling": 1 }, "model": "grimfate:item/weakling_bow_3dpull1" },
    { "predicate": { "pulling": 1 },               "model": "grimfate:item/weakling_bow_3dpull0" }
  ]
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_2d.json -----
{
  "parent": "minecraft:item/generated",
  "textures": {
    "layer0": "grimfate:item/weakling_bow_2d"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_2d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3d.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [32, 32],
	"textures": {
		"0": "grimfate:item/weakling_bow_3d",
		"particle": "block/weakling_bow_3d"
	},
	"elements": [
		{
			"from": [7, 9, 6],
			"to": [9, 16, 8],
			"rotation": {"angle": 0, "axis": "x", "origin": [7, 9, 6]},
			"faces": {
				"north": {"uv": [0, 0, 1, 3.5], "texture": "#0"},
				"east": {"uv": [1.5, 0, 2.5, 3.5], "texture": "#0"},
				"south": {"uv": [3, 0, 4, 3.5], "texture": "#0"},
				"west": {"uv": [0, 4, 1, 7.5], "texture": "#0"},
				"up": {"uv": [11, 10, 10, 9], "texture": "#0"},
				"down": {"uv": [11, 10.5, 10, 11.5], "texture": "#0"}
			}
		},
		{
			"from": [7.1, 4.2, 7],
			"to": [8.9, 9.2, 9],
			"rotation": {"angle": -22.5, "axis": "x", "origin": [7, 7.2, 7]},
			"faces": {
				"north": {"uv": [5.5, 0, 6.5, 2.5], "texture": "#0"},
				"east": {"uv": [5.5, 3, 6.5, 5.5], "texture": "#0"},
				"south": {"uv": [5.5, 6, 6.5, 8.5], "texture": "#0"},
				"west": {"uv": [7, 0, 8, 2.5], "texture": "#0"},
				"up": {"uv": [1, 12, 0, 11], "texture": "#0"},
				"down": {"uv": [12.5, 0, 11.5, 1], "texture": "#0"}
			}
		},
		{
			"from": [7.35, -0.4, 9.2],
			"to": [8.65, 4.6, 10.7],
			"rotation": {"angle": -22.5, "axis": "x", "origin": [7, 2.6, 8.95]},
			"faces": {
				"north": {"uv": [8.5, 3, 9.25, 5.5], "texture": "#0"},
				"east": {"uv": [8.5, 6, 9.25, 8.5], "texture": "#0"},
				"south": {"uv": [5.5, 9, 6.25, 11.5], "texture": "#0"},
				"west": {"uv": [7, 9, 7.75, 11.5], "texture": "#0"},
				"up": {"uv": [12.25, 5.25, 11.5, 4.5], "texture": "#0"},
				"down": {"uv": [12.25, 6, 11.5, 6.75], "texture": "#0"}
			}
		},
		{
			"from": [7.1, 16, 6.3],
			"to": [8.9, 21, 8.3],
			"rotation": {"angle": 22.5, "axis": "x", "origin": [7, 16, 6.3]},
			"faces": {
				"north": {"uv": [7, 3, 8, 5.5], "texture": "#0"},
				"east": {"uv": [7, 6, 8, 8.5], "texture": "#0"},
				"south": {"uv": [0, 8, 1, 10.5], "texture": "#0"},
				"west": {"uv": [8.5, 0, 9.5, 2.5], "texture": "#0"},
				"up": {"uv": [12.5, 2.5, 11.5, 1.5], "texture": "#0"},
				"down": {"uv": [12.5, 3, 11.5, 4], "texture": "#0"}
			}
		},
		{
			"from": [7.35, 20.6, 8.45],
			"to": [8.65, 25.6, 9.95],
			"rotation": {"angle": 22.5, "axis": "x", "origin": [7, 20.6, 8.2]},
			"faces": {
				"north": {"uv": [8.5, 9, 9.25, 11.5], "texture": "#0"},
				"east": {"uv": [10, 0, 10.75, 2.5], "texture": "#0"},
				"south": {"uv": [10, 3, 10.75, 5.5], "texture": "#0"},
				"west": {"uv": [10, 6, 10.75, 8.5], "texture": "#0"},
				"up": {"uv": [12.25, 8.25, 11.5, 7.5], "texture": "#0"},
				"down": {"uv": [12.25, 9, 11.5, 9.75], "texture": "#0"}
			}
		},
		{
			"from": [7.75, 1, 11],
			"to": [8.25, 24, 11.5],
			"rotation": {"angle": 0, "axis": "y", "origin": [7.2, 0, 11]},
			"faces": {
				"north": {"uv": [1.5, 4, 1.75, 15.5], "texture": "#0"},
				"east": {"uv": [2.5, 4, 2.75, 15.5], "texture": "#0"},
				"south": {"uv": [3.5, 4, 3.75, 15.5], "texture": "#0"},
				"west": {"uv": [4.5, 0, 4.75, 11.5], "texture": "#0"},
				"up": {"uv": [11.75, 10.75, 11.5, 10.5], "texture": "#0"},
				"down": {"uv": [11.75, 11.5, 11.5, 11.75], "texture": "#0"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"thirdperson_lefthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"firstperson_righthand": {
			"rotation": [20, 15, -75],
			"translation": [-10, -1.25, -1.5]
		},
		"firstperson_lefthand": {
			"rotation": [20, -15, -75],
			"translation": [-6, 1.25, -5.75]
		},
		"ground": {
			"rotation": [40, 0, 0],
			"translation": [0, 3.75, 0]
		},
		"gui": {
			"rotation": [0, 90, 0],
			"translation": [0, -3.75, 0]
		},
		"fixed": {
			"rotation": [0, 90, 0],
			"translation": [-0.75, -4.25, 0]
		}
	},
	"groups": [
		{
			"name": "weakling_bow_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2, 3, 4, 5]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3d.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull0.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [32, 32],
	"textures": {
		"3": "grimfate:item/weakling_bow_3dpull0",
		"particle": "block/weakling_bow_3d"
	},
	"elements": [
		{
			"from": [7, 9, 6],
			"to": [9, 16, 8],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 9, 6]},
			"faces": {
				"north": {"uv": [6.5, 1, 7.5, 4.5], "texture": "#3"},
				"east": {"uv": [6.5, 4.5, 7.5, 8], "texture": "#3"},
				"south": {"uv": [7.5, 1, 8.5, 4.5], "texture": "#3"},
				"west": {"uv": [7.5, 4.5, 8.5, 8], "texture": "#3"},
				"up": {"uv": [12, 12, 11, 11], "texture": "#3"},
				"down": {"uv": [1, 11.5, 0, 12.5], "texture": "#3"}
			}
		},
		{
			"from": [7.1, 4.2, 7],
			"to": [8.9, 9.2, 9],
			"rotation": {"angle": -22.5, "axis": "x", "origin": [7, 7.2, 7]},
			"faces": {
				"north": {"uv": [6.5, 8, 7.5, 10.5], "texture": "#3"},
				"east": {"uv": [7.5, 8, 8.5, 10.5], "texture": "#3"},
				"south": {"uv": [8.5, 1, 9.5, 3.5], "texture": "#3"},
				"west": {"uv": [8.5, 3.5, 9.5, 6], "texture": "#3"},
				"up": {"uv": [2, 12.5, 1, 11.5], "texture": "#3"},
				"down": {"uv": [12.5, 1, 11.5, 2], "texture": "#3"}
			}
		},
		{
			"from": [7.35, 0.1, 9.7],
			"to": [8.65, 5.1, 11.2],
			"rotation": {"angle": -45, "axis": "x", "origin": [7, 3.1, 9.45]},
			"faces": {
				"north": {"uv": [9.5, 6, 10.25, 8.5], "texture": "#3"},
				"east": {"uv": [9.5, 8.5, 10.25, 11], "texture": "#3"},
				"south": {"uv": [10.5, 1, 11.25, 3.5], "texture": "#3"},
				"west": {"uv": [10.5, 3.5, 11.25, 6], "texture": "#3"},
				"up": {"uv": [3.75, 12.25, 3, 11.5], "texture": "#3"},
				"down": {"uv": [12.25, 3, 11.5, 3.75], "texture": "#3"}
			}
		},
		{
			"from": [7.1, 16, 6.3],
			"to": [8.9, 21, 8.3],
			"rotation": {"angle": 22.5, "axis": "x", "origin": [7, 16, 6.3]},
			"faces": {
				"north": {"uv": [8.5, 6, 9.5, 8.5], "texture": "#3"},
				"east": {"uv": [8.5, 8.5, 9.5, 11], "texture": "#3"},
				"south": {"uv": [9.5, 1, 10.5, 3.5], "texture": "#3"},
				"west": {"uv": [9.5, 3.5, 10.5, 6], "texture": "#3"},
				"up": {"uv": [3, 12.5, 2, 11.5], "texture": "#3"},
				"down": {"uv": [12.5, 2, 11.5, 3], "texture": "#3"}
			}
		},
		{
			"from": [7.35, 20.6, 8.45],
			"to": [8.65, 25.6, 9.95],
			"rotation": {"angle": 45, "axis": "x", "origin": [7, 20.6, 8.2]},
			"faces": {
				"north": {"uv": [6, 10.5, 6.75, 13], "texture": "#3"},
				"east": {"uv": [10.5, 6, 11.25, 8.5], "texture": "#3"},
				"south": {"uv": [7, 10.5, 7.75, 13], "texture": "#3"},
				"west": {"uv": [10.5, 8.5, 11.25, 11], "texture": "#3"},
				"up": {"uv": [4.75, 12.25, 4, 11.5], "texture": "#3"},
				"down": {"uv": [12.25, 4, 11.5, 4.75], "texture": "#3"}
			}
		},
		{
			"from": [8, 1, 10],
			"to": [8, 24, 16],
			"rotation": {"angle": 0, "axis": "y", "origin": [6, 11, 10]},
			"faces": {
				"north": {"uv": [0, 0, 0, 11.5], "texture": "#3"},
				"east": {"uv": [0, 0, 3, 11.5], "texture": "#3"},
				"south": {"uv": [0, 0, 0, 11.5], "texture": "#3"},
				"west": {"uv": [3, 0, 6, 11.5], "texture": "#3"},
				"up": {"uv": [0, 3, 0, 0], "texture": "#3"},
				"down": {"uv": [0, 0, 0, 3], "texture": "#3"}
			}
		},
		{
			"from": [7.5, 12.5, -1],
			"to": [8.5, 13.5, 15],
			"rotation": {"angle": 0, "axis": "y", "origin": [6.5, 12.5, 6]},
			"faces": {
				"north": {"uv": [6, 9, 6.5, 9.5], "texture": "#3"},
				"east": {"uv": [6, 0, 14, 0.5], "texture": "#3"},
				"south": {"uv": [6, 9, 6.5, 9.5], "texture": "#3"},
				"west": {"uv": [6, 0.5, 14, 1], "texture": "#3"},
				"up": {"uv": [6.5, 9, 6, 1], "texture": "#3"},
				"down": {"uv": [6, 1, 6.5, 9], "texture": "#3"}
			}
		},
		{
			"from": [8, 12, -3],
			"to": [8, 14, 0],
			"rotation": {"angle": 0, "axis": "y", "origin": [6, 12, -3]},
			"faces": {
				"north": {"uv": [0, 0, 0, 1], "texture": "#3"},
				"east": {"uv": [8, 11, 9.5, 12], "texture": "#3"},
				"south": {"uv": [0, 0, 0, 1], "texture": "#3"},
				"west": {"uv": [9.5, 11, 11, 12], "texture": "#3"},
				"up": {"uv": [0, 1.5, 0, 0], "texture": "#3"},
				"down": {"uv": [0, 0, 0, 1.5], "texture": "#3"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"thirdperson_lefthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"firstperson_righthand": {
			"rotation": [26, 21, -74],
			"translation": [-10, -1.25, -1.5]
		},
		"firstperson_lefthand": {
			"rotation": [20, -15, -75],
			"translation": [-6, 1.25, -5.75]
		},
		"ground": {
			"rotation": [40, 0, 0],
			"translation": [0, 3.75, 0]
		},
		"gui": {
			"rotation": [0, 90, 0],
			"translation": [0, -3.75, 0]
		},
		"fixed": {
			"rotation": [0, 90, 0],
			"translation": [-0.75, -4.25, 0]
		}
	},
	"groups": [
		{
			"name": "weakling_bow_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2, 3, 4, 5, 6, 7]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull0.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull1.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [64, 64],
	"textures": {
		"3": "grimfate:item/weakling_bow_3dpull1",
		"particle": "block/weakling_bow_3d"
	},
	"elements": [
		{
			"from": [7, 9, 6],
			"to": [9, 16, 8],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 9, 6]},
			"faces": {
				"north": {"uv": [4.5, 5.25, 5, 7], "texture": "#3"},
				"east": {"uv": [5.25, 5.25, 5.75, 7], "texture": "#3"},
				"south": {"uv": [0, 5.5, 0.5, 7.25], "texture": "#3"},
				"west": {"uv": [0.75, 5.5, 1.25, 7.25], "texture": "#3"},
				"up": {"uv": [4.25, 7.5, 3.75, 7], "texture": "#3"},
				"down": {"uv": [7.5, 7, 7, 7.5], "texture": "#3"}
			}
		},
		{
			"from": [7.1, 4.7, 8],
			"to": [8.9, 9.7, 10],
			"rotation": {"angle": -45, "axis": "x", "origin": [7, 7.7, 8]},
			"faces": {
				"north": {"uv": [5.5, 1, 6, 2.25], "texture": "#3"},
				"east": {"uv": [1.5, 5.5, 2, 6.75], "texture": "#3"},
				"south": {"uv": [2.25, 5.5, 2.75, 6.75], "texture": "#3"},
				"west": {"uv": [5.5, 2.5, 6, 3.75], "texture": "#3"},
				"up": {"uv": [5, 7.75, 4.5, 7.25], "texture": "#3"},
				"down": {"uv": [5.75, 7.25, 5.25, 7.75], "texture": "#3"}
			}
		},
		{
			"from": [7.35, 1.6, 11.45],
			"to": [8.65, 6.6, 12.95],
			"rotation": {"angle": -45, "axis": "x", "origin": [7, 4.6, 11.2]},
			"faces": {
				"north": {"uv": [6.25, 1, 6.625, 2.25], "texture": "#3"},
				"east": {"uv": [6.25, 2.5, 6.625, 3.75], "texture": "#3"},
				"south": {"uv": [6.75, 4, 7.125, 5.25], "texture": "#3"},
				"west": {"uv": [6.75, 5.5, 7.125, 6.75], "texture": "#3"},
				"up": {"uv": [7.875, 4.375, 7.5, 4], "texture": "#3"},
				"down": {"uv": [7.875, 4.75, 7.5, 5.125], "texture": "#3"}
			}
		},
		{
			"from": [7.1, 16, 6.3],
			"to": [8.9, 21, 8.3],
			"rotation": {"angle": 45, "axis": "x", "origin": [7, 16, 6.3]},
			"faces": {
				"north": {"uv": [3, 5.5, 3.5, 6.75], "texture": "#3"},
				"east": {"uv": [3.75, 5.5, 4.25, 6.75], "texture": "#3"},
				"south": {"uv": [6, 4, 6.5, 5.25], "texture": "#3"},
				"west": {"uv": [6, 5.5, 6.5, 6.75], "texture": "#3"},
				"up": {"uv": [0.5, 8, 0, 7.5], "texture": "#3"},
				"down": {"uv": [1.25, 7.5, 0.75, 8], "texture": "#3"}
			}
		},
		{
			"from": [7.35, 17.6, 9.7],
			"to": [8.65, 19.1, 14.7],
			"rotation": {"angle": -45, "axis": "x", "origin": [7, 19.35, 9.7]},
			"faces": {
				"north": {"uv": [7.5, 5.5, 7.875, 5.875], "texture": "#3"},
				"east": {"uv": [7, 1, 8.25, 1.375], "texture": "#3"},
				"south": {"uv": [7.5, 6.25, 7.875, 6.625], "texture": "#3"},
				"west": {"uv": [1.5, 7, 2.75, 7.375], "texture": "#3"},
				"up": {"uv": [7.375, 3, 7, 1.75], "texture": "#3"},
				"down": {"uv": [3.375, 7, 3, 8.25], "texture": "#3"}
			}
		},
		{
			"from": [8, 2, 13],
			"to": [8, 23, 21],
			"rotation": {"angle": 0, "axis": "y", "origin": [6, 11, 14]},
			"faces": {
				"north": {"uv": [1.5, 7.75, 1.5, 13], "texture": "#3"},
				"east": {"uv": [0, 0, 2, 5.25], "texture": "#3"},
				"south": {"uv": [1.5, 7.75, 1.5, 13], "texture": "#3"},
				"west": {"uv": [2.25, 0, 4.25, 5.25], "texture": "#3"},
				"up": {"uv": [1.75, 9.75, 1.75, 7.75], "texture": "#3"},
				"down": {"uv": [1.75, 7.75, 1.75, 9.75], "texture": "#3"}
			}
		},
		{
			"from": [7.5, 12.5, 2],
			"to": [8.5, 13.5, 18],
			"rotation": {"angle": 0, "axis": "y", "origin": [6.5, 12.5, 9]},
			"faces": {
				"north": {"uv": [5.5, 4, 5.75, 4.25], "texture": "#3"},
				"east": {"uv": [4.5, 0, 8.5, 0.25], "texture": "#3"},
				"south": {"uv": [5.5, 4.5, 5.75, 4.75], "texture": "#3"},
				"west": {"uv": [4.5, 0.5, 8.5, 0.75], "texture": "#3"},
				"up": {"uv": [4.75, 5, 4.5, 1], "texture": "#3"},
				"down": {"uv": [5.25, 1, 5, 5], "texture": "#3"}
			}
		},
		{
			"from": [8, 12, 0],
			"to": [8, 14, 3],
			"rotation": {"angle": 0, "axis": "y", "origin": [6, 12, 0]},
			"faces": {
				"north": {"uv": [7.75, 1.75, 7.75, 2.25], "texture": "#3"},
				"east": {"uv": [7, 3.25, 7.75, 3.75], "texture": "#3"},
				"south": {"uv": [7.75, 1.75, 7.75, 2.25], "texture": "#3"},
				"west": {"uv": [6, 7, 6.75, 7.5], "texture": "#3"},
				"up": {"uv": [2, 8.5, 2, 7.75], "texture": "#3"},
				"down": {"uv": [2, 7.75, 2, 8.5], "texture": "#3"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"thirdperson_lefthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"firstperson_righthand": {
			"rotation": [26, 21, -74],
			"translation": [-10, -1.25, -1.5]
		},
		"firstperson_lefthand": {
			"rotation": [20, -15, -75],
			"translation": [-6, 1.25, -5.75]
		},
		"ground": {
			"rotation": [40, 0, 0],
			"translation": [0, 3.75, 0]
		},
		"gui": {
			"rotation": [0, 90, 0],
			"translation": [0, -3.75, 0]
		},
		"fixed": {
			"rotation": [0, 90, 0],
			"translation": [-0.75, -4.25, 0]
		}
	},
	"groups": [
		{
			"name": "weakling_bow_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2, 3, 4, 5, 6, 7]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull1.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull2.json -----
{
	"format_version": "1.9.0",
	"credit": "Made with Blockbench",
	"texture_size": [64, 64],
	"textures": {
		"2": "grimfate:item/weakling_bow_3dpull2",
		"particle": "block/weakling_bow_3d"
	},
	"elements": [
		{
			"from": [7, 9, 6],
			"to": [9, 16, 8],
			"rotation": {"angle": 0, "axis": "y", "origin": [7, 9, 6]},
			"faces": {
				"north": {"uv": [4.75, 4.75, 5.25, 6.5], "texture": "#2"},
				"east": {"uv": [0, 5, 0.5, 6.75], "texture": "#2"},
				"south": {"uv": [5, 0.5, 5.5, 2.25], "texture": "#2"},
				"west": {"uv": [0.75, 5, 1.25, 6.75], "texture": "#2"},
				"up": {"uv": [5.25, 7.25, 4.75, 6.75], "texture": "#2"},
				"down": {"uv": [7.5, 5, 7, 5.5], "texture": "#2"}
			}
		},
		{
			"from": [7.1, 4.7, 7.75],
			"to": [8.9, 9.7, 9.75],
			"rotation": {"angle": -45, "axis": "x", "origin": [7, 7.7, 7.75]},
			"faces": {
				"north": {"uv": [1.5, 5, 2, 6.25], "texture": "#2"},
				"east": {"uv": [2.25, 5, 2.75, 6.25], "texture": "#2"},
				"south": {"uv": [5, 2.5, 5.5, 3.75], "texture": "#2"},
				"west": {"uv": [3, 5, 3.5, 6.25], "texture": "#2"},
				"up": {"uv": [6, 7.5, 5.5, 7], "texture": "#2"},
				"down": {"uv": [7.5, 5.75, 7, 6.25], "texture": "#2"}
			}
		},
		{
			"from": [7.35, 5.1, 9.95],
			"to": [8.65, 6.6, 14.95],
			"rotation": {"angle": 22.5, "axis": "x", "origin": [7, 4.85, 11.95]},
			"faces": {
				"north": {"uv": [1, 7.25, 1.375, 7.625], "texture": "#2"},
				"east": {"uv": [6.25, 3.5, 7.5, 3.875], "texture": "#2"},
				"south": {"uv": [7.25, 1.25, 7.625, 1.625], "texture": "#2"},
				"west": {"uv": [6.25, 4.25, 7.5, 4.625], "texture": "#2"},
				"up": {"uv": [6.625, 6.25, 6.25, 5], "texture": "#2"},
				"down": {"uv": [6.875, 0.5, 6.5, 1.75], "texture": "#2"}
			}
		},
		{
			"from": [7.1, 16, 6.3],
			"to": [8.9, 21, 8.3],
			"rotation": {"angle": 45, "axis": "x", "origin": [7, 16, 6.3]},
			"faces": {
				"north": {"uv": [5.5, 4, 6, 5.25], "texture": "#2"},
				"east": {"uv": [5.5, 5.5, 6, 6.75], "texture": "#2"},
				"south": {"uv": [5.75, 0.5, 6.25, 1.75], "texture": "#2"},
				"west": {"uv": [5.75, 2, 6.25, 3.25], "texture": "#2"},
				"up": {"uv": [7.5, 7, 7, 6.5], "texture": "#2"},
				"down": {"uv": [7.75, 0.5, 7.25, 1], "texture": "#2"}
			}
		},
		{
			"from": [7.35, 17.85, 9.95],
			"to": [8.65, 19.35, 14.95],
			"rotation": {"angle": -22.5, "axis": "x", "origin": [7, 19.6, 9.95]},
			"faces": {
				"north": {"uv": [1.75, 7.25, 2.125, 7.625], "texture": "#2"},
				"east": {"uv": [1.5, 6.5, 2.75, 6.875], "texture": "#2"},
				"south": {"uv": [7, 7.25, 7.375, 7.625], "texture": "#2"},
				"west": {"uv": [6.5, 2, 7.75, 2.375], "texture": "#2"},
				"up": {"uv": [3.375, 7.75, 3, 6.5], "texture": "#2"},
				"down": {"uv": [6.625, 6.5, 6.25, 7.75], "texture": "#2"}
			}
		},
		{
			"from": [8, 4, 14],
			"to": [8, 21, 22],
			"rotation": {"angle": 0, "axis": "y", "origin": [6, 11, 18]},
			"faces": {
				"north": {"uv": [2.5, 7.25, 2.5, 11.5], "texture": "#2"},
				"east": {"uv": [0, 0, 2, 4.25], "texture": "#2"},
				"south": {"uv": [2.75, 7.25, 2.75, 11.5], "texture": "#2"},
				"west": {"uv": [2.25, 0, 4.25, 4.25], "texture": "#2"},
				"up": {"uv": [3.75, 9.25, 3.75, 7.25], "texture": "#2"},
				"down": {"uv": [4, 7.25, 4, 9.25], "texture": "#2"}
			}
		},
		{
			"from": [7.5, 12.5, 5],
			"to": [8.5, 13.5, 21],
			"rotation": {"angle": 0, "axis": "y", "origin": [6.5, 12.5, 12]},
			"faces": {
				"north": {"uv": [3.75, 5, 4, 5.25], "texture": "#2"},
				"east": {"uv": [0, 4.5, 4, 4.75], "texture": "#2"},
				"south": {"uv": [5, 4, 5.25, 4.25], "texture": "#2"},
				"west": {"uv": [4.5, 0, 8.5, 0.25], "texture": "#2"},
				"up": {"uv": [4.75, 4.5, 4.5, 0.5], "texture": "#2"},
				"down": {"uv": [4.5, 4.75, 4.25, 8.75], "texture": "#2"}
			}
		},
		{
			"from": [8, 12, 3],
			"to": [8, 14, 6],
			"rotation": {"angle": 0, "axis": "y", "origin": [6, 12, 3]},
			"faces": {
				"north": {"uv": [3.75, 5.5, 3.75, 6], "texture": "#2"},
				"east": {"uv": [6.5, 2.75, 7.25, 3.25], "texture": "#2"},
				"south": {"uv": [4, 5.5, 4, 6], "texture": "#2"},
				"west": {"uv": [0, 7, 0.75, 7.5], "texture": "#2"},
				"up": {"uv": [3.75, 7, 3.75, 6.25], "texture": "#2"},
				"down": {"uv": [4, 6.25, 4, 7], "texture": "#2"}
			}
		}
	],
	"gui_light": "front",
	"display": {
		"thirdperson_righthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"thirdperson_lefthand": {
			"translation": [-0.25, -6.25, 2.25]
		},
		"firstperson_righthand": {
			"rotation": [26, 21, -74],
			"translation": [-10, -1.25, -1.5]
		},
		"firstperson_lefthand": {
			"rotation": [20, -15, -75],
			"translation": [-6, 1.25, -5.75]
		},
		"ground": {
			"rotation": [40, 0, 0],
			"translation": [0, 3.75, 0]
		},
		"gui": {
			"rotation": [0, 90, 0],
			"translation": [0, -3.75, 0]
		},
		"fixed": {
			"rotation": [0, 90, 0],
			"translation": [-0.75, -4.25, 0]
		}
	},
	"groups": [
		{
			"name": "weakling_bow_3d",
			"origin": [8, 8, 8],
			"color": 0,
			"children": [0, 1, 2, 3, 4, 5, 6, 7]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\weakling_bow_3dpull2.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\axes.json -----
{ "replace": false, "values": ["#grimfate:axes"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\axes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\bows.json -----
{ "replace": false, "values": ["#grimfate:bows"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\bows.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\crossbows.json -----
{ "replace": false, "values": ["#grimfate:crossbows"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\crossbows.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\daggers.json -----
{
  "replace": false,
  "values": [
    "#grimfate:daggers"
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\daggers.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\greataxes.json -----
{ "replace": false, "values": ["#grimfate:two_handed"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\greataxes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\greatswords.json -----
{ "replace": false, "values": ["#grimfate:two_handed"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\greatswords.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\hammers.json -----
{ "replace": false, "values": ["#grimfate:hammers"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\hammers.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\staves.json -----
{ "replace": false, "values": ["#grimfate:staves"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\staves.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\swords.json -----
{ "replace": false, "values": ["#grimfate:swords"] }

n----- END FILE: .\grimfate\src\main\resources\data\bettercombat\tags\items\swords.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\slot_types\belt.json -----
{
  "name": "belt",
  "size": 1,
  "order": 30,
  "icon": "curios:slot/belt",
  "cosmetic": false,
  "entities": ["curios:player_like"]
}

n----- END FILE: .\grimfate\src\main\resources\data\curios\slot_types\belt.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\slot_types\necklace.json -----
{
  "name": "necklace",
  "size": 1,
  "order": 20,
  "icon": "curios:slot/necklace",
  "cosmetic": false,
  "entities": ["curios:player_like"]
}

n----- END FILE: .\grimfate\src\main\resources\data\curios\slot_types\necklace.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\slot_types\ring.json -----
{
  "size": 2,
  "order": 10,
  "icon": "curios:slot/ring",
  "cosmetic": false,
  "entities": ["curios:player_like"]
}

n----- END FILE: .\grimfate\src\main\resources\data\curios\slot_types\ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\tags\items\belt.json -----
{ "values": [] }
n----- END FILE: .\grimfate\src\main\resources\data\curios\tags\items\belt.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\tags\items\necklace.json -----
{ "values": ["grimfate:copper_necklace","grimfate:bronze_necklace"] }

n----- END FILE: .\grimfate\src\main\resources\data\curios\tags\items\necklace.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\tags\items\ring.json -----
{ "values": ["grimfate:copper_ring","grimfate:bronze_ring"] }

n----- END FILE: .\grimfate\src\main\resources\data\curios\tags\items\ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\attributes.json -----
{
  "attributes": {
    "vitality":     { "cap": 99, "max_health_per": 6.0, "regen_hp_per": 0.06 },
    "strength":     { "cap": 99, "melee_damage_per": 0.7 },
    "intelligence": { "cap": 99, "spell_power_per": 0.7 },
    "spirit":       { "cap": 99, "max_mana_per": 10.0, "regen_mp_per": 0.08 },
    "dexterity":    { "cap": 99, "cast_speed_per": 0.5 },
    "evasion":      { "cap": 100, "evasion_per": 0.5 }
  }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\attributes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\levels.json -----
{
  "max_level": 99,
  "base": 500.0,
  "growth": 2.00
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\levels.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\spells.json -----
{
  "auto_bolt_staff": {
    "type": "projectile",
    "damage_type": "phys_ranged",
    "base_damage": 22,
    "mana_cost": 8,
    "cooldown_ticks": 40,
    "speed": 1.6,
    "range": 32,
    "requires_type": "STAFF",
    "scaling": {
      "INT": 0.25
    }
  },
  "spells": {
    "grimfate:knight_dash": {
      "school": "TECHNIQUE",
      "tags": ["MOVEMENT"],
      "base_cost": 8,
      "base_cooldown": 60,
      "scaling": { "dexterity": 0.7 }
    }
  }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\spells.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\fiber_from_grass.json -----
{
  "type": "neoforge:add_item",
  "conditions": [
    {
      "condition": "neoforge:loot_table_id",
      "loot_table_id": [
        "minecraft:blocks/grass",
        "minecraft:blocks/tall_grass"
      ]
    },
    { "condition": "minecraft:random_chance", "chance": 0.125 }
  ],
  "item": "grimfate:fiber",
  "count": 1
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\fiber_from_grass.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\global_loot_modifiers.json -----
{
  "replace": false,
  "entries": [
    "grimfate:fiber_from_grass",
    "grimfate:pork_fat_from_pig",
    "grimfate:jewelry_from_chests"
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\global_loot_modifiers.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\jewelry_from_chests.json -----
{
  "type": "neoforge:add_table",
  "conditions": [
    {
      "condition": "neoforge:loot_table_id",
      "loot_table_id": [
        "minecraft:chests/simple_dungeon",
        "minecraft:chests/abandoned_mineshaft",
        "minecraft:chests/shipwreck_treasure",
        "minecraft:chests/jungle_temple",

        "minecraft:chests/village/village_weaponsmith",
        "minecraft:chests/village/village_armorer",
        "minecraft:chests/village/village_temple",
        "minecraft:chests/village/village_cartographer",
        "minecraft:chests/village/village_fletcher",
        "minecraft:chests/village/village_tannery",
        "minecraft:chests/village/village_toolsmith",
        "minecraft:chests/village/village_fisher",
        "minecraft:chests/village/village_butcher",

        "minecraft:chests/village/village_desert_house",
        "minecraft:chests/village/village_plains_house",
        "minecraft:chests/village/village_savanna_house",
        "minecraft:chests/village/village_snowy_house",
        "minecraft:chests/village/village_taiga_house"
      ]
    }
  ],
  "table": "grimfate:gameplay/jewelry_pool"
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\jewelry_from_chests.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\pork_fat_from_pig.json -----
{
  "type": "neoforge:add_item",
  "conditions": [
    {
      "condition": "neoforge:loot_table_id",
      "loot_table_id": [ "minecraft:entities/pig" ]
    },
    { "condition": "minecraft:random_chance", "chance": 0.5 }
  ],
  "item": "grimfate:pork_fat",
  "count": 1
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\pork_fat_from_pig.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_tables\gameplay\jewelry_pool.json -----
{
  "type": "minecraft:chest",
  "pools": [
    {
      "rolls": 1,
      "conditions": [
        { "condition": "minecraft:random_chance", "chance": 0.20 }
      ],
      "entries": [
        {
          "type": "minecraft:tag",
          "name": "grimfate:jewelry",
          "expand": true
        }
      ]
    }
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_tables\gameplay\jewelry_pool.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\canvas_fabric.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [
    "FFF",
    "FPF",
    "FFF"
  ],
  "key": {
    "F": { "item": "grimfate:fiber" },
    "P": {"item": "grimfate:pork_fat"}
  },
  "result": { "item": "grimfate:canvas_fabric", "count": 1 }
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\canvas_fabric.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\copper_sword.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [
    " I ",
    " I ",
    "PSC"
  ],
  "key": {
    "I": { "item": "minecraft:copper_ingot" },
    "C": { "item": "grimfate:canvas_fabric" },
    "P": {"item": "grimfate:pork_fat"},
    "S": {"item": "minecraft:stick"}
  },
  "result": { "item": "grimfate:copper_sword", "count": 1 }
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\copper_sword.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\copperforced_shield.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [
    "MFM",
    "MCM",
    "MRM"
  ],
  "key": {
    "C": { "item": "minecraft:copper_ingot" },
    "R": { "item": "grimfate:rawhide" },
    "P": {"item": "grimfate:pork_fat"},
    "M": {"tag": "minecraft:planks"}
  },
  "result": { "item": "grimfate:copperforced_shield", "count": 1 }
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\copperforced_shield.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\rawhide.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [
    "LLF",
    "FFF"
  ],
  "key": {
    "F": { "item": "grimfate:pork_fat" },
    "L": { "item": "minecraft:leather" }
  },
  "result": { "item": "grimfate:rawhide", "count": 1 }
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\rawhide.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\scholar_staff.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [
    "PFP",
    " S ",
    " S "],
  "key": {
    "S": {"item": "minecraft:stick"},
    "P": {"item": "grimfate:pork_fat"},
    "F": {"item": "grimfate:fiber"}
  },
  "result": {"id": "grimfate:scholar_staff", "count": 1}
}
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\scholar_staff.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\weakling_bow.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [
    "GS ",
    "GFC",
    "GS "
  ],
  "key": {
    "S": { "item": "minecraft:stick" },
    "C": { "item": "grimfate:canvas_fabric" },
    "F": {"item": "grimfate:pork_fat"},
    "G": {"item": "grimfate:fiber"}
  },
  "result": { "item": "grimfate:weakling_bow", "count": 1 }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\weakling_bow.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\boots.json -----
{ "values": ["grimfate:copper_boots", "grimfate:linen_shoes", "grimfate:rawhide_boots"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\boots.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\chest.json -----
{ "values": ["grimfate:copper_chestplate", "grimfate:linen_cape", "grimfate:rawhide_jacket"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\chest.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\cloth.json -----
{ "values": ["grimfate:linen_shoes", "grimfate:linen_cape", "grimfate:linen_hat", "grimfate:linen_pants"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\cloth.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\helm.json -----
{ "values": ["grimfate:copper_helmet", "grimfate:linen_hat", "grimfate:rawhide_hood"] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\helm.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\leather.json -----
{ "values": ["grimfate:rawhide_boots", "grimfate:rawhide_wraps", "grimfate:rawhide_jacket", "grimfate:rawhide_hood"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\leather.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\legs.json -----
{ "values": ["grimfate:copper_chestplate", "grimfate:linen_pants", "grimfate:rawhide_wraps"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\legs.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\plate.json -----
{ "values": ["grimfate:copper_helmet", "grimfate:copper_chestplate", "grimfate:copper_leggings", "grimfate:copper_boots"] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\plate.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\axes.json -----
{ "replace": false, "values": [

] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\axes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\bows.json -----
{ "replace": false, "values": [
  "grimfate:weakliing_bow"
] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\bows.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\crossbows.json -----
{ "replace": false, "values": [

] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\crossbows.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\daggers.json -----
{ "replace": false, "values": [

] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\daggers.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\greataxes.json -----
{ "replace": false, "values": [

] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\greataxes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\greatswords.json -----
{ "replace": false, "values": [

] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\greatswords.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\hammers.json -----
{ "replace": false, "values": [

] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\hammers.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\jewelry.json -----
{
  "replace": false,
  "values": [
    "grimfate:copper_ring",
    "grimfate:bronze_ring",
    "grimfate:copper_necklace",
    "grimfate:copper_necklace"
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\jewelry.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\archer.json -----
{ "values": [] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\archer.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\mage.json -----
{ "values": [] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\mage.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\melee.json -----
{ "values": [] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\melee.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\shields.json -----
{ "replace": false, "values": [

] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\shields.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\staves.json -----
{ "replace": false, "values": [
  "grimfate:scholar_staff"
] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\staves.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\swords.json -----
{ "replace": false, "values": [
  "grimfate:copper_sword"
] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\swords.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\weapon_attributes\copper_sword.json -----
{ "parent": "bettercombat:sword" }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\weapon_attributes\copper_sword.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\weapon_attributes\scholar_staff.json -----
{ "parent": "bettercombat:staff" }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\weapon_attributes\scholar_staff.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\weapon_attributes\weakling_bow.json -----
{ "parent": "bettercombat:bow_two_handed_heavy" }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\weapon_attributes\weakling_bow.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json -----
{
  "replace": false,
  "entries": [
    "grimfate:fiber_from_grass",
    "grimfate:pork_fat_from_pig",
    "grimfate:jewelry_from_chests"
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json -----n
