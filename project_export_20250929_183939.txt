=== FILE STRUCTURE (relative to D:\doomspire) ===
.\gradle.properties
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java
.\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java
.\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java
.\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java
.\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java
.\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java
.\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java
.\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java
.\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java
.\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java
.\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java
.\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java
.\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltResult.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltService.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltTuning.java
.\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java
.\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java
.\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java
.\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java
.\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json
.\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\model\armor\BaseArmorGeoModel.java
.\grimfate\src\main\java\com\doomspire\grimfate\client\render\armor\BaseArmorRenderer.java
.\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponPredicates.java
.\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponType.java
.\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java
.\grimfate\src\main\java\com\doomspire\grimfate\compat\curios\CuriosCompat.java
.\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java
.\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java
.\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java
.\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java
.\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\armor\GenericGeoArmorItem.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\comp\AffixListComponent.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\comp\WeaponProfileComponent.java
.\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java
.\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java
.\grimfate\src\main\java\com\doomspire\grimfate\loot\RustyRingDropModifier.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\AutoBoltServer.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastAutoBoltPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java
.\grimfate\src\main\java\com\doomspire\grimfate\network\SpellCastClient.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModArmorMaterials.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModDataComponents.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java
.\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItemTags.java
.\grimfate\src\main\resources\assets\grimfate\geo\armor\copper_armor_set.geo.json
.\grimfate\src\main\resources\assets\grimfate\lang\en_us.json
.\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_boots.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_chestplate.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_helmet.json
.\grimfate\src\main\resources\assets\grimfate\models\item\copper_leggins.json
.\grimfate\src\main\resources\assets\grimfate\models\item\rusty_ring.json
.\grimfate\src\main\resources\data\curios\slot_types\necklace.json
.\grimfate\src\main\resources\data\curios\slot_types\ring.json
.\grimfate\src\main\resources\data\grimfate\balance\attributes.json
.\grimfate\src\main\resources\data\grimfate\balance\levels.json
.\grimfate\src\main\resources\data\grimfate\balance\spells.json
.\grimfate\src\main\resources\data\grimfate\loot_modifiers\rusty_ring.json
.\grimfate\src\main\resources\data\grimfate\recipes\apprentice_staff.json
.\grimfate\src\main\resources\data\grimfate\recipes\copper_sword.json
.\grimfate\src\main\resources\data\grimfate\recipes\hunters_bow.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\boots.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\chest.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\cloth.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\helm.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\leather.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\legs.json
.\grimfate\src\main\resources\data\grimfate\tags\items\armor\plate.json
.\grimfate\src\main\resources\data\grimfate\tags\items\daggers.json
.\grimfate\src\main\resources\data\grimfate\tags\items\melee_weapons.json
.\grimfate\src\main\resources\data\grimfate\tags\items\ranged_weapons.json
.\grimfate\src\main\resources\data\grimfate\tags\items\role\archer.json
.\grimfate\src\main\resources\data\grimfate\tags\items\role\mage.json
.\grimfate\src\main\resources\data\grimfate\tags\items\role\melee.json
.\grimfate\src\main\resources\data\grimfate\tags\items\shields.json
.\grimfate\src\main\resources\data\grimfate\tags\items\staves.json
.\grimfate\src\main\resources\data\grimfate\tags\items\two_handed.json
.\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json
n=== CONCATENATED CONTENTS ===n
----- BEGIN FILE: .\gradle.properties -----
# ------------------------------
# Gradle performance
# ------------------------------
org.gradle.jvmargs=-Xmx2G
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configuration-cache=true

# ------------------------------
# Minecraft / NeoForge versions
# ------------------------------
minecraft_version=1.21.1
minecraft_version_range=[1.21.1,)
neo_version=21.1.208
loader_version_range=[1,)

# ------------------------------
# Parchment (mappings & docs)
# ------------------------------
parchment_minecraft_version=1.21.1
parchment_mappings_version=2024.11.17

# ------------------------------
# Mod metadata (???????? ??? grimfate)
# ------------------------------
mod_id=grimfate
mod_name=Grimfate
mod_version=0.0.1
mod_license=All Rights Reserved
mod_group_id=com.doomspire
mod_authors=Epilekt
mod_description=RPG ??? Grimfate. ????????? ??????, ??????, ????? ? ????? ????????? ? Minecraft.

# ------------------------------
# Mod metadata (?????????? grimcore)
# ------------------------------
core_mod_id=grimcore
core_mod_name=Grimcore
core_mod_version=0.0.1
core_mod_group_id=com.doomspire
core_mod_authors=Epilekt
core_mod_description=Core library with shared RPG systems for Grimfate

geckolib_version=4.7.7

n----- END FILE: .\gradle.properties -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.*;

public final class MobStatCalculator {
    private MobStatCalculator(){}

    public static StatSnapshot calculate(MobStatsAttachment att) {
        StatSnapshot s = new StatSnapshot();

        int vit  = att.getAttribute(Attributes.VITALITY);
        int str  = att.getAttribute(Attributes.STRENGTH);
        int intl = att.getAttribute(Attributes.INTELLIGENCE);
        int dex  = att.getAttribute(Attributes.DEXTERITY);
        int eva  = att.getAttribute(Attributes.EVASION);

        // База для мобов (потом вынесем в датапак balance)
        s.maxHealth   = 60 + vit * 20;
        s.regenHealth = 0 + vit * 1;

        // у мобов нет маны
        s.maxMana   = 0;
        s.regenMana = 0;

        // Базовый урон (только физика для старта)
        s.damage.put(DamageTypes.PHYS_MELEE, 3f + str * 0.5f);
        s.damage.put(DamageTypes.PHYS_RANGED, dex * 0.5f);

        // Элементы оставим 0 по умолчанию (будут у кастомных мобов)
        s.damage.putIfAbsent(DamageTypes.FIRE, 0f);
        s.damage.putIfAbsent(DamageTypes.FROST, 0f);
        s.damage.putIfAbsent(DamageTypes.LIGHTNING, 0f);
        s.damage.putIfAbsent(DamageTypes.POISON, 0f);

        // Защита/уклон/крит как старт
        s.resistances.put(ResistTypes.PHYS, 0.0f);
        s.resistances.put(ResistTypes.FIRE, 0.0f);
        s.resistances.put(ResistTypes.FROST, 0.0f);
        s.resistances.put(ResistTypes.LIGHTNING, 0.0f);
        s.resistances.put(ResistTypes.POISON, 0.0f);

        s.evasionChance = Math.min(0.5f, eva * 0.005f); // 0.5% за очко, кап 50%
        s.critChance = 0f;
        s.critDamage = 0.25f;

        return s;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatCalculator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.*;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.EnumMap;

public class MobStatsAttachment {
    private final EnumMap<Attributes, Integer> attributes = new EnumMap<>(Attributes.class);
    private int currentHealth = 100;
    private boolean dirty = true;
    private StatSnapshot snapshot = new StatSnapshot();

    public MobStatsAttachment() {
        // у мобов нет маны → пропускаем SPIRIT
        for (Attributes a : Attributes.values()) {
            if (a != Attributes.SPIRIT) attributes.put(a, 0);
        }
    }

    public int getAttribute(Attributes attr) {
        return attributes.getOrDefault(attr, 0);
    }
    public void setAttribute(Attributes attr, int value) {
        if (attr == Attributes.SPIRIT) return; // игнор
        attributes.put(attr, Math.max(0, value)); dirty = true;
    }
    public void addAttribute(Attributes attr, int delta) {
        if (attr == Attributes.SPIRIT) return;
        attributes.put(attr, Math.max(0, getAttribute(attr) + delta)); dirty = true;
    }

    public int getCurrentHealth() { return currentHealth; }
    public void setCurrentHealth(int v) {
        int max = (int)Math.max(1, getSnapshot().maxHealth);
        currentHealth = Math.max(0, Math.min(v, max));
    }

    public StatSnapshot getSnapshot() {
        if (dirty) {
            snapshot = MobStatCalculator.calculate(this);
            dirty = false;
        }
        return snapshot;
    }
    public void markDirty() { dirty = true; }

    // --- net sync ---
    public static final StreamCodec<RegistryFriendlyByteBuf, MobStatsAttachment> STREAM_CODEC =
            StreamCodec.of(MobStatsAttachment::encode, MobStatsAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, MobStatsAttachment att) {
        buf.writeVarInt(att.currentHealth);
        // порядок атрибутов фиксируем:
        for (Attributes a : Attributes.values()) {
            if (a == Attributes.SPIRIT) continue;
            buf.writeVarInt(att.getAttribute(a));
        }
    }
    private static MobStatsAttachment decode(RegistryFriendlyByteBuf buf) {
        MobStatsAttachment att = new MobStatsAttachment();
        att.currentHealth = buf.readVarInt();
        for (Attributes a : Attributes.values()) {
            if (a == Attributes.SPIRIT) continue;
            att.attributes.put(a, buf.readVarInt());
        }
        att.dirty = true;
        return att;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\MobStatsAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java -----
package com.doomspire.grimcore.attach;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.resources.ResourceLocation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Лоадаут спеллов игрока: 6 слотов + пер-слот кулдауны.
 * Сериализация:
 *  - CODEC (в NBT/сейв): slots как список строк (пустая строка = null), cooldowns как список int.
 *  - STREAM_CODEC (в сеть): на слот пишем флаг наличия + ResourceLocation (если есть), затем cooldowns.
 */
public final class PlayerLoadoutAttachment {

    public static final int SLOTS = 6;

    private final ResourceLocation[] slots = new ResourceLocation[SLOTS];
    private final int[] cooldown = new int[SLOTS];

    public PlayerLoadoutAttachment() {}

    // -------- API --------
    public ResourceLocation get(int slot) { check(slot); return slots[slot]; }
    public void set(int slot, ResourceLocation id) { check(slot); slots[slot] = id; }

    public int getCooldown(int slot) { check(slot); return cooldown[slot]; }
    public void setCooldown(int slot, int ticks) { check(slot); cooldown[slot] = Math.max(0, ticks); }

    public void tickDown() {
        for (int i = 0; i < SLOTS; i++) if (cooldown[i] > 0) cooldown[i]--;
    }

    public void clearAll() {
        Arrays.fill(slots, null);
        Arrays.fill(cooldown, 0);
    }

    private static void check(int s) {
        if (s < 0 || s >= SLOTS) throw new IndexOutOfBoundsException("slot " + s);
    }

    // -------- CODEC (persist) --------
    public static final Codec<PlayerLoadoutAttachment> CODEC = RecordCodecBuilder.create(inst -> inst.group(
            // список строк длиной SLOTS; "" означает пустой слот
            Codec.list(Codec.STRING).fieldOf("slots").forGetter(att -> {
                List<String> out = new ArrayList<>(SLOTS);
                for (int i = 0; i < SLOTS; i++) out.add(att.slots[i] != null ? att.slots[i].toString() : "");
                return out;
            }),
            Codec.list(Codec.INT).fieldOf("cooldowns").forGetter(att -> {
                List<Integer> out = new ArrayList<>(SLOTS);
                for (int i = 0; i < SLOTS; i++) out.add(att.cooldown[i]);
                return out;
            })
    ).apply(inst, (slotStrings, cds) -> {
        PlayerLoadoutAttachment att = new PlayerLoadoutAttachment();
        int n = Math.min(SLOTS, slotStrings.size());
        for (int i = 0; i < n; i++) {
            String s = slotStrings.get(i);
            if (s != null && !s.isEmpty()) {
                ResourceLocation rl = ResourceLocation.tryParse(s);
                if (rl != null) att.slots[i] = rl;
            }
        }
        int m = Math.min(SLOTS, cds.size());
        for (int i = 0; i < m; i++) att.cooldown[i] = Math.max(0, cds.get(i));
        return att;
    }));

    // -------- STREAM_CODEC (network) --------
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerLoadoutAttachment> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public PlayerLoadoutAttachment decode(RegistryFriendlyByteBuf buf) {
                    PlayerLoadoutAttachment att = new PlayerLoadoutAttachment();
                    for (int i = 0; i < SLOTS; i++) {
                        boolean has = buf.readBoolean();
                        if (has) att.slots[i] = ResourceLocation.STREAM_CODEC.decode(buf);
                    }
                    for (int i = 0; i < SLOTS; i++) {
                        att.cooldown[i] = buf.readVarInt();
                    }
                    return att;
                }

                @Override
                public void encode(RegistryFriendlyByteBuf buf, PlayerLoadoutAttachment att) {
                    for (int i = 0; i < SLOTS; i++) {
                        ResourceLocation rl = att.slots[i];
                        buf.writeBoolean(rl != null);
                        if (rl != null) ResourceLocation.STREAM_CODEC.encode(buf, rl);
                    }
                    for (int i = 0; i < SLOTS; i++) {
                        buf.writeVarInt(att.cooldown[i]);
                    }
                }
            };
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerLoadoutAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimcore.xp.LevelTable;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

/**
 * Персистентный прогресс игрока (уровень/опыт/кап). Сохраняется через CODEC.
 * Клиенту отдаём лёгкий снапшот PlayerProgress.
 */
public class PlayerProgressAttachment {

    private int level;
    private int exp;
    private int expCap;

    public PlayerProgressAttachment() {
        this.level = 1;
        this.exp = 0;
        this.expCap = LevelTable.expForLevel(1); // кап до 2-го уровня
    }

    public int level() { return level; }
    public int exp() { return exp; }
    public int expCap() { return expCap; }

    /** Возвращает число полученных уровней (для выдачи очков атрибутов). */
    public int addExp(int amount) {
        if (amount <= 0) return 0;
        int gained = 0;
        exp += amount;
        while (exp >= expCap && level < LevelTable.maxLevel()) {
            exp -= expCap;
            level++;
            expCap = LevelTable.expForLevel(level);
            gained++;
        }
        return gained;
    }

    /** Снимок для HUD/клиента. */
    public PlayerProgress toSnapshot() {
        return new PlayerProgress(level, exp, expCap);
    }

    // ---------- Persist (save/load) ----------
    public static final Codec<PlayerProgressAttachment> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.fieldOf("level").forGetter(PlayerProgressAttachment::level),
            Codec.INT.fieldOf("exp").forGetter(PlayerProgressAttachment::exp),
            Codec.INT.fieldOf("exp_cap").forGetter(PlayerProgressAttachment::expCap)
    ).apply(i, (lvl, e, cap) -> {
        PlayerProgressAttachment a = new PlayerProgressAttachment();
        a.level = Math.max(1, lvl);
        a.exp = Math.max(0, e);
        a.expCap = Math.max(1, cap);
        return a;
    }));

    // ---------- Network (instant sync, если шлём кастомный пакет) ----------
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerProgressAttachment> STREAM_CODEC =
            StreamCodec.of(PlayerProgressAttachment::encode, PlayerProgressAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, PlayerProgressAttachment a) {
        buf.writeVarInt(a.level);
        buf.writeVarInt(a.exp);
        buf.writeVarInt(a.expCap);
    }

    private static PlayerProgressAttachment decode(RegistryFriendlyByteBuf buf) {
        PlayerProgressAttachment a = new PlayerProgressAttachment();
        a.level  = buf.readVarInt();
        a.exp    = buf.readVarInt();
        a.expCap = buf.readVarInt();
        return a;
    }
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerProgressAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java -----
package com.doomspire.grimcore.attach;

import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatCalculator;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.world.entity.player.Player;
import com.doomspire.grimcore.datapack.BalanceData;
import java.util.EnumMap;
import java.util.Locale;

/**
 * Attachment игрока: очки атрибутов, текущие ресурсы и кэш агрегированных статов.
 * Без устаревших API. Для сети используем StreamCodec (NeoForge/Mojang 1.21.1).
 */
public class PlayerStatsAttachment {

    // ---- Текущие ресурсы (кастомные полосы) ----
    private int currentHealth = 100;
    private int currentMana   = 100;

    // ---- Распределённые очки по атрибутам ----
    private final EnumMap<Attributes, Integer> attributes = new EnumMap<>(Attributes.class);

    // ---- Очки, нераспределённые игроком ----
    private int unspentPoints = 0;

    // ---- Кэш снапшота и грязный флаг ----
    private StatSnapshot snapshot = new StatSnapshot();
    private boolean dirty = true;

    public PlayerStatsAttachment() {
        for (Attributes a : Attributes.values()) {
            attributes.put(a, 0);
        }
    }

    // ===================== API =====================

    public int getCurrentHealth() { return currentHealth; }
    public int getCurrentMana()   { return currentMana; }

    public void setCurrentHealth(int v) {
        int max = (int) Math.max(1, getSnapshot().maxHealth);
        currentHealth = Math.max(0, Math.min(v, max));
    }

    public void setCurrentMana(int v) {
        int max = (int) Math.max(1, getSnapshot().maxMana);
        currentMana = Math.max(0, Math.min(v, max));
    }

    public void markDirty() { this.dirty = true; }

    public int getAttribute(Attributes attr) {
        return attributes.getOrDefault(attr, 0);
    }

    public void setAttribute(Attributes attr, int value) {
        attributes.put(attr, Math.max(0, value));
        dirty = true;
    }

    public void addAttribute(Attributes attr, int delta) {
        attributes.put(attr, Math.max(0, getAttribute(attr) + delta));
        dirty = true;
    }

    public int getUnspentPoints() { return unspentPoints; }
    public void setUnspentPoints(int v) { unspentPoints = Math.max(0, v); }
    public void addUnspentPoints(int amount) { if (amount > 0) unspentPoints += amount; }

    public int hardCapFor(Attributes attr) {
        return BalanceData.attrs().cap(attr);
    }

    /** Потратить 1 очко в атрибут с проверкой капа. Возвращает true при успехе. */
    public boolean tryAllocatePoint(Attributes attr) {
        if (unspentPoints <= 0) return false;
        int cap = hardCapFor(attr);
        int cur = getAttribute(attr);
        if (cur >= cap) return false;

        setAttribute(attr, cur + 1);
        unspentPoints--;
        return true;
    }

    public StatSnapshot getSnapshot() {
        if (dirty) {
            snapshot = StatCalculator.calculate(this);
            dirty = false;
        }
        return snapshot;
    }

    // ===================== NET (StreamCodec) =====================
    public static final StreamCodec<RegistryFriendlyByteBuf, PlayerStatsAttachment> STREAM_CODEC =
            StreamCodec.of(PlayerStatsAttachment::encode, PlayerStatsAttachment::decode);

    private static void encode(RegistryFriendlyByteBuf buf, PlayerStatsAttachment att) {
        buf.writeVarInt(att.unspentPoints);
        buf.writeVarInt(att.currentHealth);
        buf.writeVarInt(att.currentMana);
        for (Attributes a : Attributes.values()) {
            buf.writeVarInt(att.getAttribute(a));
        }
    }

    private static PlayerStatsAttachment decode(RegistryFriendlyByteBuf buf) {
        PlayerStatsAttachment att = new PlayerStatsAttachment();
        att.unspentPoints = buf.readVarInt();
        att.currentHealth = buf.readVarInt();
        att.currentMana   = buf.readVarInt();
        for (Attributes a : Attributes.values()) {
            att.attributes.put(a, buf.readVarInt());
        }
        att.dirty = true;
        return att;
    }

    // ===================== Утилиты =====================

    /** Достаёт аттачмент у игрока. */
    public static PlayerStatsAttachment get(Player player) {
        return player.getData(ModAttachments.PLAYER_STATS.get());
    }

    /** Пытается распарсить строковый id атрибута в enum (без краша). */
    public static Attributes parseAttrId(String id) {
        if (id == null) return null;
        try {
            return Attributes.valueOf(id.trim().toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException ex) {
            return null;
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\attach\PlayerStatsAttachment.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java -----
package com.doomspire.grimcore.combat;

import com.doomspire.grimcore.stat.DamageTypes;
import net.minecraft.world.entity.LivingEntity;

import java.util.EnumMap;

/**
 * Контекст одного удара/заклинания.
 * Заполняется перед вызовом DamageEngine.
 */
public class DamageContext {
    public final LivingEntity attacker;
    public final LivingEntity target;
    public final EnumMap<DamageTypes, Float> damageMap = new EnumMap<>(DamageTypes.class);
    public boolean critical = false;

    public DamageContext(LivingEntity attacker, LivingEntity target) {
        this.attacker = attacker;
        this.target = target;
        for (DamageTypes t : DamageTypes.values()) damageMap.put(t, 0f);
    }

    public DamageContext add(DamageTypes type, float amount) {
        damageMap.put(type, damageMap.get(type) + amount);
        return this;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageContext.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java -----
package com.doomspire.grimcore.combat;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.DamageTypes;
import com.doomspire.grimcore.stat.ResistTypes;
import com.doomspire.grimcore.stat.StatSnapshot;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.LivingEntity;

import java.util.concurrent.ThreadLocalRandom;

public final class DamageEngine {
    private DamageEngine() {}

    public static float resolveAndApply(DamageContext ctx) {
        final LivingEntity target = ctx.target;

        // --- читаем снапшот цели (игрок или моб) ---
        StatSnapshot tSnap;
        boolean targetIsPlayer = target.getData(ModAttachments.PLAYER_STATS.get()) != null;
        if (targetIsPlayer) {
            PlayerStatsAttachment tAtt = target.getData(ModAttachments.PLAYER_STATS.get());
            if (tAtt == null) return 0f;
            tSnap = tAtt.getSnapshot();
            // Evade
            if (ThreadLocalRandom.current().nextFloat() < tSnap.evasionChance) {
                return 0f;
            }
        } else {
            MobStatsAttachment tAtt = target.getData(ModAttachments.MOB_STATS.get());
            if (tAtt == null) return 0f;
            tSnap = tAtt.getSnapshot();
            if (ThreadLocalRandom.current().nextFloat() < tSnap.evasionChance) {
                return 0f;
            }
        }

        // --- снапшот атакера (для крита/воровства) ---
        StatSnapshot aSnap = null;
        if (ctx.attacker != null) {
            var aPlayer = ctx.attacker.getData(ModAttachments.PLAYER_STATS.get());
            if (aPlayer != null) aSnap = aPlayer.getSnapshot();
            else {
                var aMob = ctx.attacker.getData(ModAttachments.MOB_STATS.get());
                if (aMob != null) aSnap = aMob.getSnapshot();
            }
        }

        float total = 0f;

        for (var entry : ctx.damageMap.entrySet()) {
            DamageTypes type = entry.getKey();
            float dmg = entry.getValue();
            if (dmg <= 0f) continue;

            // crit
            if (aSnap != null) {
                boolean rollCrit = ctx.critical || ThreadLocalRandom.current().nextFloat() < aSnap.critChance;
                if (rollCrit) {
                    dmg *= (1f + Math.max(0f, aSnap.critDamage)); // +50% => 0.5
                }
            }

            // resist mapping
            float resist = switch (type) {
                case PHYS_MELEE, PHYS_RANGED -> tSnap.resistances.getOrDefault(ResistTypes.PHYS, 0f);
                case FIRE -> tSnap.resistances.getOrDefault(ResistTypes.FIRE, 0f);
                case FROST -> tSnap.resistances.getOrDefault(ResistTypes.FROST, 0f);
                case LIGHTNING -> tSnap.resistances.getOrDefault(ResistTypes.LIGHTNING, 0f);
                case POISON -> tSnap.resistances.getOrDefault(ResistTypes.POISON, 0f);
            };
            resist = Math.max(0f, Math.min(resist, 0.90f)); // хард-кап 90%
            dmg *= (1f - resist);

            total += Math.max(0f, dmg);
        }

        // lifesteal/manasteal по суммарному урону
        if (aSnap != null && total > 0f && ctx.attacker instanceof LivingEntity attackerLe) {
            int heal = Math.round(total * Math.max(0f, aSnap.lifesteal));
            int mana = Math.round(total * Math.max(0f, aSnap.manasteal));

            var aPlayer = attackerLe.getData(ModAttachments.PLAYER_STATS.get());
            if (aPlayer != null) {
                boolean changed = false;
                if (heal > 0) {
                    aPlayer.setCurrentHealth(aPlayer.getCurrentHealth() + heal);
                    changed = true;
                }
                if (mana > 0) {
                    aPlayer.setCurrentMana(aPlayer.getCurrentMana() + mana);
                    changed = true;
                }
                if (changed) {
                    aPlayer.markDirty();
                    if (attackerLe instanceof ServerPlayer spA) {
                        GrimcoreNetworking.syncPlayerStats(spA, aPlayer);
                    }
                }
            } else {
                var aMob = attackerLe.getData(ModAttachments.MOB_STATS.get());
                if (aMob != null && heal > 0) {
                    aMob.setCurrentHealth(aMob.getCurrentHealth() + heal);
                    aMob.markDirty();
                }
            }
        }

        // применяем к цели
        int applied = Math.max(0, Math.round(total));
        if (applied > 0) {
            if (targetIsPlayer) {
                PlayerStatsAttachment tAtt = target.getData(ModAttachments.PLAYER_STATS.get());
                tAtt.setCurrentHealth(tAtt.getCurrentHealth() - applied);
                tAtt.markDirty();
                if (target instanceof ServerPlayer spT) {
                    GrimcoreNetworking.syncPlayerStats(spT, tAtt); // мгновенный HUD-синк цели
                }
            } else {
                MobStatsAttachment tAtt = target.getData(ModAttachments.MOB_STATS.get());
                tAtt.setCurrentHealth(tAtt.getCurrentHealth() - applied);
                tAtt.markDirty();
            }
        }

        return applied;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\DamageEngine.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java -----
package com.doomspire.grimcore.combat;

import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.damagesource.DamageTypes;

import java.util.Map;

public final class EnvironmentalDamage {
    private EnvironmentalDamage(){}

    // проценты от maxHP (0..1)
    private static final Map<net.minecraft.resources.ResourceKey<net.minecraft.world.damagesource.DamageType>, Float> PERCENTS = Map.of(
            DamageTypes.FALL, 0.15f,
            DamageTypes.DROWN, 0.10f,
            DamageTypes.LAVA, 0.25f,
            DamageTypes.ON_FIRE, 0.08f,
            DamageTypes.IN_FIRE, 0.12f,
            DamageTypes.HOT_FLOOR, 0.10f,
            DamageTypes.SWEET_BERRY_BUSH, 0.04f,
            DamageTypes.OUTSIDE_BORDER, 1.0f
    );

    public static Float percentFor(DamageSource src) {
        for (var e : PERCENTS.entrySet()) {
            if (src.is(e.getKey())) return e.getValue();
        }
        return null;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\combat\EnvironmentalDamage.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.commands.GrimfateCommands;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.RegisterCommandsEvent;

@EventBusSubscriber(modid = Grimcore.MODID)
public final class CommandBusHandlers {
    private CommandBusHandlers(){}

    @SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent e) {
        GrimfateCommands.register(e.getDispatcher());
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\CommandBusHandlers.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java -----
package com.doomspire.grimcore.commands;

import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;

import java.util.Collection;
import java.util.List;

public final class GrimfateCommands {
    private GrimfateCommands(){}

    public static void register(CommandDispatcher<CommandSourceStack> d) {
        d.register(
                Commands.literal("grimfate")
                        .requires(src -> src.hasPermission(2)) // только операторы по умолчанию
                        .then(Commands.literal("give")
                                .then(Commands.literal("exp")
                                        // вариант: /grimfate give exp <amount>
                                        .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                                                .executes(ctx -> {
                                                    ServerPlayer target = ctx.getSource().getPlayerOrException();
                                                    int amount = IntegerArgumentType.getInteger(ctx, "amount");
                                                    return giveExp(ctx.getSource(), List.of(target), amount);
                                                })
                                                // вариант: /grimfate give exp <amount> <targets>
                                                .then(Commands.argument("targets", EntityArgument.players())
                                                        .executes(ctx -> {
                                                            Collection<ServerPlayer> targets = EntityArgument.getPlayers(ctx, "targets");
                                                            int amount = IntegerArgumentType.getInteger(ctx, "amount");
                                                            return giveExp(ctx.getSource(), targets, amount);
                                                        })
                                                )
                                        )
                                )
                        )
        );
    }

    private static int giveExp(CommandSourceStack src, Collection<ServerPlayer> targets, int amount) {
        int totalLevels = 0;

        for (ServerPlayer player : targets) {
            PlayerProgressAttachment prog = player.getData(ModAttachments.PLAYER_PROGRESS.get());
            PlayerStatsAttachment    stats= player.getData(ModAttachments.PLAYER_STATS.get());
            if (prog == null || stats == null) continue;

            int levels = prog.addExp(amount);
            if (levels > 0) {
                stats.addUnspentPoints(levels);
                stats.markDirty();
                GrimcoreNetworking.syncPlayerStats(player, stats);         // мгновенный HUD (очки/полосы)
            }
            ProgressNetworking.syncPlayerProgress(player, prog);            // мгновенный HUD (XP/уровень)

            totalLevels += levels;
            src.sendSuccess(() -> Component.literal(
                    "Given " + amount + " XP to " + player.getGameProfile().getName() +
                            (levels > 0 ? (" (+" + levels + " level)") : "")), true);
        }

        return Math.max(1, totalLevels);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\commands\GrimfateCommands.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java -----
package com.doomspire.grimcore.config;

import net.neoforged.neoforge.common.ModConfigSpec;

public final class CoreCommonConfig {
    //    public static final ModConfigSpec SPEC;
    //    public static final ModConfigSpec.BooleanValue PULL_ENABLED;
    //    public static final ModConfigSpec.IntValue PULL_RADIUS;     // 0..4
    //    public static final ModConfigSpec.IntValue MAX_CONTAINERS;  // safety cap
    //
            //    static {
        //        ModConfigSpec.Builder b = new ModConfigSpec.Builder();
        //        PULL_ENABLED   = b.comment("Enable QoL pulling from nearby containers").define("pullEnabled", true);
        //        PULL_RADIUS    = b.comment("Pull radius (0..4)").defineInRange("pullRadius", 3, 0, 4);
        //        MAX_CONTAINERS = b.comment("Safety cap for scanned containers").defineInRange("maxContainers", 24, 1, 128);
        //        SPEC = b.build();
        //    }

    private CoreCommonConfig() {}
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\config\CoreCommonConfig.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.spell.api.SpellSchool;
import com.mojang.serialization.Codec;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;

/**
 * Разрешённые дисциплины (школы), при которых предмет активирует бонусы/эффект.
 * Например: только WARCRY/TECHNIQUE.
 *
 * Иммутабельный компонент с корректными equals/hashCode.
 */
public final class ClassRestrictionComponent {
    private final EnumSet<SpellSchool> allowed; // внутреннее хранилище

    public ClassRestrictionComponent(Set<SpellSchool> allowed) {
        EnumSet<SpellSchool> s = allowed == null || allowed.isEmpty()
                ? EnumSet.noneOf(SpellSchool.class)
                : EnumSet.copyOf(allowed);
        this.allowed = s;
    }

    /** Пустой набор = разрешено всем. */
    public boolean isAllowed(SpellSchool school) {
        return allowed.isEmpty() || allowed.contains(school);
    }

    /** Неизменяемое представление. */
    public Set<SpellSchool> allowed() {
        return Collections.unmodifiableSet(allowed);
    }

    public static final Codec<SpellSchool> SCHOOL_CODEC =
            Codec.STRING.xmap(s -> SpellSchool.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<ClassRestrictionComponent> CODEC =
            SCHOOL_CODEC.listOf().xmap(list -> new ClassRestrictionComponent(Set.copyOf(list)),
                    c -> java.util.List.copyOf(c.allowed()));

    public static final StreamCodec<RegistryFriendlyByteBuf, ClassRestrictionComponent> STREAM_CODEC =
            StreamCodec.of(
                    (buf, c) -> {
                        ByteBufCodecs.VAR_INT.encode(buf, c.allowed.size());
                        for (var s : c.allowed) ByteBufCodecs.fromCodec(SCHOOL_CODEC).encode(buf, s);
                    },
                    buf -> {
                        int n = ByteBufCodecs.VAR_INT.decode(buf);
                        EnumSet<SpellSchool> set = EnumSet.noneOf(SpellSchool.class);
                        for (int i = 0; i < n; i++) set.add(ByteBufCodecs.fromCodec(SCHOOL_CODEC).decode(buf));
                        return new ClassRestrictionComponent(set);
                    }
            );

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ClassRestrictionComponent that)) return false;
        return Objects.equals(allowed, that.allowed);
    }

    @Override
    public int hashCode() {
        return Objects.hash(allowed);
    }

    @Override
    public String toString() {
        return "ClassRestrictionComponent" + allowed;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\ClassRestrictionComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java -----
package com.doomspire.grimcore.data.component;

import com.doomspire.grimcore.stat.Attributes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;
import java.util.Objects;

/**
 * Иммутабельный data-component с бонусами к атрибутам, напр.:
 * {"strength": 3, "intelligence": 2}
 *
 * Требования NeoForge к компонентам:
 *  - иммутабельность
 *  - корректные equals/hashCode
 */
public final class StatBonusComponent {

    private final EnumMap<Attributes, Integer> bonus; // иммутабельное содержимое

    public StatBonusComponent(Map<Attributes, Integer> map) {
        EnumMap<Attributes, Integer> tmp = new EnumMap<>(Attributes.class);
        if (map != null) {
            for (var e : map.entrySet()) {
                if (e.getKey() != null) {
                    int v = e.getValue() == null ? 0 : e.getValue();
                    if (v != 0) tmp.put(e.getKey(), v);
                }
            }
        }
        this.bonus = tmp.isEmpty() ? new EnumMap<>(Attributes.class) : new EnumMap<>(tmp);
    }

    /** Возвращает бонус для заданного атрибута (0 если не задан). */
    public int get(Attributes a) {
        Integer v = bonus.get(a);
        return v == null ? 0 : v;
    }

    /** Неизменяемое представление всех бонусов. */
    public Map<Attributes, Integer> all() {
        return Collections.unmodifiableMap(bonus);
    }

    // --- Codec/StreamCodec ---
    public static final Codec<Attributes> ATTR_CODEC =
            Codec.STRING.xmap(s -> Attributes.valueOf(s.toUpperCase()), a -> a.name().toLowerCase());

    public static final Codec<StatBonusComponent> CODEC =
            Codec.unboundedMap(ATTR_CODEC, Codec.INT)
                    .xmap(StatBonusComponent::new, c -> c.all());

    public static final StreamCodec<RegistryFriendlyByteBuf, StatBonusComponent> STREAM_CODEC =
            StreamCodec.of(
                    (buf, c) -> {
                        var map = c.bonus;
                        ByteBufCodecs.VAR_INT.encode(buf, map.size());
                        for (var e : map.entrySet()) {
                            ByteBufCodecs.fromCodec(ATTR_CODEC).encode(buf, e.getKey());
                            ByteBufCodecs.VAR_INT.encode(buf, e.getValue());
                        }
                    },
                    buf -> {
                        int n = ByteBufCodecs.VAR_INT.decode(buf);
                        EnumMap<Attributes, Integer> m = new EnumMap<>(Attributes.class);
                        for (int i = 0; i < n; i++) {
                            Attributes a = ByteBufCodecs.fromCodec(ATTR_CODEC).decode(buf);
                            int v = ByteBufCodecs.VAR_INT.decode(buf);
                            if (v != 0) m.put(a, v);
                        }
                        return new StatBonusComponent(m);
                    }
            );

    // --- equals/hashCode (по содержимому карты) ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof StatBonusComponent that)) return false;
        return Objects.equals(bonus, that.bonus);
    }

    @Override
    public int hashCode() {
        return Objects.hash(bonus);
    }

    @Override
    public String toString() {
        return "StatBonusComponent" + bonus;
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\component\StatBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java -----
package com.doomspire.grimcore.data;

import com.doomspire.grimcore.data.component.StatBonusComponent;
import com.doomspire.grimcore.stat.Attributes;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.player.Player;

public final class ItemBonusHelper {
    private ItemBonusHelper(){}

    public static int sum(Player p, Attributes attr) {
        int total = 0;
        for (var slot : EquipmentSlot.values()) {
            var stack = p.getItemBySlot(slot);
            if (stack.isEmpty()) continue;
            var comp = stack.get(ModDataComponents.STAT_BONUS.get());
            if (comp != null) total += comp.get(attr);
        }
        return total;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ItemBonusHelper.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java -----
package com.doomspire.grimcore.data;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.data.component.ClassRestrictionComponent;
import com.doomspire.grimcore.data.component.StatBonusComponent;
import net.minecraft.core.registries.Registries;
import net.minecraft.core.component.DataComponentType;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModDataComponents {
    private ModDataComponents() {}

    public static final DeferredRegister<DataComponentType<?>> COMPONENT_TYPES =
            DeferredRegister.create(Registries.DATA_COMPONENT_TYPE, Grimcore.MODID);

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<StatBonusComponent>> STAT_BONUS =
            COMPONENT_TYPES.register("stat_bonus", () ->
                    DataComponentType.<StatBonusComponent>builder()
                            .persistent(StatBonusComponent.CODEC)
                            .networkSynchronized(StatBonusComponent.STREAM_CODEC)
                            .build()
            );

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<ClassRestrictionComponent>> CLASS_RESTRICTION =
            COMPONENT_TYPES.register("class_restriction", () ->
                    DataComponentType.<ClassRestrictionComponent>builder()
                            .persistent(ClassRestrictionComponent.CODEC)
                            .networkSynchronized(ClassRestrictionComponent.STREAM_CODEC)
                            .build()
            );

    public static void init(net.neoforged.bus.api.IEventBus modBus) {
        COMPONENT_TYPES.register(modBus);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\data\ModDataComponents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import net.minecraft.resources.ResourceLocation;
import org.jetbrains.annotations.Nullable;

/** Глобальный снимок data-driven баланса (обновляется при перезагрузке датапаков). */
public final class Balance {
    private Balance() {}

    private static volatile LevelsCurve levels = LevelsCurve.defaults();
    private static volatile AttributesBalance attributes = AttributesBalance.defaults();
    private static volatile SpellTuning spells = SpellTuning.defaults();

    public static void set(LevelsCurve l, AttributesBalance a, SpellTuning s) {
        levels = (l != null) ? l : LevelsCurve.defaults();
        attributes = (a != null) ? a : AttributesBalance.defaults();
        spells = (s != null) ? s : SpellTuning.defaults();
    }

    public static LevelsCurve levels() { return levels; }
    public static AttributesBalance attributes() { return attributes; }
    public static SpellTuning spells() { return spells; }

    public static @Nullable SpellTuning.Entry getSpellEntry(ResourceLocation id) {
        return spells.byId().get(id);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\Balance.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.doomspire.grimcore.stat.Attributes;
import com.mojang.logging.LogUtils;
import org.slf4j.Logger;

import java.util.EnumMap;
import java.util.Map;

/**
 * Глобальный кэш загруженных из datapack'ов балансовых таблиц.
 * Потокобезопасность: доступ только с сервера-треда при reload/старте.
 */
public final class BalanceData {
    private static final Logger LOG = LogUtils.getLogger();

    // Текущие активные значения
    private static volatile LevelsCurve levelsCurve = LevelsCurve.defaults();
    private static volatile AttributesBalance attributes = AttributesBalance.defaults();
    private static volatile SpellTuning spellTuning = SpellTuning.defaults();

    private BalanceData() {}

    public static LevelsCurve levels() { return levelsCurve; }
    public static AttributesBalance attrs() { return attributes; }
    public static SpellTuning spells() { return spellTuning; }

    /** Вызывается из BalanceReloadListener после успешного парсинга JSON. */
    static void apply(LevelsCurve lv, AttributesBalance ab, SpellTuning st) {
        if (lv != null) levelsCurve = lv;
        if (ab != null) attributes = ab;
        if (st != null) spellTuning = st;
        LOG.info("[Grim] Balance data applied: levels={}, attrs={}, spells={}",
                levelsCurve.summary(), attributes.summary(), spellTuning.summary());
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceData.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java -----
package com.doomspire.grimcore.datapack;

import com.doomspire.grimcore.datapack.codec.AttributesBalance;
import com.doomspire.grimcore.datapack.codec.LevelsCurve;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.mojang.logging.LogUtils;
import com.mojang.serialization.Codec;
import com.mojang.serialization.JsonOps;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.packs.resources.ResourceManager;
import net.minecraft.server.packs.resources.SimplePreparableReloadListener;
import net.minecraft.util.profiling.ProfilerFiller;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.event.AddReloadListenerEvent;
import org.slf4j.Logger;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;

/**
 * Читает JSON из:
 *  - data/grimfate/balance/levels.json
 *  - data/grimfate/balance/attributes.json
 *  - data/grimfate/balance/spells.json
 * и применяет в BalanceData.
 *
 * 1.21.1 / NeoForge: регистрируемся через AddReloadListenerEvent.
 */
public final class BalanceReloadListener extends SimplePreparableReloadListener<BalanceReloadListener.Data> {
    private static final Logger LOG = LogUtils.getLogger();

    /** Снэпшот подготовленных данных. */
    public record Data(LevelsCurve levels, AttributesBalance attrs, SpellTuning spells) {}

    /** Регистрация серверного reload-listener’а. */
    @SubscribeEvent
    public static void onAddReloadListeners(AddReloadListenerEvent e) {
        e.addListener(new BalanceReloadListener());
    }

    @Override
    protected Data prepare(ResourceManager rm, ProfilerFiller profiler) {
        var levels = readJson(rm, "grimfate", "balance/levels.json", LevelsCurve.CODEC);
        var attrs  = readJson(rm, "grimfate", "balance/attributes.json", AttributesBalance.CODEC);
        var spells = readJson(rm, "grimfate", "balance/spells.json", SpellTuning.CODEC);
        com.doomspire.grimcore.datapack.Balance.set(levels, attrs, spells);
        return new Data(levels, attrs, spells);
    }

    @Override
    protected void apply(Data data, ResourceManager rm, ProfilerFiller profiler) {
        BalanceData.apply(
                data.levels() != null ? data.levels() : LevelsCurve.defaults(),
                data.attrs()  != null ? data.attrs()  : AttributesBalance.defaults(),
                data.spells() != null ? data.spells() : SpellTuning.defaults()
        );
        LOG.info("[Grim] BalanceReloadListener applied.");
    }

    // ---------- helpers ----------

    private static <T> T readJson(ResourceManager rm, String namespace, String path, Codec<T> codec) {
        try {
            ResourceLocation rl = ResourceLocation.fromNamespaceAndPath(namespace, path);
            var opt = rm.getResource(rl);
            if (opt.isEmpty()) return null;

            try (var in = opt.get().open();
                 var br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
                var json = com.google.gson.JsonParser.parseReader(br);
                var parsed = codec.parse(JsonOps.INSTANCE, json);
                return parsed.result().orElse(null);
            }
        } catch (Exception ex) {
            LOG.error("[Grim] Failed to read json {}/{}: {}", namespace, path, ex.toString());
            return null;
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\BalanceReloadListener.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java -----
package com.doomspire.grimcore.datapack.codec;

import com.doomspire.grimcore.stat.Attributes;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

import java.util.EnumMap;
import java.util.Map;

public record AttributesBalance(Map<Attributes, Rule> byAttr) {

    public static final Codec<Rule> RULE_CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.optionalFieldOf("cap", 99).forGetter(Rule::cap),
            Codec.DOUBLE.optionalFieldOf("max_health_per", 5.0).forGetter(Rule::maxHealthPer),
            Codec.DOUBLE.optionalFieldOf("max_mana_per", 5.0).forGetter(Rule::maxManaPer),
            Codec.DOUBLE.optionalFieldOf("regen_hp_per", 0.05).forGetter(Rule::regenHpPer),
            Codec.DOUBLE.optionalFieldOf("regen_mp_per", 0.05).forGetter(Rule::regenMpPer),
            Codec.DOUBLE.optionalFieldOf("crit_chance_per", 0.0).forGetter(Rule::critChancePer),
            Codec.DOUBLE.optionalFieldOf("evasion_per", 0.0).forGetter(Rule::evasionPer),
            Codec.DOUBLE.optionalFieldOf("melee_damage_per", 0.0).forGetter(Rule::meleeDamagePer),
            Codec.DOUBLE.optionalFieldOf("spell_power_per", 0.0).forGetter(Rule::spellPowerPer),
            Codec.DOUBLE.optionalFieldOf("cast_speed_per", 0.0).forGetter(Rule::castSpeedPer)
    ).apply(i, Rule::new));

    public static final Codec<Attributes> ATTR_CODEC =
            Codec.STRING.xmap(s -> Attributes.valueOf(s.toUpperCase()), a -> a.name().toLowerCase());

    public static final Codec<Map<Attributes, Rule>> MAP_CODEC =
            Codec.unboundedMap(ATTR_CODEC, RULE_CODEC).xmap(m -> {
                EnumMap<Attributes, Rule> map = new EnumMap<>(Attributes.class);
                map.putAll(m);
                return map;
            }, m -> m);

    public static final Codec<AttributesBalance> CODEC =
            RecordCodecBuilder.create(i -> i.group(
                    MAP_CODEC.fieldOf("attributes").forGetter(AttributesBalance::byAttr)
            ).apply(i, AttributesBalance::new));

    public static AttributesBalance defaults() {
        EnumMap<Attributes, Rule> def = new EnumMap<>(Attributes.class);
        for (Attributes a : Attributes.values()) {
            int cap = (a == Attributes.EVASION) ? 100 : 99;

            double maxHealthPer = (a == Attributes.VITALITY) ? 6.0 : 0.0;
            double regenHpPer   = (a == Attributes.VITALITY) ? 0.06 : 0.0;

            double maxManaPer   = (a == Attributes.SPIRIT) ? 10.0 : 0.0;
            double regenMpPer   = (a == Attributes.SPIRIT) ? 0.08 : 0.0;

            double meleePer     = (a == Attributes.STRENGTH) ? 0.7 : 0.0;
            double spellPer     = (a == Attributes.INTELLIGENCE) ? 0.7 : 0.0;
            double castPer      = (a == Attributes.DEXTERITY) ? 0.5 : 0.0;
            double evasionPer   = (a == Attributes.EVASION) ? 0.5 : 0.0;

            def.put(a, new Rule(cap, maxHealthPer, maxManaPer, regenHpPer, regenMpPer,
                    0.0, evasionPer, meleePer, spellPer, castPer));
        }
        return new AttributesBalance(def);
    }

    public int cap(Attributes a) { return byAttr.getOrDefault(a, defaults().byAttr.get(a)).cap; }

    public String summary() { return "attrs=" + byAttr.size(); }

    public record Rule(
            int cap,
            double maxHealthPer,
            double maxManaPer,
            double regenHpPer,
            double regenMpPer,
            double critChancePer,
            double evasionPer,
            double meleeDamagePer,
            double spellPowerPer,
            double castSpeedPer
    ) {}
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\AttributesBalance.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java -----
package com.doomspire.grimcore.datapack.codec;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

public record LevelsCurve(int maxLevel, double base, double growth) {

    public static final Codec<LevelsCurve> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.INT.fieldOf("max_level").forGetter(LevelsCurve::maxLevel),
            Codec.DOUBLE.fieldOf("base").forGetter(LevelsCurve::base),
            Codec.DOUBLE.fieldOf("growth").forGetter(LevelsCurve::growth)
    ).apply(i, LevelsCurve::new));

    public static LevelsCurve defaults() {
        return new LevelsCurve(50, 100.0, 1.10); // прежние дефолты, пока не пришли данные из датапака
    }

    public String summary() {
        return "max=" + maxLevel + ", base=" + base + ", growth=" + growth;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\LevelsCurve.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java -----
package com.doomspire.grimcore.datapack.codec;

import com.doomspire.grimcore.spell.api.SpellSchool;
import com.doomspire.grimcore.spell.api.SpellTag;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.resources.ResourceLocation;

import java.util.List;
import java.util.Map;

public record SpellTuning(Map<ResourceLocation, Entry> byId) {

    public static final Codec<ResourceLocation> RL_CODEC = ResourceLocation.CODEC;

    public static final Codec<SpellSchool> SCHOOL_CODEC =
            Codec.STRING.xmap(s -> SpellSchool.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<SpellTag> TAG_CODEC =
            Codec.STRING.xmap(s -> SpellTag.valueOf(s.toUpperCase()), v -> v.name().toLowerCase());

    public static final Codec<Scaling> SCALING_CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.DOUBLE.optionalFieldOf("vitality", 0.0).forGetter(Scaling::vitality),
            Codec.DOUBLE.optionalFieldOf("strength", 0.0).forGetter(Scaling::strength),
            Codec.DOUBLE.optionalFieldOf("intelligence", 0.0).forGetter(Scaling::intelligence),
            Codec.DOUBLE.optionalFieldOf("spirit", 0.0).forGetter(Scaling::spirit),
            Codec.DOUBLE.optionalFieldOf("dexterity", 0.0).forGetter(Scaling::dexterity),
            Codec.DOUBLE.optionalFieldOf("evasion", 0.0).forGetter(Scaling::evasion)
    ).apply(i, Scaling::new));

    public static final Codec<Entry> ENTRY_CODEC = RecordCodecBuilder.create(i -> i.group(
            SCHOOL_CODEC.fieldOf("school").forGetter(Entry::school),
            Codec.list(TAG_CODEC).optionalFieldOf("tags", List.of()).forGetter(Entry::tags),
            Codec.INT.optionalFieldOf("base_cost", 0).forGetter(Entry::baseCost),
            Codec.INT.optionalFieldOf("base_cooldown", 0).forGetter(Entry::baseCooldown),
            SCALING_CODEC.optionalFieldOf("scaling", Scaling.ZERO).forGetter(Entry::scaling),
            Codec.list(Codec.STRING).optionalFieldOf("forbidden_weapons", List.of()).forGetter(Entry::forbiddenWeapons),
            Codec.list(Codec.STRING).optionalFieldOf("allowed_armor_tags", List.of()).forGetter(Entry::allowedArmorTags)
    ).apply(i, Entry::new));

    public static final Codec<Map<ResourceLocation, Entry>> MAP_CODEC =
            Codec.unboundedMap(RL_CODEC, ENTRY_CODEC);

    public static final Codec<SpellTuning> CODEC =
            RecordCodecBuilder.create(i -> i.group(
                    MAP_CODEC.fieldOf("spells").forGetter(SpellTuning::byId)
            ).apply(i, SpellTuning::new));

    /** Значения по умолчанию — пустой набор. */
    public static SpellTuning defaults() {
        return new SpellTuning(Map.of());
    }

    /** Короткий summary для логов. */
    public String summary() {
        return "spells=" + (byId != null ? byId.size() : 0);
    }

    // --- types ---

    public record Entry(
            SpellSchool school,
            List<SpellTag> tags,
            int baseCost,
            int baseCooldown,
            Scaling scaling,
            List<String> forbiddenWeapons,
            List<String> allowedArmorTags
    ) {}

    public record Scaling(
            double vitality,
            double strength,
            double intelligence,
            double spirit,
            double dexterity,
            double evasion
    ) {
        public static final Scaling ZERO = new Scaling(0,0,0,0,0,0);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\datapack\codec\SpellTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.combat.DamageContext;
import com.doomspire.grimcore.combat.DamageEngine;
import com.doomspire.grimcore.combat.EnvironmentalDamage;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.DamageTypes;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.living.LivingDamageEvent;

public final class CoreDamageEvents {

    private CoreDamageEvents() {}
    /**
     * Ядро обработки урона. Никакой предметной/спелл-логики здесь нет.
     * Сначала экологический урон (% от MaxHP), затем боевой пайплайн.
     */
    @SubscribeEvent
    public static void onLivingDamage(LivingDamageEvent.Pre event) {
        LivingEntity living = event.getEntity();
        if (living.level().isClientSide() || !living.isAlive()) return;

        // ---------- Экологический урон как % MaxHP ----------
        Float pct = EnvironmentalDamage.percentFor(event.getSource());
        if (pct != null) {
            if (living instanceof ServerPlayer sp) {
                PlayerStatsAttachment ps = sp.getData(ModAttachments.PLAYER_STATS.get());
                if (ps != null) {
                    int max = (int) Math.max(1, ps.getSnapshot().maxHealth);
                    int delta = Math.max(1, Math.round(max * pct));
                    ps.setCurrentHealth(ps.getCurrentHealth() - delta);
                    ps.markDirty();
                    // мгновенный синк HUD
                    GrimcoreNetworking.syncPlayerStats(sp, ps);
                    event.setNewDamage(0f);
                    if (ps.getCurrentHealth() <= 0) killByGeneric(sp);
                }
                return;
            } else {
                MobStatsAttachment ms = living.getData(ModAttachments.MOB_STATS.get());
                if (ms != null) {
                    int max = (int) Math.max(1, ms.getSnapshot().maxHealth);
                    int delta = Math.max(1, Math.round(max * pct));
                    ms.setCurrentHealth(ms.getCurrentHealth() - delta);
                    ms.markDirty();
                    event.setNewDamage(0f);
                    if (ms.getCurrentHealth() <= 0) killByGeneric(living);
                }
                return;
            }
        }

        float amountAfterContent = event.getNewDamage();
        if (amountAfterContent <= 0f) return;

        Entity src = event.getSource() != null ? event.getSource().getEntity() : null;

        // ---------- Цель — игрок: расчёт через DamageEngine ----------
        if (living instanceof ServerPlayer serverPlayer) {
            LivingEntity attacker = (src instanceof LivingEntity le) ? le : null;

            DamageContext ctx = new DamageContext(attacker, serverPlayer);
            if (attacker != null) {
                // если атакует моб с кастомными статами — берём его физический урон
                MobStatsAttachment aStats = attacker.getData(ModAttachments.MOB_STATS.get());
                if (aStats != null) {
                    float phys = aStats.getSnapshot().damage.getOrDefault(DamageTypes.PHYS_MELEE, amountAfterContent);
                    ctx.add(DamageTypes.PHYS_MELEE, phys);
                } else {
                    // иначе fallback на ванильное число
                    ctx.add(DamageTypes.PHYS_MELEE, amountAfterContent);
                }
            } else {
                ctx.add(DamageTypes.PHYS_MELEE, amountAfterContent);
            }

            DamageEngine.resolveAndApply(ctx);
            event.setNewDamage(0f);

            PlayerStatsAttachment att = serverPlayer.getData(ModAttachments.PLAYER_STATS.get());
            if (att != null && att.getCurrentHealth() <= 0) killByGeneric(serverPlayer);
            return;
        }

        // ---------- Цель — моб: прямое применение к кастомному HP ----------
        {
            float base = amountAfterContent;
            if (src instanceof LivingEntity le) {
                MobStatsAttachment aStats = le.getData(ModAttachments.MOB_STATS.get());
                if (aStats != null) {
                    base = aStats.getSnapshot().damage.getOrDefault(DamageTypes.PHYS_MELEE, base);
                }
            }
            MobStatsAttachment tStats = living.getData(ModAttachments.MOB_STATS.get());
            if (tStats != null) {
                tStats.setCurrentHealth(tStats.getCurrentHealth() - Math.round(base));
                tStats.markDirty();
                event.setNewDamage(0f);
                if (tStats.getCurrentHealth() <= 0) killByGeneric(living);
            }
        }
    }

    private static void killByGeneric(LivingEntity entity) {
        entity.setHealth(0f);
        DamageSource genericKill = new DamageSource(
                entity.level().registryAccess()
                        .registryOrThrow(Registries.DAMAGE_TYPE)
                        .getHolderOrThrow(net.minecraft.world.damagesource.DamageTypes.GENERIC_KILL)
        );
        entity.hurt(genericKill, Float.MAX_VALUE);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CoreDamageEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatEffects;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.PlayerEvent;

public final class CorePlayerEvents {
    private CorePlayerEvents() {}

    @SubscribeEvent
    public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
        if (!(event.getEntity() instanceof ServerPlayer player)) return;

        PlayerStatsAttachment stats = player.getData(ModAttachments.PLAYER_STATS.get());
        if (stats == null) return;

        // первичная инициализация «текущих» ресурсов
        var snap = stats.getSnapshot();
        if (stats.getCurrentHealth() <= 0) stats.setCurrentHealth((int) snap.maxHealth);
        if (stats.getCurrentMana()   <= 0) stats.setCurrentMana((int) snap.maxMana);
        stats.markDirty();

        // синк клиенту, чтобы HUD сразу обновился
        GrimcoreNetworking.syncPlayerStats(player, stats);

        // применяем ВСЕ эффекты статов к ванильным атрибутам (DEX→скорость и т.д.)
        StatEffects.applyAll(player);
    }

    @SubscribeEvent
    public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
        if (!(event.getEntity() instanceof ServerPlayer player)) return;

        // после респауна: повторно применяем эффекты (могли слететь с нового Entity)
        StatEffects.applyAll(player);
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\CorePlayerEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.EntityJoinLevelEvent;

public final class MobSpawnInit {
    private MobSpawnInit(){}

    @SubscribeEvent
    public static void onJoin(EntityJoinLevelEvent event) {
        if (event.getLevel().isClientSide()) return;
        if (!(event.getEntity() instanceof LivingEntity living)) return;
        if (living instanceof net.minecraft.world.entity.player.Player) return;

        MobStatsAttachment att = living.getData(ModAttachments.MOB_STATS.get());
        if (att == null) {
            att = new MobStatsAttachment();
            living.setData(ModAttachments.MOB_STATS.get(), att);
        }

        // Применяем data-driven оверрайд (если есть)
        MobTuning.applyPerEntityOverrides((ServerLevel) event.getLevel(), living, att);

        // Инициализируем HP от max
        int max = (int)Math.max(1, att.getSnapshot().maxHealth);
        if (att.getCurrentHealth() <= 0) att.setCurrentHealth(max);
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobSpawnInit.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.LivingEntity;

/**
 * Заглушка-провайдер пер-мобных оверрайдов.
 * На следующем шаге подменим на чтение JSON из datapack.
 */
public final class MobTuning {
    private MobTuning(){}

    public static void applyPerEntityOverrides(ServerLevel level, LivingEntity mob, MobStatsAttachment att) {
        ResourceLocation id = mob.getType().builtInRegistryHolder().key().location();
        // Пример: зомби — пожирнее, паук — ловчее
        if ("minecraft".equals(id.getNamespace()) && "zombie".equals(id.getPath())) {
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.VITALITY, 3);
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.STRENGTH, 2);
        } else if ("minecraft".equals(id.getNamespace()) && "spider".equals(id.getPath())) {
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.EVASION, 5);
            att.addAttribute(com.doomspire.grimcore.stat.Attributes.DEXTERITY, 3);
        }
        att.markDirty();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\MobTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.player.PlayerEvent;
import net.neoforged.neoforge.event.tick.PlayerTickEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Простая серверная регенерация HP/MP с аккумуляторами.
 * - считает реген каждый тик
 * - применяет целые очки, дробную часть копит
 * - синкает на клиент не чаще, чем раз в 10 тиков и только при изменениях
 */
public final class RegenTicker {
    private RegenTicker(){}

    private static final class Accum {
        double hpFrac = 0.0;
        double mpFrac = 0.0;
        int    lastSyncedHp = Integer.MIN_VALUE;
        int    lastSyncedMp = Integer.MIN_VALUE;
        long   lastSyncGameTime = 0L;
    }

    private static final Map<UUID, Accum> ACCUMS = new HashMap<>();
    private static final int SYNC_COOLDOWN_TICKS = 10;

    @SubscribeEvent
    public static void onPlayerTick(PlayerTickEvent.Post e) {
        if (!(e.getEntity() instanceof ServerPlayer sp)) return;
        var level = sp.serverLevel();
        PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (att == null) return;

        StatSnapshot snap = att.getSnapshot();
        // реген/сек из снапшота → реген/тик
        double hpPerTick = Math.max(0.0, snap.regenHealth) / 20.0;
        double mpPerTick = Math.max(0.0, snap.regenMana)   / 20.0;

        var a = ACCUMS.computeIfAbsent(sp.getUUID(), k -> new Accum());
        a.hpFrac += hpPerTick;
        a.mpFrac += mpPerTick;

        int hpGain = (int) Math.floor(a.hpFrac);
        int mpGain = (int) Math.floor(a.mpFrac);
        if (hpGain != 0 || mpGain != 0) {
            a.hpFrac -= hpGain;
            a.mpFrac -= mpGain;

            // применяем к текущим ресурсам
            int beforeHp = att.getCurrentHealth();
            int beforeMp = att.getCurrentMana();
            att.setCurrentHealth(beforeHp + hpGain);
            att.setCurrentMana(beforeMp + mpGain);
            att.markDirty();

            // редкий синк: только если значения изменились и прошло >= cooldown
            boolean hpChanged = att.getCurrentHealth() != a.lastSyncedHp;
            boolean mpChanged = att.getCurrentMana()   != a.lastSyncedMp;
            long now = level.getGameTime();
            if ((hpChanged || mpChanged) && now - a.lastSyncGameTime >= SYNC_COOLDOWN_TICKS) {
                GrimcoreNetworking.syncPlayerStats(sp, att);
                a.lastSyncedHp = att.getCurrentHealth();
                a.lastSyncedMp = att.getCurrentMana();
                a.lastSyncGameTime = now;
            }
        }
    }

    @SubscribeEvent
    public static void onPlayerLoggedOut(PlayerEvent.PlayerLoggedOutEvent e) {
        if (e.getEntity() != null) {
            ACCUMS.remove(e.getEntity().getUUID());
        }
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\RegenTicker.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java -----
package com.doomspire.grimcore.events;

import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.LivingEntity;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.neoforge.common.NeoForge;
import net.neoforged.neoforge.event.entity.living.LivingDeathEvent;

public final class XpEvents {
    private XpEvents(){}

    public static void registerToBus() {
        NeoForge.EVENT_BUS.register(XpEvents.class);
    }

    @SubscribeEvent
    public static void onLivingDeath(LivingDeathEvent event) {
        if (event.getEntity().level().isClientSide()) return;

        LivingEntity dead = event.getEntity();
        if (dead instanceof ServerPlayer) return;

        ServerPlayer killer = null;
        if (event.getSource() != null && event.getSource().getEntity() instanceof ServerPlayer sp) {
            killer = sp;
        } else if (dead.getKillCredit() instanceof ServerPlayer sp2) {
            killer = sp2;
        }
        if (killer == null) return;

        // --- вычисляем "цену" моба ---
        int maxHp;
        MobStatsAttachment mobAtt = dead.getData(ModAttachments.MOB_STATS.get());
        if (mobAtt != null) {
            maxHp = Math.max(1, (int) mobAtt.getSnapshot().maxHealth);
        } else {
            maxHp = Math.max(1, (int) Math.ceil(dead.getMaxHealth()));
        }
        int xp = Math.max(1, Math.round((float) Math.pow(maxHp, 0.80) * 4f));

        // --- применяем на игроке ---
        PlayerProgressAttachment prog = killer.getData(ModAttachments.PLAYER_PROGRESS.get());
        PlayerStatsAttachment stats   = killer.getData(ModAttachments.PLAYER_STATS.get());
        if (prog == null || stats == null) return;

        int levels = prog.addExp(xp);

        if (levels > 0) {
            stats.addUnspentPoints(levels); // выдаём очки за ап-левел
            stats.markDirty();
            GrimcoreNetworking.syncPlayerStats(killer, stats); // мгновенно обновим HUD (очки можно показывать)
        }

        // прогресс: мгновенный клиентский синк (HUD увидит exp/level/cap)
        ProgressNetworking.syncPlayerProgress(killer, prog);
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\events\XpEvents.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.data.ModDataComponents;
import com.doomspire.grimcore.events.CoreDamageEvents;
import com.doomspire.grimcore.events.CorePlayerEvents;
import com.doomspire.grimcore.events.MobSpawnInit;
import com.doomspire.grimcore.events.RegenTicker;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;
import net.neoforged.neoforge.common.NeoForge;

@Mod(Grimcore.MODID)
public final class Grimcore {
    public static final String MODID = "grimcore";
    public Grimcore(IEventBus modEventBus, ModContainer container) {
        // attachments регистрируем на MOD bus
        com.doomspire.grimcore.stat.ModAttachments.ATTACHMENT_TYPES.register(modEventBus);
        ModDataComponents.init(modEventBus);
        // игровые события — на общий шина NeoForge
        NeoForge.EVENT_BUS.register(CoreDamageEvents.class);
        NeoForge.EVENT_BUS.register(CorePlayerEvents.class);
        NeoForge.EVENT_BUS.register(MobSpawnInit.class);
        NeoForge.EVENT_BUS.register(RegenTicker.class);

    }
}




n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\Grimcore.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java -----
package com.doomspire.grimcore.item.comp;
// WIP: template for future extension (do not remove)
@org.jetbrains.annotations.ApiStatus.Experimental

public class BlockBonusComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\BlockBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java -----
package com.doomspire.grimcore.item.comp;
// WIP: template for future extension (do not remove)
@org.jetbrains.annotations.ApiStatus.Experimental

public class ClassRestrictionComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\ClassRestrictionComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java -----
package com.doomspire.grimcore.item.comp;
// WIP: template for future extension (do not remove)
@org.jetbrains.annotations.ApiStatus.Experimental

public class StatBonusComponent {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\item\comp\StatBonusComponent.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java -----
package com.doomspire.grimcore;

import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.net.ProgressNetworking;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

@EventBusSubscriber(modid = Grimcore.MODID) // без bus = ...
public final class ModBusHandlers {
    private ModBusHandlers() {}

    @SubscribeEvent
    public static void onRegisterPayloads(RegisterPayloadHandlersEvent e) {
        GrimcoreNetworking.register(e);
        ProgressNetworking.register(e);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\ModBusHandlers.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

public final class GrimcoreNetworking {
    private GrimcoreNetworking() {}

    public static void register(final RegisterPayloadHandlersEvent event) {
        var registrar = event.registrar(Grimcore.MODID);

        // 1.21.x: используем playToClient / playToServer и CustomPacketPayload.Type
        registrar.playToClient(
                S2C_SyncPlayerStats.TYPE,
                S2C_SyncPlayerStats.STREAM_CODEC,
                (payload, ctx) -> {
                    Player clientPlayer = Minecraft.getInstance().player;
                    if (clientPlayer != null) {
                        clientPlayer.setData(ModAttachments.PLAYER_STATS.get(), payload.att());
                    }
                }
        );
    }

    /** Вызывать на сервере после изменения HP/MP, чтобы HUD сразу обновился. */
    public static void syncPlayerStats(ServerPlayer target, PlayerStatsAttachment att) {
        PacketDistributor.sendToPlayer(target, new S2C_SyncPlayerStats(att));
    }

    // -------- payload (CLIENT-bound) --------
    public record S2C_SyncPlayerStats(PlayerStatsAttachment att) implements CustomPacketPayload {
        public static final Type<S2C_SyncPlayerStats> TYPE =
                new Type<>(ResourceLocation.fromNamespaceAndPath(Grimcore.MODID, "sync_player_stats"));

        public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncPlayerStats> STREAM_CODEC =
                StreamCodec.composite(
                        PlayerStatsAttachment.STREAM_CODEC, S2C_SyncPlayerStats::att,
                        S2C_SyncPlayerStats::new
                );

        @Override
        public Type<? extends CustomPacketPayload> type() {
            return TYPE;
        }
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\GrimcoreNetworking.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java -----
package com.doomspire.grimcore.net;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.client.Minecraft;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;

public final class ProgressNetworking {
    private ProgressNetworking(){}

    public static void register(final RegisterPayloadHandlersEvent event) {
        var registrar = event.registrar(Grimcore.MODID);
        registrar.playToClient(
                S2C_SyncPlayerProgress.TYPE,
                S2C_SyncPlayerProgress.STREAM_CODEC,
                (payload, ctx) -> {
                    var player = Minecraft.getInstance().player;
                    if (player != null) {
                        player.setData(ModAttachments.PLAYER_PROGRESS.get(), payload.att());
                    }
                }
        );
    }

    public static void syncPlayerProgress(ServerPlayer target, PlayerProgressAttachment att) {
        PacketDistributor.sendToPlayer(target, new S2C_SyncPlayerProgress(att));
    }

    public record S2C_SyncPlayerProgress(PlayerProgressAttachment att) implements CustomPacketPayload {
        public static final Type<S2C_SyncPlayerProgress> TYPE =
                new Type<>(ResourceLocation.fromNamespaceAndPath(Grimcore.MODID, "sync_player_progress"));

        public static final StreamCodec<RegistryFriendlyByteBuf, S2C_SyncPlayerProgress> STREAM_CODEC =
                StreamCodec.composite(
                        PlayerProgressAttachment.STREAM_CODEC, S2C_SyncPlayerProgress::att,
                        S2C_SyncPlayerProgress::new
                );

        @Override
        public Type<? extends CustomPacketPayload> type() { return TYPE; }
    }
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\net\ProgressNetworking.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java -----
package com.doomspire.grimcore.runtime;

/**
 * Лёгкий runtime-хаб для каждого игрока.
 * Не сериализуется. Хранится в ConcurrentHashMap на сервере.
 */
public class PlayerRuntimeData {
    public double healthAccumulator = 0.0;
    public double manaAccumulator = 0.0;
    public long lastSyncTick = 0L; // gameTime последнего синка
    public boolean dirty = false;  // пометка для внешних систем
    // Кеши для тяжёлых вычислений
    public int cachedDamage = -1;
    public long cacheUntilTick = 0L;
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeData.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java -----
package com.doomspire.grimcore.runtime;

import net.minecraft.server.level.ServerPlayer;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Простой manager для runtime-данных (сервер).
 */
public final class PlayerRuntimeManager {
    private static final ConcurrentHashMap<UUID, PlayerRuntimeData> RUNTIME = new ConcurrentHashMap<>();

    private PlayerRuntimeManager() {}

    public static PlayerRuntimeData getOrCreate(ServerPlayer player) {
        return RUNTIME.computeIfAbsent(player.getUUID(), uuid -> new PlayerRuntimeData());
    }

    public static PlayerRuntimeData get(ServerPlayer player) {
        return RUNTIME.get(player.getUUID());
    }

    public static void remove(ServerPlayer player) {
        if (player != null) RUNTIME.remove(player.getUUID());
    }

    public static void remove(UUID uuid) {
        if (uuid != null) RUNTIME.remove(uuid);
    }

    public static void clearAll() {
        RUNTIME.clear();
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\runtime\PlayerRuntimeManager.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java -----
package com.doomspire.grimcore.spell.api;

public enum CastResult {
    OK,
    NOT_ENOUGH_MANA,
    ON_COOLDOWN,
    BLOCKED,
    FAIL
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\CastResult.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.resources.ResourceLocation;

import java.util.Set;

/** Базовый контракт любого спелла. Реализации — stateless-singleton. */
public interface Spell {
    /** Уникальный id, например grimfate:fire_bolt */
    ResourceLocation id();

    /** Школа (для фильтров/баланса/синергий). */
    SpellSchool school();

    /** Стоимость маны (базовая, до модификаторов). */
    int manaCost(SpellContext ctx);

    /** Кулдаун в тиках (базовый, до модификаторов). */
    int cooldownTicks(SpellContext ctx);

    /** Основной вызов кастования. Возвращает результат (успешно/недостаточно ресурса/на кулдауне...). */
    CastResult cast(SpellContext ctx);

    Set<SpellTag> tags();
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\Spell.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java -----
package com.doomspire.grimcore.spell.api;

import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.entity.player.Player;
import org.jetbrains.annotations.Nullable;

/** Контекст вызова спелла (сервер). */
public final class SpellContext {
    public final ServerLevel level;
    public final Player caster;
    public final int slot;                  // слот хотбара спеллов; -1 если вне хотбара
    public final double aimX, aimY, aimZ;   // произвольные «наводочные» параметры
    @Nullable public final Object tuning;   // объект tюнинга (деcериализованный из SpellTuning), типизируем позже

    public SpellContext(ServerLevel level, Player caster, int slot, double aimX, double aimY, double aimZ, @Nullable Object tuning) {
        this.level = level;
        this.caster = caster;
        this.slot = slot;
        this.aimX = aimX;
        this.aimY = aimY;
        this.aimZ = aimZ;
        this.tuning = tuning;
    }

    public static SpellContext simple(ServerLevel lvl, Player caster) {
        return new SpellContext(lvl, caster, -1, 0, 0, 0, null);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellContext.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java -----
package com.doomspire.grimcore.spell.api;

public enum SpellSchool {
    FIRE, FROST, LIGHTNING, POISON,
    TECHNIQUE, WARCRY, AURA, ARCANE, SHADOW,
    UTILITY
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellSchool.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java -----
package com.doomspire.grimcore.spell.api;

public enum SpellTag {
    MELEE, RANGED, BUFF, DEBUFF, MOVEMENT, PROJECTILE, AREA,
    CHANNELED, DOT, SHIELD, SUMMON, WEAPON_SKILL
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\api\SpellTag.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltResult.java -----
package com.doomspire.grimcore.spell.autobolt;

public record AutoBoltResult(boolean ok, String reason, int cooldownTicks, float projectileSpeed) {
    public static AutoBoltResult ok(int cd, float speed) { return new AutoBoltResult(true, null, cd, speed); }
    public static AutoBoltResult denied(String why)       { return new AutoBoltResult(false, why, 0, 0.0f); }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltResult.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltService.java -----
package com.doomspire.grimcore.spell.autobolt;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.spell.autobolt.AutoBoltResult;
import com.doomspire.grimcore.spell.autobolt.AutoBoltTuning;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.item.ItemStack;

/**
 * Ядро авто-атаки посоха: валидация/баланс/списание ресурсов.
 * НИЧЕГО не спавним и не играем звуки — это задача grimfate.
 */
public final class AutoBoltService {

    public static AutoBoltResult computeAndConsume(ServerPlayer sp, ItemStack usedStaff) {
        // 1) Достаём статы игрока и их снапшот
        PlayerStatsAttachment stats = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (stats == null) return AutoBoltResult.denied("no_stats");

        StatSnapshot snap = stats.getSnapshot(); // кэшируемый снапшот из аттача

        // 2) Проверяем кулдаун именно на ЭТОТ предмет (пер-айтем)
        if (sp.getCooldowns().isOnCooldown(usedStaff.getItem())) {
            return AutoBoltResult.denied("cooldown");
        }

        // 3) Тюнинг авто-болта из datapack'а (mana cost / cd / projectile speed)
        AutoBoltTuning tuning = AutoBoltTuning.get();

        int manaCost = tuning.manaCost(snap, usedStaff);
        if (stats.getCurrentMana() < manaCost) {
            return AutoBoltResult.denied("not_enough_mana");
        }

        int cdTicks = tuning.cooldownTicks(snap, usedStaff);
        float projSpeed = tuning.projectileSpeed(snap, usedStaff);

        // 4) Списываем ману и синкаем
        stats.setCurrentMana(stats.getCurrentMana() - manaCost);
        stats.markDirty();
        GrimcoreNetworking.syncPlayerStats(sp, stats);

        // 5) Возвращаем параметры для контент-слоя
        return AutoBoltResult.ok(cdTicks, projSpeed);
    }

    private AutoBoltService() {}
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltService.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltTuning.java -----
// src/main/java/com/doomspire/grimcore/spell/autobolt/AutoBoltTuning.java
package com.doomspire.grimcore.spell.autobolt;

import com.doomspire.grimcore.datapack.Balance;
import com.doomspire.grimcore.datapack.codec.SpellTuning;
import com.doomspire.grimcore.stat.StatSnapshot;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
//TODO ДОБАВИТЬ PROJECTILE SPEED
/**
 * Обёртка над data-тюнингом авто-болта.
 * Все данные берутся из Balance/SpellTuning (datapack).
 */
public final class AutoBoltTuning {

    /** ID записи авто-атаки посоха в spells.json */
    public static final ResourceLocation AUTO_BOLT_ID =
            ResourceLocation.fromNamespaceAndPath("grimfate", "auto_bolt_staff");

    /** Временный дефолт, пока projectile_speed не вынесен в SpellTuning. */
    private static final float DEFAULT_PROJECTILE_SPEED = 1.6f;

    public int manaCost(StatSnapshot snap, ItemStack staff) {
        SpellTuning.Entry e = Balance.getSpellEntry(AUTO_BOLT_ID);
        // В дальнейшем сюда можно добавить сниж. стоимости от статов/аффиксов.
        return (e != null) ? Math.max(0, e.baseCost()) : 0;
    }

    public int cooldownTicks(StatSnapshot snap, ItemStack staff) {
        SpellTuning.Entry e = Balance.getSpellEntry(AUTO_BOLT_ID);
        // При необходимости учесть CDR/скорость атаки – делаем это на уровне ядра поверх baseCooldown.
        return (e != null) ? Math.max(0, e.baseCooldown()) : 0;
    }

    public float projectileSpeed(StatSnapshot snap, ItemStack staff) {
        // В SpellTuning projectile_speed пока нет → возвращаем дефолт.
        // Как только поле появится в кодеке/datapack – читаем его отсюда.
        return DEFAULT_PROJECTILE_SPEED;
    }

    public static AutoBoltTuning get() { return new AutoBoltTuning(); }
    private AutoBoltTuning() {}
}



n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\autobolt\AutoBoltTuning.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java -----
package com.doomspire.grimcore.spell;

import com.doomspire.grimcore.spell.api.Spell;
import net.minecraft.resources.ResourceLocation;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Простой реестр спеллов в рантайме.
 * Регистрация выполняется на общих инициализациях мода или при загрузке datapack-тюнинга (в т.ч. референс-спеллы).
 */
public final class GrimSpells {
    private GrimSpells() {}

    private static final Map<ResourceLocation, Spell> REGISTRY = new LinkedHashMap<>();

    public static void register(Spell spell) {
        REGISTRY.put(spell.id(), spell);
    }

    public static Spell get(ResourceLocation id) {
        return REGISTRY.get(id);
    }

    public static Map<ResourceLocation, Spell> all() {
        return Collections.unmodifiableMap(REGISTRY);
    }

    public static void clear() {
        REGISTRY.clear();
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\spell\GrimSpells.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java -----
package com.doomspire.grimcore.stat;

/**
 * Базовые атрибуты, которые игрок получает и распределяет при повышении уровня.
 */
public enum Attributes {
    VITALITY,      // здоровье, реген, бонус к блоку
    STRENGTH,      // физический урон ближнего боя
    INTELLIGENCE,  // урон заклинаний и стихий
    SPIRIT,        // мана, реген маны
    DEXTERITY,     // физический урон дальнего боя
    EVASION,       // шанс уворота
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\Attributes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java -----
package com.doomspire.grimcore.stat;

/**
 * Типы урона. Используются в DamageContext и StatSnapshot.
 */
public enum DamageTypes {
    PHYS_MELEE,
    PHYS_RANGED,
    FIRE,
    FROST,
    LIGHTNING,
    POISON
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\DamageTypes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.Grimcore;
import com.doomspire.grimcore.attach.MobStatsAttachment;
import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.NeoForgeRegistries;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.attachment.AttachmentType;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;

public final class ModAttachments {
    private ModAttachments() {}

    public static final DeferredRegister<AttachmentType<?>> ATTACHMENT_TYPES =
            DeferredRegister.create(NeoForgeRegistries.ATTACHMENT_TYPES, Grimcore.MODID);

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerStatsAttachment>> PLAYER_STATS =
            ATTACHMENT_TYPES.register("player_stats",
                    () -> AttachmentType.builder(PlayerStatsAttachment::new)
                            // персист сохранять позже, когда добавим Codec:
                            // .serialize(YourCodecHere)
                            .sync(PlayerStatsAttachment.STREAM_CODEC) // сеть ОК
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<MobStatsAttachment>> MOB_STATS =
            ATTACHMENT_TYPES.register("mob_stats",
                    () -> AttachmentType.builder(MobStatsAttachment::new)
                            .sync(MobStatsAttachment.STREAM_CODEC) // можно выключить, если на клиенте не нужно
                            .build());

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerProgressAttachment>> PLAYER_PROGRESS =
            ATTACHMENT_TYPES.register("player_progress", () ->
                    AttachmentType.builder(PlayerProgressAttachment::new)
                            .serialize(PlayerProgressAttachment.CODEC)        // автосейв в сейв игрока
                            .sync(PlayerProgressAttachment.STREAM_CODEC)      // авто-синк при замене
                            .build()
            );

    public static final DeferredHolder<AttachmentType<?>, AttachmentType<PlayerLoadoutAttachment>> PLAYER_LOADOUT =
            ATTACHMENT_TYPES.register("player_loadout",
                    () -> AttachmentType.builder(PlayerLoadoutAttachment::new)
                            .serialize(PlayerLoadoutAttachment.CODEC)      // хот-бар сохраняется
                            .sync(PlayerLoadoutAttachment.STREAM_CODEC)     // ВАЖНО: клиент видит изменения
                            .build());
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ModAttachments.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java -----
package com.doomspire.grimcore.stat;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;

/**
 * Чистые данные об уровне игрока.
 * Только хранение + сериализация в NBT/сеть.
 */
public record PlayerProgress(int level, int exp, int expCap) {

    public static final Codec<PlayerProgress> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.INT.fieldOf("level").forGetter(PlayerProgress::level),
            Codec.INT.fieldOf("exp").forGetter(PlayerProgress::exp),
            Codec.INT.fieldOf("exp_cap").forGetter(PlayerProgress::expCap)
    ).apply(instance, PlayerProgress::new));

    public static final StreamCodec<FriendlyByteBuf, PlayerProgress> STREAM_CODEC = StreamCodec.composite(
            ByteBufCodecs.INT, PlayerProgress::level,
            ByteBufCodecs.INT, PlayerProgress::exp,
            ByteBufCodecs.INT, PlayerProgress::expCap,
            PlayerProgress::new
    );

    public static final PlayerProgress DEFAULT = new PlayerProgress(1, 0, 100);

    /**
     * Вспомогательный метод для проверки прогресса на клиенте (HUD).
     */
    public String hudString() {
        return "Lvl " + level + " (" + exp + "/" + expCap + ")";
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\PlayerProgress.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java -----
package com.doomspire.grimcore.stat;

/**
 * Сопротивления урону. Применяются в DamageEngine.
 */
public enum ResistTypes {
    PHYS,
    FIRE,
    FROST,
    LIGHTNING,
    POISON
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\ResistTypes.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;

/**
 * Пересчитывает агрегированные статы (StatSnapshot) на основе атрибутов, предметов и бонусов.
 * Вызов: при изменении атрибутов/уровня/экипировки/эффектов.
 */
public class StatCalculator {

    public static StatSnapshot calculate(PlayerStatsAttachment att) {
        StatSnapshot snapshot = new StatSnapshot();

        // Атрибуты
        int vit = att.getAttribute(Attributes.VITALITY);
        int str = att.getAttribute(Attributes.STRENGTH);
        int intl = att.getAttribute(Attributes.INTELLIGENCE);
        int spirit = att.getAttribute(Attributes.SPIRIT);
        int dex = att.getAttribute(Attributes.DEXTERITY);
        int eva = att.getAttribute(Attributes.EVASION);

        // Примеры формул (значения можно вынести в JSON balance/attributes.json)
        snapshot.maxHealth = 100 + vit * 20;
        snapshot.regenHealth = 1 + vit * 1;

        snapshot.maxMana = 100 + spirit * 30;
        snapshot.regenMana = 1 + spirit * 3;

        snapshot.damage.put(DamageTypes.PHYS_MELEE, str * 0.03f);
        snapshot.damage.put(DamageTypes.PHYS_RANGED, dex * 0.03f);
        snapshot.damage.put(DamageTypes.FIRE, intl * 0.02f);
        snapshot.damage.put(DamageTypes.FROST, intl * 0.02f);
        snapshot.damage.put(DamageTypes.LIGHTNING, intl * 0.02f);
        snapshot.damage.put(DamageTypes.POISON, intl * 0.02f);

        snapshot.critChance = 0f; // 1% за очко
        snapshot.critDamage = 0.5f;        // +50% базово
        snapshot.lifesteal = 0f;
        snapshot.manasteal = 0f;
        snapshot.evasionChance = eva * 0.01f;
        snapshot.moveSpeedPct = dex * 0.25D; // 0.25% за 1 DEX

        // TODO: сюда позже подключим бонусы предметов через StatAggregator

        return snapshot;
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatCalculator.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java -----
package com.doomspire.grimcore.stat;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.ai.attributes.AttributeInstance;
import net.minecraft.world.entity.ai.attributes.AttributeModifier;
import net.minecraft.world.entity.ai.attributes.Attributes;

/**
 * Применяет эффекты из статов к ванильным атрибутам игрока.
 * ЕДИНАЯ точка – тут же и снимаем/обновляем модификаторы.
 */
public final class StatEffects {
    private StatEffects() {}

    // Идентификаторы наших модификаторов (ResourceLocation в 1.21.1)
    public static final ResourceLocation MOVE_SPEED_ID =
            ResourceLocation.fromNamespaceAndPath("grimcore", "dex_move_speed");

    /**
     * Применяет все эффекты заново на основе текущего снапшота статов.
     * Вызывать после любого изменения статов/экипировки и при логине/респауне.
     */
    public static void applyAll(ServerPlayer sp) {
        PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (att == null) return;

        var snap = att.getSnapshot();

        // 1) Ловкость → скорость передвижения: +0.25% за 1 DEX
        applyMoveSpeed(sp, snap.moveSpeedPct);
        // 2) здесь же позже: сила → урон ближнего, интеллект → сила магии и т.п.
    }

    private static void applyMoveSpeed(ServerPlayer sp, double percent) {
        AttributeInstance inst = sp.getAttribute(Attributes.MOVEMENT_SPEED);
        if (inst == null) return;

        // снимаем старый наш модификатор
        inst.removeModifier(MOVE_SPEED_ID);

        // +X% к ИТОГОВОЙ скорости → ADD_MULTIPLIED_TOTAL с долей (0.075 для +7.5%)
        double addTotal = percent / 100.0;
        if (addTotal == 0.0) return;

        AttributeModifier mod = new AttributeModifier(
                MOVE_SPEED_ID,
                addTotal,
                AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL
        );
        inst.addPermanentModifier(mod);
    }
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatEffects.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java -----
package com.doomspire.grimcore.stat;

import java.util.EnumMap;

/**
 * Кэшированное состояние всех характеристик игрока/моба.
 * Используется в боевом движке и GUI.
 */
public class StatSnapshot {
    // Ресурсы
    public float maxHealth;
    public float regenHealth;
    public float maxMana;
    public float regenMana;

    // Урон
    public EnumMap<DamageTypes, Float> damage = new EnumMap<>(DamageTypes.class);

    // Резисты
    public EnumMap<ResistTypes, Float> resistances = new EnumMap<>(ResistTypes.class);

    // Боевые модификаторы
    public float critChance;
    public float critDamage;
    public float lifesteal;
    public float manasteal;
    public float evasionChance;
    public double moveSpeedPct; // бонус к скорости в процентах (например 7.5 = +7.5%)

    public StatSnapshot() {
        for (DamageTypes type : DamageTypes.values()) {
            damage.put(type, 0f);
        }
        for (ResistTypes type : ResistTypes.values()) {
            resistances.put(type, 0f);
        }
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\stat\StatSnapshot.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java -----
package com.doomspire.grimcore.xp;

import com.doomspire.grimcore.datapack.BalanceData;

public final class LevelTable {
    private static final int MAX_LEVEL = 50; // временно, вынесем в конфиг
    private static final int BASE = 100;
    private static final double GROWTH = 1.10; // +10% к требованию на уровень

    private LevelTable() {}

    /** Сколько XP нужно, чтобы перейти с level → level+1 */
    public static int expForLevel(int level) {
        if (level <= 0) return BASE;
        return (int) Math.round(BASE * Math.pow(GROWTH, level - 1));
    }

    /** Сколько XP нужно всего, чтобы достичь этого уровня */
    public static int capForLevel(int level) {
        int sum = 0;
        for (int i = 1; i <= level; i++) {
            sum += expForLevel(i);
        }
        return sum;
    }

    public static int maxLevel() {
        return Math.max(1, BalanceData.levels().maxLevel());
    }

    /** Сколько XP нужно, чтобы достичь уровня L (с начала прогрессии). */
    public static long totalXpForLevel(int level) {
        var lv = BalanceData.levels();
        int L = Math.max(1, Math.min(level, lv.maxLevel()));
        double base = lv.base();
        double growth = lv.growth();
        // Геометрическая прогрессия: base * growth^(L-1) суммой от 1..L-1
        double sum = 0.0;
        double term = base;
        for (int i = 1; i < L; i++) {
            sum += term;
            term *= growth;
        }
        return Math.round(sum);
    }

    /** Сколько XP нужно от L до L+1 (инкрементальный шаг). */
    public static int xpForNextLevel(int level) {
        var lv = BalanceData.levels();
        int L = Math.max(1, Math.min(level, lv.maxLevel()));
        return (int)Math.round(lv.base() * Math.pow(lv.growth(), Math.max(0, L-1)));
    }
}


n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\LevelTable.java -----n
----- BEGIN FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java -----
package com.doomspire.grimcore.xp;

public class Rewards {
}

n----- END FILE: .\grimcore\src\main\java\com\doomspire\grimcore\xp\Rewards.java -----n
----- BEGIN FILE: .\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json -----
{
  "attributes": {
    "vitality": 3,
    "strength": 2,
    "dexterity": 0,
    "intelligence": 0,
    "evasion": 0
  },
  "resistances": {
    "phys": 0.10,
    "fire": 0.00,
    "frost": 0.00,
    "lightning": 0.00,
    "poison": 0.00
  },
  "damage": {
    "phys_melee": 25.0
  }
}

n----- END FILE: .\grimcore\src\main\resources\data\grimcore\mobs\minecraft\zombie.json -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerProgressAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimfate.config.ClientConfig;
import com.doomspire.grimfate.core.Grimfate;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.client.event.RenderGuiEvent;
import net.neoforged.neoforge.client.event.RenderGuiLayerEvent;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.CLIENT)
public final class CustomHudOverlay {
    private CustomHudOverlay() {}

    // ---- текстуры ----
    private static final ResourceLocation HEALTH_BAR_EMPTY =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_bg.png");
    private static final ResourceLocation HEALTH_BAR_FULL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_fill.png");

    private static final ResourceLocation MANA_BAR_EMPTY =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/health_bar_bg.png");
    private static final ResourceLocation MANA_BAR_FULL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/mana_bar_fill.png");

    private static final ResourceLocation XP_BG =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/xp_background.png");
    private static final ResourceLocation XP_FILL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/xp_fill.png");

    private static final ResourceLocation SPELL_CELL =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/spellbar/spell_bar_cell.png");

    // ---- плавные значения ----
    private static final Map<UUID, Float> DISPLAYED_HEALTH = new ConcurrentHashMap<>();
    private static final Map<UUID, Float> DISPLAYED_MANA   = new ConcurrentHashMap<>();
    private static final Map<UUID, Float> DISPLAYED_XP     = new ConcurrentHashMap<>();
    private static final float LERP_ALPHA = 0.20f;

    // ---- хот-бар ----
    private static final int SPELL_CELL_W = 20;
    private static final int SPELL_CELL_H = 20;
    private static final int SPELL_CELL_PAD = 2;

    // ---- какие ванильные слои гасим ----
    private static final Set<ResourceLocation> VANILLA_LAYERS_TO_HIDE = Set.of(
            ResourceLocation.fromNamespaceAndPath("minecraft", "player_health"),
            ResourceLocation.fromNamespaceAndPath("minecraft", "armor_level")
    );

    /** Гасим ванильные слои, чтобы рисовать свои HP/броню/ману/XP. */
    @SubscribeEvent
    public static void onRenderGuiLayerPre(RenderGuiLayerEvent.Pre event) {
        if (VANILLA_LAYERS_TO_HIDE.contains(event.getName())) {
            event.setCanceled(true);
        }
    }

    /** Рисуем наш общий HUD и хот-бар. */
    @SubscribeEvent
    public static void onRenderGui(RenderGuiEvent.Post event) {
        Minecraft mc = Minecraft.getInstance();
        if (mc.player == null || mc.screen != null) return;

        var player = mc.player;

        // --- статы ---
        PlayerStatsAttachment statsAtt = player.getData(ModAttachments.PLAYER_STATS.get());
        if (statsAtt == null) return;

        var snap = statsAtt.getSnapshot();
        int health    = statsAtt.getCurrentHealth();
        int maxHealth = Math.max(1, (int) snap.maxHealth);
        int mana      = statsAtt.getCurrentMana();
        int maxMana   = Math.max(1, (int) snap.maxMana);

        // --- прогресс ---
        PlayerProgressAttachment progressAtt = player.getData(ModAttachments.PLAYER_PROGRESS.get());
        PlayerProgress progress = (progressAtt != null) ? progressAtt.toSnapshot() : PlayerProgress.DEFAULT;

        GuiGraphics gui = event.getGuiGraphics();
        int sw = mc.getWindow().getGuiScaledWidth();
        int sh = mc.getWindow().getGuiScaledHeight();
        UUID uuid = player.getUUID();

        // наши бары
        renderHealthBar(gui, mc, sw, sh, uuid, health, maxHealth);
        renderManaBar(gui, mc, sw, sh, uuid, mana, maxMana);
        renderXpIcon(gui, mc, sw, sh, uuid, progress);

        // хот-бар спеллов
        renderSpellHotbar(gui, mc, sw, sh);
    }

    // -------------------- отрисовка --------------------

    private static void renderHealthBar(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                        UUID uuid, int health, int maxHealth) {
        final int W = 120, H = 12;

        float disp = DISPLAYED_HEALTH.getOrDefault(uuid, (float) health);
        disp += (health - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, maxHealth));
        DISPLAYED_HEALTH.put(uuid, disp);

        int x = sw / 2 + ClientConfig.HEALTH_BAR_X.get();
        int y = sh + ClientConfig.HEALTH_BAR_Y.get();

        gui.blit(HEALTH_BAR_EMPTY, x, y, 0, 0, W, H, W, H);
        int filled = (int) (W * (disp / Math.max(1f, maxHealth)));
        if (filled > 0) gui.blit(HEALTH_BAR_FULL, x, y, 0, 0, filled, H, W, H);

        String text = health + "/" + maxHealth;
        gui.drawString(mc.font, Component.literal(text),
                x + W / 2 - mc.font.width(text) / 2,
                y + (H - mc.font.lineHeight) / 2,
                0xFFFFFF, true);
    }

    private static void renderManaBar(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                      UUID uuid, int mana, int maxMana) {
        final int W = 120, H = 12;

        float disp = DISPLAYED_MANA.getOrDefault(uuid, (float) mana);
        disp += (mana - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, maxMana));
        DISPLAYED_MANA.put(uuid, disp);

        int x = sw / 2 + ClientConfig.MANA_BAR_X.get();
        int y = sh + ClientConfig.MANA_BAR_Y.get();

        gui.blit(MANA_BAR_EMPTY, x, y, 0, 0, W, H, W, H);
        int filled = (int) (W * (disp / Math.max(1f, maxMana)));
        if (filled > 0) gui.blit(MANA_BAR_FULL, x, y, 0, 0, filled, H, W, H);

        String text = mana + "/" + maxMana;
        gui.drawString(mc.font, Component.literal(text),
                x + W / 2 - mc.font.width(text) / 2,
                y + (H - mc.font.lineHeight) / 2,
                0xFFFFFF, true);
    }

    private static void renderXpIcon(GuiGraphics gui, Minecraft mc, int sw, int sh,
                                     UUID uuid, PlayerProgress progress) {
        final int W = 32, H = 32;

        int exp = progress.exp();
        int cap = Math.max(1, progress.expCap());

        float disp = DISPLAYED_XP.getOrDefault(uuid, (float) exp);
        disp += (exp - disp) * LERP_ALPHA;
        disp = Math.max(0, Math.min(disp, cap));
        DISPLAYED_XP.put(uuid, disp);

        int x = sw / 2 + ClientConfig.XP_ICON_X.get();
        int y = sh + ClientConfig.XP_ICON_Y.get();

        gui.blit(XP_BG, x, y, 0, 0, W, H, W, H);

        int filledH = (int) (H * (disp / (float) cap));
        if (filledH > 0) {
            gui.blit(XP_FILL, x, y + (H - filledH), 0, H - filledH, W, filledH, W, H);
        }

        String lvl = String.valueOf(progress.level());
        gui.drawString(mc.font, Component.literal(lvl),
                x + W / 2 - mc.font.width(lvl) / 2,
                y + H / 2 - mc.font.lineHeight / 2,
                0xFFFFFF, true);

        String expTxt = exp + "/" + cap;
        gui.drawString(mc.font, Component.literal(expTxt),
                x + W / 2 - mc.font.width(expTxt) / 2,
                y + H + 2,
                0xFFFFFF, false);
    }

    private static void renderSpellHotbar(GuiGraphics gg, Minecraft mc, int sw, int sh) {
        var p = mc.player;
        var loadout = p.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (loadout == null) return;

        final int CELLS = PlayerLoadoutAttachment.SLOTS; // 6
        final int CELL = 20; // 20x20, без отступов

        // 1) ширина полосы
        int totalW = CELLS * CELL;

        // 2) дефолт по X: центр экрана; по Y: ровно между прицелом (sh/2) и ванильным хотбаром (~sh - 22)
        int vanillaHotbarY = sh - 22;
        int midY = (sh / 2 + vanillaHotbarY) / 2;

        int x0 = (sw - totalW) / 2 + ClientConfig.SPELLBAR_X.get();
        int y0 = midY + ClientConfig.SPELLBAR_Y.get();

        // 3) рисуем все 6 ячеек
        for (int i = 0; i < CELLS; i++) {
            int x = x0 + i * CELL;
            int y = y0;

            // фон ячейки (твоя текстура 20x20)
            gg.blit(SPELL_CELL, x, y, 0, 0, CELL, CELL, CELL, CELL);

            var rl = loadout.get(i);

            // если слот пуст — ничего не пишем (ни хоткей, ни кд)
            if (rl == null) continue;

            // кулдаун
            int cd = loadout.getCooldown(i);
            if (cd > 0) {
                // тёмная маска поверх (оставим как заливку; если захочешь — заменим на текстуру маски)
                gg.fill(x + 1, y + 1, x + CELL - 1, y + CELL - 1, 0x80000000);
                String s = String.valueOf(cd / 20);
                gg.drawString(mc.font, s, x + (CELL - mc.font.width(s)) / 2, y + 5, 0xFFFFFFFF, false);
            }

            // хоткей (буква/цифра) — только если слот не пуст
            String hk = Hotkeys.spellKeyName(i);
            // рисуем в правом нижнем углу, вписываемся в ~8x9px
            int hkX = x + CELL - mc.font.width(hk) - 2;
            int hkY = y + CELL - 9;
            gg.drawString(mc.font, hk, hkX, hkY, 0xFFE6DDAA, false);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\CustomHudOverlay.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java -----
package com.doomspire.grimfate.client.gui;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.AbstractButton;
import net.minecraft.client.gui.components.Tooltip;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.client.event.ScreenEvent;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.CLIENT)
public final class InventoryTabsButtons {
    private InventoryTabsButtons() {}

    private static final ResourceLocation TAB_TEX =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/button_tab.png");
    private static final ResourceLocation ICON_STATS =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/icon_stats.png");
    private static final ResourceLocation ICON_SKILLS =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/icon_skills.png");

    // Держим ссылки для лайв-репозиционирования
    private static SpriteTabButton STATS_BTN;
    private static SpriteTabButton SKILLS_BTN;

    @SubscribeEvent
    public static void onInit(ScreenEvent.Init.Post e) {
        Screen screen = e.getScreen();
        if (!(screen instanceof InventoryScreen inv)) return;

        int left = inv.getGuiLeft();
        int top  = inv.getGuiTop();
        int w    = inv.getXSize();

        int xStats  = left + w + 2;
        int yStats  = top;
        int xSkills = xStats;
        int ySkills = yStats + 22;

        STATS_BTN = new SpriteTabButton(
                xStats, yStats,
                TAB_TEX, 20, 20, 60,
                ICON_STATS, 16, 48, 3, // 3 кадра у icon_stats
                () -> Minecraft.getInstance().setScreen(new InventoryWithStatsScreen(Minecraft.getInstance().player)));
        STATS_BTN.setTooltip(Tooltip.create(Component.translatable("grimfate.ui.stats.open")));

        SKILLS_BTN = new SpriteTabButton(
                xSkills, ySkills,
                TAB_TEX, 20, 20, 60,
                ICON_SKILLS, 16, 80, 5, // 5 кадров у icon_skills
                () -> {
                    var p = Minecraft.getInstance().player;
                    if (p != null) p.displayClientMessage(Component.literal("Древо не нарисовано, но открылось бы и все работает"), true);
                });

        SKILLS_BTN.setTooltip(Tooltip.create(Component.literal("Дерево навыков (WIP)")));

        e.addListener(STATS_BTN);
        e.addListener(SKILLS_BTN);
    }

    // Двигаем кнопки каждый кадр — они «клеятся» к инвентарю и при книге рецептов
    @SubscribeEvent
    public static void onRender(ScreenEvent.Render.Post e) {
        Screen screen = e.getScreen();
        if (!(screen instanceof InventoryScreen inv)) return;
        int left = inv.getGuiLeft();
        int top  = inv.getGuiTop();
        int w    = inv.getXSize();

        if (STATS_BTN != null) {
            STATS_BTN.setX(left + w + 2);
            STATS_BTN.setY(top);
        }
        if (SKILLS_BTN != null) {
            SKILLS_BTN.setX(left + w + 2);
            SKILLS_BTN.setY(top + 22);
        }
    }

    /** Кнопка-«таб»: фон 3 состояния, иконка — анимированный спрайт по времени. */
    static final class SpriteTabButton extends AbstractButton {
        private final ResourceLocation tabTex;
        private final int tabFrameW, tabFrameH, tabTexH;

        private final ResourceLocation iconTex;
        private final int iconFrame;   // размер кадра иконки (обычно 16)
        private final int iconTexH;    // высота текстуры иконки (для blit)
        private final int iconFrames;  // сколько кадров у иконки

        private boolean pressedVisual = false;
        private final Runnable onPress;

        SpriteTabButton(
                int x, int y,
                ResourceLocation tabTex, int tabFrameW, int tabFrameH, int tabTexH,
                ResourceLocation iconTex, int iconFrame, int iconTexH, int iconFrames,
                Runnable onPress
        ) {
            super(x, y, tabFrameW, tabFrameH, Component.empty());
            this.tabTex = tabTex;
            this.tabFrameW = tabFrameW;
            this.tabFrameH = tabFrameH;
            this.tabTexH = tabTexH;

            this.iconTex = iconTex;
            this.iconFrame = iconFrame;
            this.iconTexH = iconTexH;
            this.iconFrames = Math.max(1, iconFrames);

            this.onPress = onPress;
        }

        @Override
        protected void renderWidget(GuiGraphics g, int mouseX, int mouseY, float partialTick) {
            // Фон — по состоянию
            int state = this.isHovered() ? 1 : 0;
            if (pressedVisual) state = 2; // 0/1/2 = normal/hover/pressed
            int vTab = state * tabFrameH;
            g.blit(tabTex, getX(), getY(), 0, vTab, tabFrameW, tabFrameH, tabFrameW, tabTexH);

            // Иконка — анимируем по времени, независимо от состояния
            long ms = System.currentTimeMillis();
            int anim = (int)((ms / 200L) % iconFrames); // ~5 FPS
            int vIcon = anim * iconFrame;

            int ix = getX() + (tabFrameW - 16) / 2;
            int iy = getY() + (tabFrameH - 16) / 2;
            g.blit(iconTex, ix, iy, 0, vIcon, 16, 16, 16, iconTexH);
        }

        @Override
        public void onPress() {
            if (onPress != null) onPress.run();
        }

        @Override
        public boolean mouseClicked(double mx, double my, int button) {
            if (this.isMouseOver(mx, my)) pressedVisual = true;
            return super.mouseClicked(mx, my, button);
        }

        @Override
        public boolean mouseReleased(double mx, double my, int button) {
            pressedVisual = false;
            return super.mouseReleased(mx, my, button);
        }

        @Override
        protected void updateWidgetNarration(NarrationElementOutput narration) {
            this.defaultButtonNarrationText(narration);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryTabsButtons.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java -----
package com.doomspire.grimfate.client.gui;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.PlayerProgress;
import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.network.ModNetworking;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Player;

import java.util.ArrayList;
import java.util.List;

public class InventoryWithStatsScreen extends InventoryScreen {

    // === Твой фон панели 160×224 ===
    private static final int PANEL_W = 160;
    private static final int PANEL_H = 224;
    // Насколько уезжает инвентарь влево, чтобы справа поместилась панель
    private static final int INV_SHIFT = 120;

    private static final ResourceLocation PANEL_BG =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/stats_panel_bg.png");

    // Иконки характеристик-атласа (подключатся, когда положишь PNG)
    private static final ResourceLocation ICONS_TEX =
            ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "textures/gui/stats/stats_icons.png");

    // Панель прижата к правому краю инвентаря
    private int panelX, panelY;

    // Прямоугольные кликабельные зоны «+»
    private final List<AttrBtn> attrButtons = new ArrayList<>();

    public InventoryWithStatsScreen(Player player) {
        super(player);
    }

    @Override
    protected void init() {
        super.init();

        // Сдвигаем инвентарь влево, чтобы справа было место под панель
        this.leftPos -= INV_SHIFT;

        // Инициализируем прямоугольники «+» по макету (координаты внутри панели)
        attrButtons.clear();
        // СТК
        attrButtons.add(makeAttrBtn(Attributes.VITALITY,     34, 22, 54, 22));
        // СИЛ
        attrButtons.add(makeAttrBtn(Attributes.STRENGTH,     34, 35, 54, 35));
        // ДУХ (SPIRIT)
        attrButtons.add(makeAttrBtn(Attributes.SPIRIT,       69, 22, 89, 22));
        // ИНТ
        attrButtons.add(makeAttrBtn(Attributes.INTELLIGENCE, 69, 35, 89, 35));
        // ЛВК
        attrButtons.add(makeAttrBtn(Attributes.DEXTERITY,   105, 22,125, 22));
        // УКЛ
        attrButtons.add(makeAttrBtn(Attributes.EVASION,     105, 35,125, 35));
    }

    private AttrBtn makeAttrBtn(Attributes id, int labelX, int labelY, int valueX, int valueY) {
        // ширина: от (labelX - 2) до valueX, высота 10, по Y прямо под надписью (labelY + 10)
        int x = labelX - 2;
        int y = labelY + 10;
        int w = valueX - x;
        int h = 10;
        return new AttrBtn(id, x, y, w, h);
    }

    @Override
    public void render(GuiGraphics g, int mouseX, int mouseY, float pt) {
        // ВАЖНО: каждый кадр привязываем панель к актуальному положению инвентаря
        panelX = this.leftPos + this.imageWidth + 2;
        panelY = this.topPos;

        // фон экрана
        this.renderBackground(g, mouseX, mouseY, pt);

        // отрисовка инвентаря
        super.render(g, mouseX, mouseY, pt);

        // фон панели 160×224
        g.blit(PANEL_BG, panelX, panelY, 0, 0, PANEL_W, PANEL_H, PANEL_W, PANEL_H);

        // данные игрока
        var p = this.minecraft.player;
        var progressAtt = p.getData(ModAttachments.PLAYER_PROGRESS.get());
        var statsAtt    = p.getData(ModAttachments.PLAYER_STATS.get());

        PlayerProgress prog = progressAtt != null ? progressAtt.toSnapshot() : PlayerProgress.DEFAULT;
        int unspent = statsAtt != null ? statsAtt.getUnspentPoints() : 0;

        // === Шапка (твои координаты) ===
        // "Уровень: X" (мы выводим "Уровень: N" одной строкой)
        String lvlText = "Уровень: " + prog.level();
        g.drawString(this.font, lvlText, panelX + 49, panelY + 7, 0xFFE6DDAA, false);

        // Нераспределённые очки — только число
        g.drawString(this.font, String.valueOf(unspent), panelX + 107, panelY + 7, 0xFFFFFF, false);

        // === Атрибуты (аббревиатуры и значения) ===
        // порядок: СТК, СИЛ, ДУХ, ИНТ, ЛВК, УКЛ
        AttrLine[] lines = new AttrLine[] {
                new AttrLine("СТК", Attributes.VITALITY,     34, 22, 54, 22),
                new AttrLine("СИЛ", Attributes.STRENGTH,     34, 35, 54, 35),
                new AttrLine("ДУХ", Attributes.SPIRIT,       69, 22, 89, 22),
                new AttrLine("ИНТ", Attributes.INTELLIGENCE, 69, 35, 89, 35),
                new AttrLine("ЛВК", Attributes.DEXTERITY,   105, 22,125, 22),
                new AttrLine("УКЛ", Attributes.EVASION,     105, 35,125, 35)
        };
        for (AttrLine L : lines) {
            g.drawString(this.font, L.label, panelX + L.labelX, panelY + L.labelY, 0xFFFFFF, false);
            int val = (statsAtt != null) ? statsAtt.getAttribute(L.id) : 0;
            g.drawString(this.font, String.valueOf(val), panelX + L.valueX, panelY + L.valueY, 0xFFFFFF, false);
        }

        // === Кнопки «+» под атрибутами (прямоугольники) ===
        for (AttrBtn b : attrButtons) {
            int ax = panelX + b.x;
            int ay = panelY + b.y;
            boolean hover = mouseX >= ax && mouseX < ax + b.w && mouseY >= ay && mouseY < ay + b.h;
            int bg = hover ? 0x66FFFFFF : 0x33FFFFFF; // подсветка на hover
            g.fill(ax, ay, ax + b.w, ay + b.h, (bg & 0x00FFFFFF) | 0x33000000);
            // тень верх-низ для псевдокнопки
            g.fill(ax, ay, ax + b.w, ay + 1, 0x55FFFFFF);
            g.fill(ax, ay + b.h - 1, ax + b.w, ay + b.h, 0x22000000);
            // маленький плюсик по центру
            int px = ax + (b.w - this.font.width("+")) / 2;
            int py = ay + (b.h - this.font.lineHeight) / 2 + 1;
            g.drawString(this.font, "+", px, py, 0xFFFFFFFF, false);
        }

        // === Заголовок "Характеристики" по центру в (80, 55) ===
        String hdr = "Характеристики";
        int hdrX = panelX + 80 - this.font.width(hdr) / 2;
        int hdrY = panelY + 55;
        g.drawString(this.font, hdr, hdrX, hdrY, 0xFFE6DDAA, false);

        // === Три колонки: иконка + значение (числа). Иконки подключу, когда положишь PNG. ===
        // Сетка колонок: левый 10px отступ, равные колонки
        final int col1L = panelX + 10,  col1R = panelX + 56;
        final int col2L = panelX + 60,  col2R = panelX + 106;
        final int col3L = panelX + 110, col3R = panelX + 156;
        final int firstY = panelY + 70;
        final int rowStep = 14;

        if (statsAtt != null) {
            var s = statsAtt.getSnapshot();

            // Колонка 1 (базовые): HP, HP/s, MP, MP/s, Speed, AttackSpeed(=0 пока)
            drawStatIconRow(g, "hp_max",        s.maxHealth,       col1L, col1R, firstY + rowStep * 0, ValueFmt.INT);
            drawStatIconRow(g, "hp_regen",      s.regenHealth,     col1L, col1R, firstY + rowStep * 1, ValueFmt.INT);
            drawStatIconRow(g, "mp_max",        s.maxMana,         col1L, col1R, firstY + rowStep * 2, ValueFmt.INT);
            drawStatIconRow(g, "mp_regen",      s.regenMana,       col1L, col1R, firstY + rowStep * 3, ValueFmt.INT);
            drawStatIconRow(g, "move_speed",    s.moveSpeedPct,    col1L, col1R, firstY + rowStep * 4, ValueFmt.PCT);
            drawStatIconRow(g, "attack_speed",  0.0,               col1L, col1R, firstY + rowStep * 5, ValueFmt.INT);

            // Колонка 2 (резисты): phys, fire, frost, lightning, poison, armor(=0 пока)
            drawStatIconRow(g, "res_phys",      s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.PHYS_MELEE, 0f) * 100.0, col2L, col2R, firstY + rowStep * 0, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_fire",      s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FIRE, 0f) * 100.0,       col2L, col2R, firstY + rowStep * 1, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_frost",     s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FROST, 0f) * 100.0,      col2L, col2R, firstY + rowStep * 2, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_lightning", s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.LIGHTNING, 0f) * 100.0,  col2L, col2R, firstY + rowStep * 3, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "res_poison",    s.resistances.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.POISON, 0f) * 100.0,     col2L, col2R, firstY + rowStep * 4, ValueFmt.PCT_RAW);
            drawStatIconRow(g, "armor",         0.0,               col2L, col2R, firstY + rowStep * 5, ValueFmt.INT);

            // Колонка 3 (уроны)
            drawStatIconRow(g, "dmg_melee",     s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.PHYS_MELEE, 0f),  col3L, col3R, firstY + rowStep * 0, ValueFmt.F1);
            drawStatIconRow(g, "dmg_ranged",    s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.PHYS_RANGED, 0f), col3L, col3R, firstY + rowStep * 1, ValueFmt.F1);
            drawStatIconRow(g, "dmg_fire",      s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FIRE, 0f),        col3L, col3R, firstY + rowStep * 2, ValueFmt.F1);
            drawStatIconRow(g, "dmg_frost",     s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.FROST, 0f),       col3L, col3R, firstY + rowStep * 3, ValueFmt.F1);
            drawStatIconRow(g, "dmg_lightning", s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.LIGHTNING, 0f),   col3L, col3R, firstY + rowStep * 4, ValueFmt.F1);
            drawStatIconRow(g, "dmg_poison",    s.damage.getOrDefault(com.doomspire.grimcore.stat.DamageTypes.POISON, 0f),      col3L, col3R, firstY + rowStep * 5, ValueFmt.F1);
        }

        // тултипы можно будет добавить по наведению на области иконок/значений
        this.renderTooltip(g, mouseX, mouseY);
    }

    // Рисуем (пока только число; иконку подключу, когда добавишь PNG)
    private void drawStatIconRow(GuiGraphics g, String iconName, double value,
                                 int colL, int colR, int y, ValueFmt fmt) {
        // Иконка (16×16) слева; если текстуры ещё нет — просто пропустим blit
        int iconX = colL;
        int valRight = colR; // правое выравнивание числа
        try {
            // расчёт кадра анимации: кадр вверх-вниз 16 px
            IconDef def = Icons.get(iconName);
            if (def != null) {
                int frame = def.frames > 1 ? (int)((System.currentTimeMillis() / def.frameMs) % def.frames) : 0;
                int u = def.u;
                int v = def.v + frame * def.h;
                g.blit(ICONS_TEX, iconX, y - 3, u, v, def.w, def.h);
            }
        } catch (Throwable ignored) {
            // если текстуры нет — тихо не рисуем
        }

        String txt = switch (fmt) {
            case INT     -> String.valueOf((int)Math.round(value));
            case F1      -> String.format(java.util.Locale.ROOT, "%.1f", value);
            case PCT     -> String.format(java.util.Locale.ROOT, "+%.2f%%", value);
            case PCT_RAW -> String.format(java.util.Locale.ROOT, "%.0f%%", value);
        };
        int vx = valRight - this.font.width(txt);
        g.drawString(this.font, txt, vx, y, 0xFFFFFF, false);
    }

    private enum ValueFmt { INT, F1, PCT, PCT_RAW }

    // === Клики по «плюсам» ===
    @Override
    public boolean mouseClicked(double mx, double my, int button) {
        // клики по прямоугольникам «+»
        for (AttrBtn b : attrButtons) {
            int ax = panelX + b.x;
            int ay = panelY + b.y;
            if (mx >= ax && mx < ax + b.w && my >= ay && my < ay + b.h) {
                ModNetworking.sendAllocatePoint(b.id.name());
                return true;
            }
        }
        return super.mouseClicked(mx, my, button);
    }

    // ===== Вспомогательные структуры =====

    private record AttrLine(String label, Attributes id, int labelX, int labelY, int valueX, int valueY) {}

    private static final class AttrBtn {
        final Attributes id;
        final int x, y, w, h;
        AttrBtn(Attributes id, int x, int y, int w, int h) {
            this.id = id; this.x = x; this.y = y; this.w = w; this.h = h;
        }
    }

    // ——— Иконки (подключатся, когда добавишь stats_icons.png) ———
    private static final class IconDef {
        final int u, v, w, h, frames, frameMs;
        IconDef(int u, int v, int w, int h, int frames, int frameMs) {
            this.u = u; this.v = v; this.w = w; this.h = h; this.frames = frames; this.frameMs = Math.max(frameMs, 1);
        }
    }
    private static final class Icons {
        private static final java.util.Map<String, IconDef> MAP = new java.util.HashMap<>();
        static {
            // колонка 1
            MAP.put("hp_max",       new IconDef(  0, 0,14,14, 1,0));
            MAP.put("hp_regen",     new IconDef( 16, 0,16,16, 6, 60));
            MAP.put("mp_max",       new IconDef( 32, 0,16,16, 8, 60));
            MAP.put("mp_regen",     new IconDef( 48, 0,16,16, 8, 60));
            MAP.put("move_speed",   new IconDef( 64, 0,16,16, 7,120));
            MAP.put("attack_speed", new IconDef( 80, 0,16,16,10, 20));
            // колонка 2
            MAP.put("res_phys",     new IconDef( 96, 0,16,16, 8, 60));
            MAP.put("res_fire",     new IconDef(112, 0,16,16, 6, 60));
            MAP.put("res_frost",    new IconDef(128, 0,16,16, 6, 60));
            MAP.put("res_lightning",new IconDef(144, 0,16,16, 6, 20));
            MAP.put("res_poison",   new IconDef(160, 0,16,16, 6, 60));
            MAP.put("armor",        new IconDef(176, 0,16,16, 1,  0));
            // колонка 3
            MAP.put("dmg_melee",    new IconDef(192, 0,16,16, 1,  0));
            MAP.put("dmg_ranged",   new IconDef(208, 0,16,16, 1,  0));
            MAP.put("dmg_fire",     new IconDef(224, 0,16,16, 1,  0));
            MAP.put("dmg_frost",    new IconDef(240, 0,16,16, 1,  0));
            MAP.put("dmg_lightning",new IconDef(256, 0,16,16, 1,  0));
            MAP.put("dmg_poison",   new IconDef(272, 0,16,16, 1,  0));
        }
        static IconDef get(String key) { return MAP.get(key); }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\gui\InventoryWithStatsScreen.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java -----
package com.doomspire.grimfate.client;

import com.doomspire.grimfate.network.ModNetworking;
import net.minecraft.client.KeyMapping;
import net.minecraft.client.Minecraft;
import net.minecraft.client.player.LocalPlayer;
import net.neoforged.neoforge.client.event.ClientTickEvent;
import net.neoforged.neoforge.client.event.RegisterKeyMappingsEvent;
import org.lwjgl.glfw.GLFW;

public final class Hotkeys {
    private Hotkeys() {}

    private static final String CAT = "key.categories.grimfate";

    // Только слоты спеллов
    private static final String[] SPELL_IDS = {
            "key.grimfate.spellslot_1",
            "key.grimfate.spellslot_2",
            "key.grimfate.spellslot_3",
            "key.grimfate.spellslot_4",
            "key.grimfate.spellslot_5",
            "key.grimfate.spellslot_6"
    };
    private static final int[] DEFAULTS = {
            GLFW.GLFW_KEY_R, GLFW.GLFW_KEY_F, GLFW.GLFW_KEY_C,
            GLFW.GLFW_KEY_V, GLFW.GLFW_KEY_B, GLFW.GLFW_KEY_N
    };

    private static final KeyMapping[] SPELL_KEYS = new KeyMapping[6];

    private static boolean CREATED = false;
    private static boolean REGISTERED = false;

    private static void ensureCreated() {
        if (CREATED) return;
        CREATED = true;

        for (int i = 0; i < SPELL_KEYS.length; i++) {
            SPELL_KEYS[i] = new KeyMapping(SPELL_IDS[i], DEFAULTS[i], CAT);
        }
    }

    /** MOD-bus: регистрация key mappings. */
    public static void onRegisterKeys(RegisterKeyMappingsEvent e) {
        ensureCreated();
        if (REGISTERED) {
            // уже зарегистрировано
            return;
        }
        REGISTERED = true;

        for (KeyMapping km : SPELL_KEYS) e.register(km);
    }

    /** NeoForge-bus: обработка нажатий. */
    public static void onClientTick(ClientTickEvent.Post e) {
        Minecraft mc = Minecraft.getInstance();
        LocalPlayer p = mc.player;
        if (p == null) return;

        for (int i = 0; i < SPELL_KEYS.length; i++) {
            KeyMapping km = SPELL_KEYS[i];
            if (km != null && km.consumeClick()) {
                ModNetworking.sendCastSpellSlot(i);
            }
        }
    }

    public static String spellKeyName(int idx) {
        if (idx < 0 || idx >= SPELL_KEYS.length || SPELL_KEYS[idx] == null) return "?";
        return SPELL_KEYS[idx].getTranslatedKeyMessage().getString();
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\Hotkeys.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\model\armor\BaseArmorGeoModel.java -----
package com.doomspire.grimfate.client.model.armor;

import com.doomspire.grimfate.item.armor.GenericGeoArmorItem;
import net.minecraft.resources.ResourceLocation;
import org.jetbrains.annotations.Nullable;
import software.bernie.geckolib.model.GeoModel;

public class BaseArmorGeoModel extends GeoModel<GenericGeoArmorItem> {

    @Override
    public ResourceLocation getModelResource(GenericGeoArmorItem animatable) {
        // Берём путь к GEO из Visual (пример: assets/grimfate/geo/armor/copper_armor_set.geo.json)
        return animatable.visual().geo();
    }

    @Override
    public ResourceLocation getTextureResource(GenericGeoArmorItem animatable) {
        // Берём путь к TEXTURE из Visual (пример: assets/grimfate/textures/armor/copper_set.png)
        return animatable.visual().texture();
    }

    @Override
    public @Nullable ResourceLocation getAnimationResource(GenericGeoArmorItem animatable) {
        // Если анимаций нет — можно вернуть null
        return null;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\model\armor\BaseArmorGeoModel.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\render\armor\BaseArmorRenderer.java -----
package com.doomspire.grimfate.client.render.armor;

import com.doomspire.grimfate.client.model.armor.BaseArmorGeoModel;
import com.doomspire.grimfate.item.armor.GenericGeoArmorItem;
import software.bernie.geckolib.renderer.GeoArmorRenderer;

public class BaseArmorRenderer extends GeoArmorRenderer<GenericGeoArmorItem> {
    public BaseArmorRenderer() {
        super(new BaseArmorGeoModel());
        // При необходимости можно связать кости:
        //this.headBone = "armorHead";
        //this.bodyBone = "armorBody";
        //this.rightArmBone = "armorRightArm";
        //this.leftArmBone = "armorLeftArm";
        //this.rightLegBone = "armorRightLeg";
        //this.leftLegBone = "armorLeftLeg";
        //this.rightBootBone = "armorRightBoot";
        //this.leftBootBone = "armorLeftBoot";
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\client\render\armor\BaseArmorRenderer.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponPredicates.java -----
package com.doomspire.grimfate.combat;

import com.doomspire.grimfate.registry.ModDataComponents;
import com.doomspire.grimfate.registry.ModItemTags;
import net.minecraft.world.item.ItemStack;

public final class WeaponPredicates {
    public static boolean isType(ItemStack stack, WeaponType t) {
        var prof = stack.get(ModDataComponents.WEAPON_PROFILE.get());
        if (prof != null) return prof.type() == t;
        return switch (t) {
            case STAFF  -> stack.is(ModItemTags.STAVES);
            case BOW    -> stack.is(ModItemTags.RANGED_WEAPONS);
            case DAGGER -> stack.is(ModItemTags.DAGGERS);
            case SWORD  -> stack.is(ModItemTags.MELEE_WEAPONS);
            case SHIELD -> stack.is(ModItemTags.SHIELDS);
            case GREATSWORD -> stack.is(ModItemTags.MELEE_WEAPONS);
            case HAMMER -> stack.is(ModItemTags.MELEE_WEAPONS);
            default     -> false;
        };
    }
    public static boolean isStaff(ItemStack s)  { return isType(s, WeaponType.STAFF); }
    public static boolean isRanged(ItemStack s) { return isType(s, WeaponType.BOW); }
    public static boolean isMelee(ItemStack s)  { return isType(s, WeaponType.SWORD) || isType(s, WeaponType.DAGGER) || isType(s, WeaponType.AXE)
            || isType(s, WeaponType.GREATSWORD) || isType(s, WeaponType.HAMMER); }
    public static boolean isShield(ItemStack s) { return isType(s, WeaponType.SHIELD); }
    private WeaponPredicates() {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponPredicates.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponType.java -----
package com.doomspire.grimfate.combat;
public enum WeaponType { SWORD, AXE, DAGGER, STAFF, BOW, SHIELD, HAMMER, GREATSWORD }


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\combat\WeaponType.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java -----
package com.doomspire.grimfate.commands;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.commands.arguments.ResourceLocationArgument;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.exceptions.CommandSyntaxException;

import java.util.Collection;

public final class AddSpellCommand {

    private AddSpellCommand() {}

    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        dispatcher.register(Commands.literal("grimfate")
                .then(Commands.literal("addspell")
                        // /grimfate addspell <spell>  — для себя
                        .then(Commands.argument("spell", ResourceLocationArgument.id())
                                .executes(ctx -> {
                                    ServerPlayer self = ctx.getSource().getPlayerOrException();
                                    ResourceLocation rl = ResourceLocationArgument.getId(ctx, "spell");
                                    int added = addToPlayer(self, rl);
                                    if (added > 0) {
                                        ctx.getSource().sendSuccess(() ->
                                                Component.literal("Added spell " + rl + " to " + self.getGameProfile().getName()), true);
                                        return 1;
                                    } else {
                                        ctx.getSource().sendFailure(Component.literal("No free slot for " + rl + " on " + self.getGameProfile().getName()));
                                        return 0;
                                    }
                                }))
                        // /grimfate addspell <targets> <spell>
                        .then(Commands.argument("targets", EntityArgument.players())
                                .then(Commands.argument("spell", ResourceLocationArgument.id())
                                        .executes(ctx -> {
                                            Collection<ServerPlayer> targets = EntityArgument.getPlayers(ctx, "targets");
                                            ResourceLocation rl = ResourceLocationArgument.getId(ctx, "spell");
                                            int total = 0;
                                            for (ServerPlayer sp : targets) {
                                                total += addToPlayer(sp, rl);
                                            }
                                            if (total > 0) {
                                                final int count = total; // effectively final копия для лямбды
                                                ctx.getSource().sendSuccess(() ->
                                                        Component.literal("Added spell " + rl + " to " + count + " player(s)"), true);
                                                return total;
                                            } else {
                                                ctx.getSource().sendFailure(Component.literal("No recipients had a free slot for " + rl));
                                                return 0;
                                            }
                                        })))
                )
        );
    }

    /**
     * Пытается добавить спелл в первый свободный слот лоадаута игрока.
     * Возвращает 1 если добавлено, иначе 0.
     */
    private static int addToPlayer(ServerPlayer sp, ResourceLocation rl) throws CommandSyntaxException {
        PlayerLoadoutAttachment att = sp.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (att == null) {
            return 0;
        }
        for (int i = 0; i < PlayerLoadoutAttachment.SLOTS; i++) {
            if (att.get(i) == null) {
                att.set(i, rl);
                // Триггерим авто-синхронизацию (ModAttachments.PLAYER_LOADOUT должен быть зарегистрирован с .sync(...))
                sp.setData(ModAttachments.PLAYER_LOADOUT.get(), att);
                return 1;
            }
        }
        return 0;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\commands\AddSpellCommand.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\compat\curios\CuriosCompat.java -----
package com.doomspire.grimfate.compat.curios;

import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ItemStack;
import net.neoforged.fml.ModList;

import java.util.function.BiConsumer;

/**
 * Мягкая интеграция с Curios. Сейчас содержит только проверку наличия.
 * Позже сюда добавим реальное чтение экипированных curios-предметов,
 * чтобы складывать их StatBonus-компоненты в агрегатор статов.
 */
public final class CuriosCompat {
    public static final String MODID = "curios";

    private CuriosCompat() {}

    public static boolean isLoaded() {
        return ModList.get().isLoaded(MODID);
    }

    /**
     * Заглушка: когда подключим API-вызовы Curios, сюда добавим обход всех слотов Curios
     * и вызов consumer.accept(stack, slotId).
     */
    public static void forEachEquipped(LivingEntity entity, BiConsumer<ItemStack, String> consumer) {
        if (!isLoaded()) return;
        // TODO: реализовать через CuriosApi при добавлении API в компиляцию агрегатора
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\compat\curios\CuriosCompat.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java -----
package com.doomspire.grimfate.config;

import net.neoforged.fml.config.ModConfig;
import net.neoforged.neoforge.common.ModConfigSpec;

public class ClientConfig {
    public static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();

    public static final ModConfigSpec.IntValue HEALTH_BAR_X;
    public static final ModConfigSpec.IntValue HEALTH_BAR_Y;

    public static final ModConfigSpec.IntValue MANA_BAR_X;
    public static final ModConfigSpec.IntValue MANA_BAR_Y;

    public static final ModConfigSpec.IntValue XP_ICON_X;
    public static final ModConfigSpec.IntValue XP_ICON_Y;

    public static final ModConfigSpec.IntValue SPELLBAR_X;
    public static final ModConfigSpec.IntValue SPELLBAR_Y;

    static {
        SPELLBAR_X = BUILDER
                .comment("Смещение спелбара по X")
                .defineInRange("hud.spellbar_x", -60, -500, 500);

        SPELLBAR_Y = BUILDER
                .comment("Смещение спелбара по X")
                .defineInRange("hud.spellbar_y", -78, -500, 500);

        HEALTH_BAR_X = BUILDER
                .comment("Смещение полоски здоровья по X")
                .defineInRange("hud.health_bar_x", -60, -500, 500);

        HEALTH_BAR_Y = BUILDER
                .comment("Смещение полоски здоровья по Y")
                .defineInRange("hud.health_bar_y", -78, -500, 500);

        MANA_BAR_X = BUILDER
                .comment("Смещение полоски маны по X")
                .defineInRange("hud.mana_bar_x", -60, -500, 500);

        MANA_BAR_Y = BUILDER
                .comment("Смещение полоски маны по Y")
                .defineInRange("hud.mana_bar_y", -65, -500, 500);

        XP_ICON_X = BUILDER
                .comment("Смещение иконки опыта по X")
                .defineInRange("hud.xp_icon_x", -30, -500, 500);

        XP_ICON_Y = BUILDER
                .comment("Смещение иконки опыта по Y")
                .defineInRange("hud.xp_icon_y", -100, -500, 500);
    }

    public static final ModConfigSpec SPEC = BUILDER.build();
}



n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ClientConfig.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java -----
package com.doomspire.grimfate.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * 🔧 ModConfig — централизованный конфиг мода
 * В будущем:
 *  - хранение базовых статов для игроков и мобов
 *  - множители регена/урона
 *  - настройка аффиксов
 *  - редактирование через JSON без пересборки
 */
public class ModConfig {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final File CONFIG_FILE = new File("config/grimfate.json");

    // ===== Пример будущих параметров (пока закомментированы) =====

    // Базовые статы игрока
    // public int basePlayerHealth = 100;
    // public float basePlayerRegen = 0.5f; // 0.5 хп в сек.
    // public int basePlayerMana = 50;
    // public float manaRegenMultiplier = 1.0f;

    // Базовые статы мобов
    // public int baseMobHealth = 50;
    // public float baseMobRegen = 1.0f;

    // Множители урона/защиты
    // public float damageMultiplier = 1.0f;
    // public float defenseMultiplier = 1.0f;

    // Система аффиксов (позже)
    // public float affixDropChance = 0.1f;

    // =============================================================

    private static ModConfig INSTANCE = new ModConfig();

    public static ModConfig get() {
        return INSTANCE;
    }

    /** Загружаем конфиг из JSON */
    public static void load() {
        if (!CONFIG_FILE.exists()) {
            save(); // если файла нет, создаём дефолт
            return;
        }

        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            INSTANCE = GSON.fromJson(reader, ModConfig.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /** Сохраняем конфиг в JSON */
    public static void save() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(INSTANCE, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\config\ModConfig.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java -----
package com.doomspire.grimfate.core;

import java.util.List;

import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.neoforge.common.ModConfigSpec;

// An example config class. This is not required, but it's a good idea to have one to keep your config organized.
// Demonstrates how to use Neo's config APIs
public class Config {
    private static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();

    public static final ModConfigSpec.BooleanValue LOG_DIRT_BLOCK = BUILDER
            .comment("Whether to log the dirt block on common setup")
            .define("logDirtBlock", true);

    public static final ModConfigSpec.IntValue MAGIC_NUMBER = BUILDER
            .comment("A magic number")
            .defineInRange("magicNumber", 42, 0, Integer.MAX_VALUE);

    public static final ModConfigSpec.ConfigValue<String> MAGIC_NUMBER_INTRODUCTION = BUILDER
            .comment("What you want the introduction message to be for the magic number")
            .define("magicNumberIntroduction", "The magic number is... ");

    // a list of strings that are treated as resource locations for items
    public static final ModConfigSpec.ConfigValue<List<? extends String>> ITEM_STRINGS = BUILDER
            .comment("A list of items to log on common setup.")
            .defineListAllowEmpty("items", List.of("minecraft:iron_ingot"), () -> "", Config::validateItemName);

    static final ModConfigSpec SPEC = BUILDER.build();

    private static boolean validateItemName(final Object obj) {
        return obj instanceof String itemName && BuiltInRegistries.ITEM.containsKey(ResourceLocation.parse(itemName));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Config.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java -----
package com.doomspire.grimfate.core;

import com.doomspire.grimfate.commands.AddSpellCommand;
import com.doomspire.grimfate.config.ClientConfig;
import com.doomspire.grimfate.network.ModNetworking;
import com.doomspire.grimfate.registry.ModArmorMaterials;
import com.doomspire.grimfate.registry.ModDataComponents;
import com.doomspire.grimfate.registry.ModEntityTypes;
import com.doomspire.grimfate.registry.ModItems;
import com.mojang.logging.LogUtils;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.CreativeModeTab;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;
import net.neoforged.fml.config.ModConfig;
import net.neoforged.fml.event.lifecycle.FMLCommonSetupEvent;
import net.neoforged.fml.loading.FMLEnvironment;
import net.neoforged.neoforge.event.BuildCreativeModeTabContentsEvent;
import net.neoforged.neoforge.event.RegisterCommandsEvent;
import net.neoforged.neoforge.event.server.ServerStartingEvent;
import net.neoforged.neoforge.registries.DeferredRegister;
import org.slf4j.Logger;

@Mod(Grimfate.MODID)
public class Grimfate {
    public static final String MODID = "grimfate";
    public static final Logger LOGGER = LogUtils.getLogger();

    public static final DeferredRegister<CreativeModeTab> CREATIVE_MODE_TABS =
            DeferredRegister.create(Registries.CREATIVE_MODE_TAB, MODID);

    public Grimfate(IEventBus modEventBus, ModContainer modContainer) {
        // Конфиги
        modContainer.registerConfig(ModConfig.Type.CLIENT, ClientConfig.SPEC);
        modContainer.registerConfig(ModConfig.Type.COMMON, Config.SPEC);

        // Сеть
        modEventBus.addListener(ModNetworking::register);

        // Контент
        CREATIVE_MODE_TABS.register(modEventBus);
        ModItems.init(modEventBus);
        ModEntityTypes.init(modEventBus);
        ModArmorMaterials.ARMOR_MATERIALS.register(modEventBus);
        com.doomspire.grimfate.loot.ModLootModifiers.init(modEventBus);
        ModDataComponents.DATA_COMPONENT_TYPES.register(modEventBus);

        // Фазы
        modEventBus.addListener(this::commonSetup);
        modEventBus.addListener(this::addCreative);

        // Клиент — все клиентские MOD-бус листенеры (вместе с Hotkeys onRegisterKeys)
        if (FMLEnvironment.dist.isClient()) {
                GrimfateClient.registerModBusListeners(modEventBus);
            }
    }

    private void commonSetup(final FMLCommonSetupEvent e) { /* ... */ }

    private void addCreative(final BuildCreativeModeTabContentsEvent e) { /* ... */ }

    @net.neoforged.bus.api.SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent e) {
        AddSpellCommand.register(e.getDispatcher());
    }

    public static ResourceLocation rl(String path) {
        return ResourceLocation.fromNamespaceAndPath(MODID, path);
    }

    @net.neoforged.bus.api.SubscribeEvent
    public void onServerStarting(ServerStartingEvent event) { /* ... */ }
}
n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\Grimfate.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java -----
package com.doomspire.grimfate.core;

import com.doomspire.grimfate.client.Hotkeys;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import com.doomspire.grimfate.registry.ModEntityTypes;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.entity.ThrownItemRenderer;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.client.event.EntityRenderersEvent;
import net.neoforged.neoforge.client.event.RegisterKeyMappingsEvent;
import net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;
import net.neoforged.neoforge.common.NeoForge;

public final class GrimfateClient {
    private GrimfateClient() {}

    public static void registerModBusListeners(IEventBus modBus) {
        modBus.addListener(GrimfateClient::onRegisterRenderers);
        modBus.addListener(GrimfateClient::onClientSetup);
        // Ключевая строка: регистрируем KeyMappings только отсюда
        modBus.addListener(Hotkeys::onRegisterKeys);
    }

    static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers e) {
        e.registerEntityRenderer(ModEntityTypes.BOLT.get(),
                ctx -> new ThrownItemRenderer<BoltProjectileEntity>(ctx, 1.0f, false));
    }

    static void onClientSetup(FMLClientSetupEvent e) {
        Grimfate.LOGGER.info("Client setup OK. User={}", Minecraft.getInstance().getUser().getName());
        // Forge-bus listener для тиков — ровно один раз
        NeoForge.EVENT_BUS.addListener(Hotkeys::onClientTick);
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\core\GrimfateClient.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java -----
package com.doomspire.grimfate.entity;

import net.minecraft.core.particles.ParticleTypes;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.projectile.ThrowableItemProjectile;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.Level;
import net.minecraft.world.phys.HitResult;
import net.minecraft.world.phys.Vec3;

public class BoltProjectileEntity extends ThrowableItemProjectile {

    public BoltProjectileEntity(EntityType<? extends BoltProjectileEntity> type, Level level) {
        super(type, level);
        this.setNoGravity(true);
    }

    public BoltProjectileEntity(Level level, LivingEntity shooter) {
        this(com.doomspire.grimfate.registry.ModEntityTypes.BOLT.get(), level);
        this.setOwner(shooter);
        this.setNoGravity(true);
    }

    /** Отдаём клиенту предмет для ThrownItemRenderer. */
    @Override
    protected Item getDefaultItem() {
        // TODO: заменить на собственный bolt_item для посоха
        return net.minecraft.world.item.Items.AIR;
    }

    /** Старт с небольшим смещением от глаз + задание скорости. */
    public void shootForward(LivingEntity shooter, float speed) {
        Vec3 look = shooter.getLookAngle();
        // смещение на полблока вперёд, чтобы не цеплять свой хитбокс
        this.setPos(
                shooter.getX() + look.x * 0.5,
                shooter.getEyeY() - 0.1 + look.y * 0.5,
                shooter.getZ() + look.z * 0.5
        );
        this.setDeltaMovement(look.normalize().scale(speed));
    }

    @Override
    protected void onHit(HitResult result) {
        super.onHit(result);

        if (!level().isClientSide) {
            // Небольшая частица в месте попадания
            ((ServerLevel) level()).sendParticles(ParticleTypes.CRIT, getX(), getY(), getZ(), 4, 0, 0, 0, 0.0);

            // Урон по цели, если есть «живая» цель
            if (result.getType() == HitResult.Type.ENTITY && getOwner() instanceof LivingEntity owner) {
                var hit = ((net.minecraft.world.phys.EntityHitResult) result).getEntity();
                if (hit instanceof LivingEntity target) {
                    // наш физ-ранжед, простой урон через ванильный DamageSource (ядро боя подключим позже)
                    DamageSource src = level().damageSources().indirectMagic(this, owner); // пока нейтральный DS
                    target.hurt(src, 5.0f); // базовый урон; позже подменим на DamageEngine
                }
            }
            discard();
        }
    }

    @Override
    public void tick() {
        super.tick();
        // Жизнь ~36 блоков при скорости ~1.8 => 20 тиков * 2 сек достаточно
        if (this.tickCount > 40) this.discard();
        if (level().isClientSide) {
            level().addParticle(ParticleTypes.CRIT, getX(), getY(), getZ(), 0, 0, 0);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\entity\BoltProjectileEntity.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java -----
package com.doomspire.grimfate.events;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.world.entity.player.Player;
import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.tick.PlayerTickEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@EventBusSubscriber(modid = Grimfate.MODID, value = Dist.DEDICATED_SERVER) // слушаем только на сервере
public final class LoadoutTickEvents {
    private LoadoutTickEvents() {}

    private static final Map<UUID, Long> LAST_SYNC_TICK = new HashMap<>();
    private static final Map<UUID, Integer> LAST_SUM = new HashMap<>();
    private static final int SYNC_COOLDOWN_TICKS = 10; // ~0.5с при 20 TPS

    @SubscribeEvent
    public static void onPlayerTick(PlayerTickEvent.Post e) {
        Player p = e.getEntity();
        if (p.level().isClientSide) return;

        PlayerLoadoutAttachment att = p.getData(ModAttachments.PLAYER_LOADOUT.get());
        if (att == null) return;

        // 1) уменьшаем кулдауны
        att.tickDown();

        // 2) считаем «суммарный кулдаун», чтобы дешево понимать, изменилось ли что-то
        int sum = 0;
        for (int i = 0; i < PlayerLoadoutAttachment.SLOTS; i++) {
            sum += att.getCooldown(i);
        }

        long now = p.level().getGameTime();
        UUID id = p.getUUID();
        long last = LAST_SYNC_TICK.getOrDefault(id, 0L);
        int prev = LAST_SUM.getOrDefault(id, -1);

        // 3) синкаем только если:
        //  - прошло >= SYNC_COOLDOWN_TICKS тиков
        //  - изменилась агрегированная сумма (включая переход в ноль)
        if ((now - last) >= SYNC_COOLDOWN_TICKS && sum != prev) {
            p.setData(ModAttachments.PLAYER_LOADOUT.get(), att); // триггерит .sync(...) из ModAttachments
            LAST_SYNC_TICK.put(id, now);
            LAST_SUM.put(id, sum);
        }
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\events\LoadoutTickEvents.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\armor\GenericGeoArmorItem.java -----
package com.doomspire.grimfate.item.armor;

import net.minecraft.core.Holder;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ArmorMaterial;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import org.jetbrains.annotations.Nullable;

import software.bernie.geckolib.animatable.GeoItem;
import software.bernie.geckolib.animatable.client.GeoRenderProvider;
import software.bernie.geckolib.animatable.instance.AnimatableInstanceCache;
import software.bernie.geckolib.animation.AnimatableManager;
import software.bernie.geckolib.animation.AnimationController;
import software.bernie.geckolib.animation.PlayState;
import software.bernie.geckolib.constant.DefaultAnimations;
import software.bernie.geckolib.renderer.GeoArmorRenderer;
import software.bernie.geckolib.util.GeckoLibUtil;

import java.util.function.Consumer;

public class GenericGeoArmorItem extends ArmorItem implements GeoItem {
    // <— это нужно ModItems.copperVisual()
    public record Visual(net.minecraft.resources.ResourceLocation geo,
                         net.minecraft.resources.ResourceLocation texture) {}

    private final Visual visual;
    private final AnimatableInstanceCache cache = GeckoLibUtil.createInstanceCache(this);

    public GenericGeoArmorItem(Holder<ArmorMaterial> material, Type type, Properties props, Visual visual) {
        super(material, type, props);
        this.visual = visual;
    }

    public Visual visual() { return visual; }

    @Override
    public AnimatableInstanceCache getAnimatableInstanceCache() { return cache; }

    // Новый API GeckoLib 4.5+: регистрируем провайдера рендера брони
    @Override
    public void createGeoRenderer(Consumer<GeoRenderProvider> consumer) {
        consumer.accept(new GeoRenderProvider() {
            private GeoArmorRenderer<?> renderer;

            @Override
            public <T extends LivingEntity> net.minecraft.client.model.HumanoidModel<?> getGeoArmorRenderer(
                    @Nullable T living, ItemStack stack, @Nullable EquipmentSlot slot,
                    @Nullable net.minecraft.client.model.HumanoidModel<T> original) {
                if (renderer == null) {
                    renderer = new com.doomspire.grimfate.client.render.armor.BaseArmorRenderer();
                }
                return renderer;
            }
        });
    }

    @Override
    public void registerControllers(AnimatableManager.ControllerRegistrar controllers) {
        controllers.add(new AnimationController<>(this, 20, state -> {
            // базовая "idle" анимация предмета брони — если будет нужна
            state.setAnimation(DefaultAnimations.IDLE);

            // Правка: armorSlots есть только у LivingEntity
            var e = state.getData(software.bernie.geckolib.constant.DataTickets.ENTITY);
            if (!(e instanceof LivingEntity living)) return PlayState.STOP;

            // Можно включать всегда, либо доделать проверку полного сета позже
            for (ItemStack s : living.getArmorSlots()) {
                // no-op: проверка на пустоту при желании
            }
            return PlayState.CONTINUE;
        }));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\armor\GenericGeoArmorItem.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\AffixListComponent.java -----
package com.doomspire.grimfate.item.comp;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

import java.util.ArrayList;
import java.util.List;

/** Хранилище выбранных аффиксов (id + роллы). Эффекты подключим позже. */
public record AffixListComponent(List<Entry> entries) {

    public record Entry(String id, List<Float> rolls) {
        public static final Codec<Entry> CODEC = RecordCodecBuilder.create(i -> i.group(
                Codec.STRING.fieldOf("id").forGetter(Entry::id),
                Codec.FLOAT.listOf().fieldOf("rolls").forGetter(Entry::rolls)
        ).apply(i, Entry::new));
    }

    public static final Codec<AffixListComponent> CODEC =
            Entry.CODEC.listOf().xmap(AffixListComponent::new, AffixListComponent::entries);

    /** Для сетевой синхронизации data-component. */
    public static final StreamCodec<RegistryFriendlyByteBuf, AffixListComponent> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public AffixListComponent decode(RegistryFriendlyByteBuf buf) {
                    int n = buf.readVarInt();
                    List<Entry> list = new ArrayList<>(n);
                    for (int i = 0; i < n; i++) {
                        String id = buf.readUtf();
                        int m = buf.readVarInt();
                        List<Float> rolls = new ArrayList<>(m);
                        for (int j = 0; j < m; j++) rolls.add(buf.readFloat());
                        list.add(new Entry(id, rolls));
                    }
                    return new AffixListComponent(list);
                }
                @Override
                public void encode(RegistryFriendlyByteBuf buf, AffixListComponent v) {
                    List<Entry> list = v.entries();
                    buf.writeVarInt(list.size());
                    for (Entry e : list) {
                        buf.writeUtf(e.id());
                        List<Float> rolls = e.rolls();
                        buf.writeVarInt(rolls.size());
                        for (Float r : rolls) buf.writeFloat(r);
                    }
                }
            };
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\AffixListComponent.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\WeaponProfileComponent.java -----
package com.doomspire.grimfate.item.comp;

import com.doomspire.grimfate.combat.WeaponType;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;

public record WeaponProfileComponent(
        WeaponType type,
        boolean twoHanded,
        float baseSpeed,
        float baseDamageMod,
        int affixSlots
) {
    public static final Codec<WeaponProfileComponent> CODEC = RecordCodecBuilder.create(i -> i.group(
            Codec.STRING.xmap(WeaponType::valueOf, WeaponType::name).fieldOf("type").forGetter(WeaponProfileComponent::type),
            Codec.BOOL.fieldOf("two_handed").forGetter(WeaponProfileComponent::twoHanded),
            Codec.FLOAT.fieldOf("base_speed").forGetter(WeaponProfileComponent::baseSpeed),
            Codec.FLOAT.fieldOf("base_damage_mod").forGetter(WeaponProfileComponent::baseDamageMod),
            Codec.INT.fieldOf("affix_slots").forGetter(WeaponProfileComponent::affixSlots)
    ).apply(i, WeaponProfileComponent::new));

    /** Для сетевой синхронизации data-component (NeoForge 1.21.1). */
    public static final StreamCodec<RegistryFriendlyByteBuf, WeaponProfileComponent> STREAM_CODEC =
            new StreamCodec<>() {
                @Override
                public WeaponProfileComponent decode(RegistryFriendlyByteBuf buf) {
                    WeaponType t = WeaponType.valueOf(buf.readUtf());
                    boolean two = buf.readBoolean();
                    float sp = buf.readFloat();
                    float dm = buf.readFloat();
                    int slots = buf.readVarInt();
                    return new WeaponProfileComponent(t, two, sp, dm, slots);
                }
                @Override
                public void encode(RegistryFriendlyByteBuf buf, WeaponProfileComponent v) {
                    buf.writeUtf(v.type().name());
                    buf.writeBoolean(v.twoHanded());
                    buf.writeFloat(v.baseSpeed());
                    buf.writeFloat(v.baseDamageMod());
                    buf.writeVarInt(v.affixSlots());
                }
            };
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\comp\WeaponProfileComponent.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java -----
package com.doomspire.grimfate.item;

import com.doomspire.grimfate.network.payload.C2SCastAutoBoltPayload;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResultHolder;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.UseAnim;
import net.minecraft.world.level.Level;
import net.neoforged.neoforge.network.PacketDistributor;

public class StaffItem extends Item {
    public StaffItem(Properties props) { super(props); }

    @Override
    public int getUseDuration(ItemStack stack, LivingEntity entity) {
        return 72000; // удержание ПКМ
    }

    @Override
    public UseAnim getUseAnimation(ItemStack stack) {
        // анимация «натягивания» как у лука, чтобы была понятна механика удержания
        return UseAnim.BOW;
    }

    @Override
    public InteractionResultHolder<ItemStack> use(Level level, Player player, InteractionHand hand) {
        player.startUsingItem(hand); // удержание ПКМ
        return InteractionResultHolder.consume(player.getItemInHand(hand));
    }

    private static long lastMsMain = 0, lastMsOff = 0;

    @Override
    public void onUseTick(Level level, LivingEntity entity, ItemStack stack, int remainingUseDuration) {
        if (!level.isClientSide) return;

        // нам нужна рука и рейтконтроль — только для игроков
        if (!(entity instanceof Player player)) return;
        InteractionHand hand = player.getUsedItemHand();
        if (hand == null) return;

        int elapsed = getUseDuration(stack, entity) - remainingUseDuration;
        if (elapsed <= 0) return;

        long now = System.currentTimeMillis();
        long last = (hand == InteractionHand.MAIN_HAND) ? lastMsMain : lastMsOff;
        if (now - last < 80) return; // ~каждые 5–6 тиков
        if (hand == InteractionHand.MAIN_HAND) lastMsMain = now; else lastMsOff = now;

        PacketDistributor.sendToServer(new C2SCastAutoBoltPayload(hand));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\item\StaffItem.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java -----
package com.doomspire.grimfate.loot;

import com.doomspire.grimfate.core.Grimfate;
import com.mojang.serialization.MapCodec;
import net.neoforged.neoforge.common.loot.IGlobalLootModifier;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.NeoForgeRegistries;

public final class ModLootModifiers {
    private ModLootModifiers() {}

    // Регистрируем КОДЕКИ модификаторов лута
    public static final DeferredRegister<MapCodec<? extends IGlobalLootModifier>> GLM_SERIALIZERS =
            DeferredRegister.create(NeoForgeRegistries.Keys.GLOBAL_LOOT_MODIFIER_SERIALIZERS, Grimfate.MODID);

    public static final DeferredHolder<MapCodec<? extends IGlobalLootModifier>, MapCodec<RustyRingDropModifier>> RUSTY_RING =
            GLM_SERIALIZERS.register("rusty_ring", () -> RustyRingDropModifier.CODEC);

    public static void init(net.neoforged.bus.api.IEventBus modBus) {
        GLM_SERIALIZERS.register(modBus);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\ModLootModifiers.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\RustyRingDropModifier.java -----
package com.doomspire.grimfate.loot;

import com.doomspire.grimcore.data.ModDataComponents;
import com.doomspire.grimcore.data.component.StatBonusComponent;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.registry.ModItems;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.storage.loot.LootContext;
import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
import net.neoforged.neoforge.common.loot.IGlobalLootModifier;
import net.neoforged.neoforge.common.loot.LootModifier;

import java.util.Map;

/** Простой GLM: с заданным шансом добавляет grimfate:rusty_ring (+1 SPIRIT). */
public class RustyRingDropModifier extends LootModifier {

    public static final MapCodec<RustyRingDropModifier> CODEC = RecordCodecBuilder.mapCodec(inst ->
            LootModifier.codecStart(inst)
                    .and(Codec.DOUBLE.fieldOf("chance").forGetter(m -> m.chance))
                    .apply(inst, RustyRingDropModifier::new)
    );

    private final double chance;

    public RustyRingDropModifier(LootItemCondition[] conditions, double chance) {
        super(conditions);
        this.chance = chance;
    }

    @Override
    public MapCodec<? extends IGlobalLootModifier> codec() { return CODEC; }

    @Override
    protected ObjectArrayList<ItemStack> doApply(ObjectArrayList<ItemStack> generatedLoot, LootContext ctx) {
        // ✅ Ограничиваемся сундуками: имя лут-таблицы должно содержать "chests/"
        ResourceLocation tableId = ctx.getQueriedLootTableId();
        if (tableId == null || !tableId.getPath().contains("chests/")) return generatedLoot;

        if (ctx.getRandom().nextDouble() > this.chance) return generatedLoot;

        ItemStack ring = new ItemStack(ModItems.RUSTY_RING.get());

        // Компонент: +1 к SPIRIT
        ring.set(ModDataComponents.STAT_BONUS.get(),
                new StatBonusComponent(Map.of(Attributes.SPIRIT, 1)));

        generatedLoot.add(ring);
        Grimfate.LOGGER.debug("[GLM] rusty_ring: ADDED to {}", tableId);
        return generatedLoot;
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\loot\RustyRingDropModifier.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\AutoBoltServer.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimfate.combat.WeaponPredicates;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;

/** Серверная реализация авто-болта (ПКМ). ЛКМ — ванильное «копание». */
public final class AutoBoltServer {
    private AutoBoltServer() {}

    public static void tryCast(ServerPlayer sp) {
        ItemStack main = sp.getMainHandItem();
        ItemStack off  = sp.getOffhandItem();

        ItemStack used = ItemStack.EMPTY;
        if (WeaponPredicates.isStaff(main)) used = main;
        else if (WeaponPredicates.isStaff(off)) used = off;
        if (used.isEmpty()) return;

        Item usedItem = used.getItem();
        if (sp.getCooldowns().isOnCooldown(usedItem)) return;

        PlayerStatsAttachment stats = sp.getData(ModAttachments.PLAYER_STATS.get());
        if (stats == null) return;

        // Баланс №0 (в дальнейшем читаем из spells.json: auto_bolt_staff)
        final int manaCost = 8;
        final int cdTicks  = 40;
        final float speed  = 1.6f;

        if (stats.getCurrentMana() < manaCost) return;

        stats.setCurrentMana(stats.getCurrentMana() - manaCost);
        stats.markDirty();
        GrimcoreNetworking.syncPlayerStats(sp, stats);

        var bolt = new BoltProjectileEntity(sp.level(), sp);
        bolt.shootForward(sp, speed);
        sp.level().addFreshEntity(bolt);

        sp.getCooldowns().addCooldown(usedItem, cdTicks);
        sp.level().playSound(null, sp.getX(), sp.getY(), sp.getZ(),
                SoundEvents.WITHER_SHOOT, SoundSource.PLAYERS, 0.6f, 1.0f);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\AutoBoltServer.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimcore.attach.PlayerLoadoutAttachment;
import com.doomspire.grimcore.attach.PlayerStatsAttachment;
import com.doomspire.grimcore.net.GrimcoreNetworking;
import com.doomspire.grimcore.spell.GrimSpells;
import com.doomspire.grimcore.spell.api.CastResult;
import com.doomspire.grimcore.spell.api.SpellContext;
import com.doomspire.grimcore.stat.Attributes;
import com.doomspire.grimcore.stat.ModAttachments;
import com.doomspire.grimcore.stat.StatEffects;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import com.doomspire.grimfate.network.payload.*;
import com.doomspire.grimfate.registry.ModItems;
import net.minecraft.client.Minecraft;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.neoforged.neoforge.network.PacketDistributor;
import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;
import net.neoforged.neoforge.network.handling.IPayloadContext;

import java.util.UUID;

public final class ModNetworking {
    private ModNetworking() {}
    private static boolean REGISTERED = false;
    public static void register(RegisterPayloadHandlersEvent e) {
        if (REGISTERED) return;      // ← защита от повтора (кстати нихуя не помогает никогда)
        REGISTERED = true;
        var reg = e.registrar("grimfate");

        reg.playToServer(C2SAllocatePointPayload.TYPE, C2SAllocatePointPayload.STREAM_CODEC,
                ModNetworking::handleAllocatePoint);

        reg.playToClient(S2CAllocateResultPayload.TYPE, S2CAllocateResultPayload.STREAM_CODEC,
                ModNetworking::handleAllocateResult);

        reg.playToServer(C2SCastSpellSlotPayload.TYPE, C2SCastSpellSlotPayload.STREAM_CODEC,
                ModNetworking::handleCastSpellSlot);

        reg.playToServer(C2SCastAutoBoltPayload.TYPE, C2SCastAutoBoltPayload.STREAM_CODEC,
                (msg, ctx) -> {
                    ctx.enqueueWork(() -> {
                        var sp = (net.minecraft.server.level.ServerPlayer) ctx.player();
                        if (sp == null) return;

                        // 1) Определяем в какой руке посох (серверная валидация)
                        var stack = (msg.hand() == net.minecraft.world.InteractionHand.MAIN_HAND)
                                ? sp.getMainHandItem() : sp.getOffhandItem();

                        if (stack.isEmpty()) return;
                        if (!com.doomspire.grimfate.combat.WeaponPredicates.isStaff(stack)) return;

                        // 2) Ядро: посчитать и списать ресурсы (мана/скейлы/кд/скорость)
                        var result = com.doomspire.grimcore.spell.autobolt.AutoBoltService.computeAndConsume(sp, stack);
                        if (!result.ok()) return;

                        // 3) Контент: спавним снаряд с указанной скоростью
                        var proj = new com.doomspire.grimfate.entity.BoltProjectileEntity(sp.level(), sp);
                        proj.shootForward(sp, result.projectileSpeed());
                        sp.level().addFreshEntity(proj);

                        // 4) Презентация/звук (контент)
                        sp.level().playSound(null, sp.getX(), sp.getY(), sp.getZ(),
                                net.minecraft.sounds.SoundEvents.WITHER_SHOOT,
                                net.minecraft.sounds.SoundSource.PLAYERS, 0.6f, 1.0f);

                        // 5) КД — ставим НА КОНКРЕТНЫЙ ПОСОХ (пер-айтем)
                        sp.getCooldowns().addCooldown(stack.getItem(), result.cooldownTicks());
                    });
                });
    }

    public static void sendAllocatePoint(String attrId) {
        PacketDistributor.sendToServer(new C2SAllocatePointPayload(attrId));
    }

    // === handlers ===

    private static void handleAllocatePoint(C2SAllocatePointPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            PlayerStatsAttachment att = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (att == null) return;

            Attributes attr = PlayerStatsAttachment.parseAttrId(msg.attributeId());
            if (attr == null) return;

            boolean ok = att.tryAllocatePoint(attr);
            int allocated = att.getAttribute(attr);
            int unspent   = att.getUnspentPoints();

            PacketDistributor.sendToPlayer(sp, new S2CAllocateResultPayload(attr.name(), allocated, unspent));

            att.markDirty();
            GrimcoreNetworking.syncPlayerStats(sp, att);

            // ⬇️ ТОЛЬКО вызов ядра — никаких модификаторов в ModNetworking
            StatEffects.applyAll(sp);
        });
    }

    private static void handleAllocateResult(S2CAllocateResultPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            var mc = Minecraft.getInstance();
            if (mc.player == null) return;

            var att = mc.player.getData(ModAttachments.PLAYER_STATS.get());
            if (att != null) {
                Attributes attr = PlayerStatsAttachment.parseAttrId(msg.attributeId());
                if (attr != null) {
                    att.setAttribute(attr, msg.newAllocated());
                }
                att.setUnspentPoints(msg.unspent());
                att.markDirty();
            }
            // UI обновится сам — экран читает свежие данные из Attachment.
        });
    }

    private static void handleCastAutoBolt(IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;
            AutoBoltServer.tryCast(sp); // общая точка для ПКМ-автоатаки
        });
    }

    private static void handleCastSpellSlot(C2SCastSpellSlotPayload msg, IPayloadContext ctx) {
        ctx.enqueueWork(() -> {
            ServerPlayer sp = (ServerPlayer) ctx.player();
            if (sp == null) return;

            int slot = msg.slot();
            if (slot < 0 || slot >= PlayerLoadoutAttachment.SLOTS) return;

            PlayerLoadoutAttachment loadout = sp.getData(ModAttachments.PLAYER_LOADOUT.get());
            if (loadout == null) return;

            if (loadout.getCooldown(slot) > 0) return;

            ResourceLocation spellId = loadout.get(slot);
            if (spellId == null) return;

            var spell = GrimSpells.get(spellId);
            if (spell == null) return;

            var lvl = sp.serverLevel();
            var ctxSpell = new SpellContext(lvl, sp, slot, 0, 0, 0, null);

            int cost = Math.max(0, spell.manaCost(ctxSpell));
            int cd   = Math.max(0, spell.cooldownTicks(ctxSpell));

            var stats = sp.getData(ModAttachments.PLAYER_STATS.get());
            if (stats == null) return;
            if (stats.getCurrentMana() < cost) return;

            CastResult result = spell.cast(ctxSpell);
            if (result == CastResult.OK) {
                stats.setCurrentMana(stats.getCurrentMana() - cost);
                stats.markDirty();
                GrimcoreNetworking.syncPlayerStats(sp, stats);

                loadout.setCooldown(slot, cd);
                sp.setData(ModAttachments.PLAYER_LOADOUT.get(), loadout);
            }
        });
    }

    public static void sendCastSpellSlot(int slot) {
        PacketDistributor.sendToServer(new C2SCastSpellSlotPayload(slot));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\ModNetworking.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SAllocatePointPayload(String attributeId) implements CustomPacketPayload {
    public static final Type<C2SAllocatePointPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_allocate_point"));

    public static final StreamCodec<RegistryFriendlyByteBuf, C2SAllocatePointPayload> STREAM_CODEC =
            StreamCodec.composite(
                    ByteBufCodecs.STRING_UTF8, C2SAllocatePointPayload::attributeId,
                    C2SAllocatePointPayload::new
            );

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SAllocatePointPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastAutoBoltPayload.java -----
package com.doomspire.grimfate.network.payload;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.InteractionHand;

public record C2SCastAutoBoltPayload(InteractionHand hand) implements CustomPacketPayload {
    public static final Type<C2SCastAutoBoltPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, "c2s_cast_auto_bolt"));

    public static final StreamCodec<RegistryFriendlyByteBuf, C2SCastAutoBoltPayload> STREAM_CODEC =
            new StreamCodec<>() {
                @Override public C2SCastAutoBoltPayload decode(RegistryFriendlyByteBuf buf) {
                    return new C2SCastAutoBoltPayload(buf.readEnum(InteractionHand.class));
                }
                @Override public void encode(RegistryFriendlyByteBuf buf, C2SCastAutoBoltPayload v) {
                    buf.writeEnum(v.hand());
                }
            };

    @Override public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastAutoBoltPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record C2SCastSpellSlotPayload(int slot) implements CustomPacketPayload {
    public static final Type<C2SCastSpellSlotPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "c2s_cast_spell_slot"));
    public static final StreamCodec<RegistryFriendlyByteBuf, C2SCastSpellSlotPayload> STREAM_CODEC =
            StreamCodec.of((buf, msg) -> ByteBufCodecs.VAR_INT.encode(buf, msg.slot),
                    buf -> new C2SCastSpellSlotPayload(ByteBufCodecs.VAR_INT.decode(buf)));

    @Override public Type<? extends CustomPacketPayload> type() { return TYPE; }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\C2SCastSpellSlotPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java -----
package com.doomspire.grimfate.network.payload;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record S2CAllocateResultPayload(String attributeId, int newAllocated, int unspent)
        implements CustomPacketPayload {

    public static final Type<S2CAllocateResultPayload> TYPE =
            new Type<>(ResourceLocation.fromNamespaceAndPath("grimfate", "s2c_allocate_result"));

    public static final StreamCodec<RegistryFriendlyByteBuf, S2CAllocateResultPayload> STREAM_CODEC =
            StreamCodec.composite(
                    ByteBufCodecs.STRING_UTF8, S2CAllocateResultPayload::attributeId,
                    ByteBufCodecs.VAR_INT,    S2CAllocateResultPayload::newAllocated,
                    ByteBufCodecs.VAR_INT,    S2CAllocateResultPayload::unspent,
                    S2CAllocateResultPayload::new
            );

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\payload\S2CAllocateResultPayload.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\SpellCastClient.java -----
package com.doomspire.grimfate.network;

import com.doomspire.grimfate.network.payload.C2SCastAutoBoltPayload;
import net.minecraft.world.InteractionHand;
import net.neoforged.neoforge.network.PacketDistributor;

public final class SpellCastClient {
    private SpellCastClient() {}

    /** Вызов авто-болта с указанием руки (используется там, где не хочется лезть в Item.onUseTick). */
    public static void tryCastAutoBoltFromStaff(InteractionHand hand) {
        PacketDistributor.sendToServer(new C2SCastAutoBoltPayload(hand));
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\network\SpellCastClient.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModArmorMaterials.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.core.Holder;
import net.minecraft.core.registries.Registries;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.ArmorMaterial;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.crafting.Ingredient;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

public final class ModArmorMaterials {
    public static final DeferredRegister<ArmorMaterial> ARMOR_MATERIALS =
            DeferredRegister.create(Registries.ARMOR_MATERIAL, Grimfate.MODID);

    private static Map<ArmorItem.Type, Integer> def(int helm, int chest, int legs, int boots) {
        var m = new EnumMap<ArmorItem.Type, Integer>(ArmorItem.Type.class);
        m.put(ArmorItem.Type.HELMET, helm);
        m.put(ArmorItem.Type.CHESTPLATE, chest);
        m.put(ArmorItem.Type.LEGGINGS, legs);
        m.put(ArmorItem.Type.BOOTS, boots);
        return m;
    }

    public static final DeferredHolder<ArmorMaterial, ArmorMaterial> COPPER = ARMOR_MATERIALS.register("copper",
            () -> new ArmorMaterial(
                    /* defense map */ def(2, 6, 5, 2),
                    /* enchantability */ 12,
                    /* equip sound (Holder) */ SoundEvents.ARMOR_EQUIP_GENERIC,
                    /* repair ingredient (Supplier) */ (Supplier<Ingredient>) () -> Ingredient.of(Items.COPPER_INGOT),
                    /* vanilla 2D layers (не нужны для GeckoLib) */ List.<ArmorMaterial.Layer>of(),
                    /* toughness */ 0.0f,
                    /* knockback  */ 0.0f
            ));

    // Возвращаем Holder<ArmorMaterial> для humanoidArmor(...)
    public static Holder<ArmorMaterial> copperHolder() {
        // В NeoForge 21.1 это Holder.Reference<T>
        return COPPER.getDelegate();
        // Если у вас есть getHolder(): return COPPER.getHolder().orElseThrow();
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModArmorMaterials.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModDataComponents.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.item.comp.AffixListComponent;
import com.doomspire.grimfate.item.comp.WeaponProfileComponent;
import net.minecraft.core.component.DataComponentType;
import net.minecraft.core.registries.Registries;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModDataComponents {
    private ModDataComponents() {}

    public static final DeferredRegister<DataComponentType<?>> DATA_COMPONENT_TYPES =
            DeferredRegister.create(Registries.DATA_COMPONENT_TYPE, Grimfate.MODID);

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<WeaponProfileComponent>> WEAPON_PROFILE =
            DATA_COMPONENT_TYPES.register("weapon_profile",
                    () -> DataComponentType.<WeaponProfileComponent>builder()
                            .persistent(WeaponProfileComponent.CODEC)
                            .networkSynchronized(WeaponProfileComponent.STREAM_CODEC)
                            .build());

    public static final DeferredHolder<DataComponentType<?>, DataComponentType<AffixListComponent>> AFFIX_LIST =
            DATA_COMPONENT_TYPES.register("affix_list",
                    () -> DataComponentType.<AffixListComponent>builder()
                            .persistent(AffixListComponent.CODEC)
                            .networkSynchronized(AffixListComponent.STREAM_CODEC)
                            .build());

    public static void init(IEventBus modBus) {
        DATA_COMPONENT_TYPES.register(modBus);
    }
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModDataComponents.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.entity.BoltProjectileEntity;
import net.minecraft.core.registries.Registries;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.MobCategory;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

public final class ModEntityTypes {
    private ModEntityTypes(){}

    public static final DeferredRegister<EntityType<?>> ENTITIES =
            DeferredRegister.create(Registries.ENTITY_TYPE, Grimfate.MODID);

    public static final DeferredHolder<EntityType<?>, EntityType<BoltProjectileEntity>> BOLT =
            ENTITIES.register("bolt", () -> EntityType.Builder
                    .<BoltProjectileEntity>of(BoltProjectileEntity::new, MobCategory.MISC)
                    .sized(0.25f, 0.25f)
                    .clientTrackingRange(64)
                    .updateInterval(2)
                    .build(Grimfate.MODID + ":bolt"));

    public static void init(IEventBus modBus) {
        ENTITIES.register(modBus);
    }
}



n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModEntityTypes.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.combat.WeaponType;
import com.doomspire.grimfate.core.Grimfate;
import com.doomspire.grimfate.item.StaffItem;
import com.doomspire.grimfate.item.armor.GenericGeoArmorItem;
import com.doomspire.grimfate.item.comp.WeaponProfileComponent;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ArmorItem;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.Rarity;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.neoforge.registries.DeferredHolder;
import net.neoforged.neoforge.registries.DeferredRegister;

import static com.doomspire.grimfate.core.Grimfate.rl;

public final class ModItems {
    private ModItems(){}

    public static final DeferredRegister<Item> ITEMS =
            DeferredRegister.create(Registries.ITEM, Grimfate.MODID);

    // Материалы
    public static final DeferredHolder<Item, Item> HARDWOOD_SHAFT = ITEMS.register("hardwood_shaft", () -> new Item(new Item.Properties()));
    public static final DeferredHolder<Item, Item> LINEN_CLOTH    = ITEMS.register("linen_cloth",    () -> new Item(new Item.Properties()));
    public static final DeferredHolder<Item, Item> COPPER_RIVET   = ITEMS.register("copper_rivet",   () -> new Item(new Item.Properties()));

    private static GenericGeoArmorItem.Visual copperVisual() {
        return new GenericGeoArmorItem.Visual(
                rl("geo/armor/copper_armor_set.geo.json"),
                rl("textures/armor/copper_armor_set.png")
        );
    }

    // Броня (каждый предмет — Item с humanoidArmor + GeckoLib визуалом)
    public static final DeferredHolder<Item, Item> COPPER_HELMET = ITEMS.register("copper_helmet",
            () -> new GenericGeoArmorItem(ModArmorMaterials.copperHolder(), ArmorItem.Type.HELMET, new Item.Properties(), copperVisual()));
    public static final DeferredHolder<Item, Item> COPPER_CHESTPLATE = ITEMS.register("copper_chestplate",
            () -> new GenericGeoArmorItem(ModArmorMaterials.copperHolder(), ArmorItem.Type.CHESTPLATE, new Item.Properties(), copperVisual()));
    public static final DeferredHolder<Item, Item> COPPER_LEGGINGS = ITEMS.register("copper_leggings",
            () -> new GenericGeoArmorItem(ModArmorMaterials.copperHolder(), ArmorItem.Type.LEGGINGS, new Item.Properties(), copperVisual()));
    public static final DeferredHolder<Item, Item> COPPER_BOOTS = ITEMS.register("copper_boots",
            () -> new GenericGeoArmorItem(ModArmorMaterials.copperHolder(), ArmorItem.Type.BOOTS, new Item.Properties(), copperVisual()));

    // Оружие/щит (каждому задаём WEAPON_PROFILE через Properties.component)
    public static final DeferredHolder<Item, Item> RUSTY_SWORD = ITEMS.register("rusty_sword",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.SWORD, false, 1.0f, 1.0f, 1))));

    public static final DeferredHolder<Item, Item> COPPER_SWORD = ITEMS.register("copper_sword",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.SWORD, false, 1.05f, 1.1f, 1))));

    public static final DeferredHolder<Item, Item> WEATHERED_STAFF = ITEMS.register("weathered_staff",
            () -> new StaffItem(new Item.Properties()
                    .stacksTo(1)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.STAFF, true, 1.0f, 1.0f, 2))));

    public static final DeferredHolder<Item, Item> APPRENTICE_STAFF = ITEMS.register("apprentice_staff",
            () -> new StaffItem(new Item.Properties()
                    .stacksTo(1)
                    .rarity(Rarity.UNCOMMON)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.STAFF, true, 1.05f, 1.1f, 2))));

    public static final DeferredHolder<Item, Item> SIMPLE_BOW = ITEMS.register("simple_bow",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.BOW, true, 1.0f, 1.0f, 1))));

    public static final DeferredHolder<Item, Item> HUNTERS_BOW = ITEMS.register("hunters_bow",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .rarity(Rarity.UNCOMMON)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.BOW, true, 1.05f, 1.15f, 2))));

    public static final DeferredHolder<Item, Item> WEATHERED_SHIELD = ITEMS.register("weathered_shield",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .component(ModDataComponents.WEAPON_PROFILE.get(),
                            new WeaponProfileComponent(WeaponType.SHIELD, false, 0.9f, 0.0f, 0))));

    public static final DeferredHolder<Item, Item> RUSTY_RING = ITEMS.register("rusty_ring",
            () -> new Item(new Item.Properties()
                    .stacksTo(1)
                    .rarity(Rarity.UNCOMMON)));

    public static void init(IEventBus modBus) {
        ITEMS.register(modBus);
    }
}


n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItems.java -----n
----- BEGIN FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItemTags.java -----
package com.doomspire.grimfate.registry;

import com.doomspire.grimfate.core.Grimfate;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.tags.TagKey;
import net.minecraft.world.item.Item;

public final class ModItemTags {
    public static final TagKey<Item> MELEE_WEAPONS  = tag("melee_weapons");
    public static final TagKey<Item> STAVES         = tag("staves");
    public static final TagKey<Item> RANGED_WEAPONS = tag("ranged_weapons");
    public static final TagKey<Item> DAGGERS        = tag("daggers");
    public static final TagKey<Item> SHIELDS        = tag("shields");

    private static TagKey<Item> tag(String path) {
        return TagKey.create(Registries.ITEM, ResourceLocation.fromNamespaceAndPath(Grimfate.MODID, path));
    }
    private ModItemTags() {}
}

n----- END FILE: .\grimfate\src\main\java\com\doomspire\grimfate\registry\ModItemTags.java -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\copper_armor_set.geo.json -----
{
	"format_version": "1.12.0",
	"minecraft:geometry": [
		{
			"description": {
				"identifier": "geometry.copper_armor_set",
				"texture_width": 128,
				"texture_height": 128,
				"visible_bounds_width": 2,
				"visible_bounds_height": 3.5,
				"visible_bounds_offset": [0, 1.25, 0]
			},
			"bones": [
				{
					"name": "bipedHead",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorHead",
					"parent": "bipedHead",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-5, 29, -5], "size": [10, 4, 10], "pivot": [0, 31, 0], "rotation": [-7.5, 0, 0], "uv": [0, 0]},
						{"origin": [-1, 27, -6], "size": [2, 5, 1], "pivot": [0, 28, -5], "rotation": [-7.5, 0, 0], "uv": [38, 30]}
					]
				},
				{
					"name": "bipedBody",
					"pivot": [0, 24, 0]
				},
				{
					"name": "armorBody",
					"parent": "bipedBody",
					"pivot": [0, 24, 0],
					"cubes": [
						{"origin": [-1.7, 18, -3], "size": [5, 5, 6], "pivot": [-0.7, 21, -2], "rotation": [0, 0, 45], "uv": [28, 37]},
						{"origin": [1.3, 14, -3], "size": [2, 2, 1], "pivot": [-0.7, 17, -2], "rotation": [0, 0, 45], "uv": [22, 43]},
						{"origin": [3, 10.75, -2.5], "size": [2, 14.25, 5], "pivot": [4, 23, 0], "rotation": [0, 0, 45], "uv": [0, 43]},
						{"origin": [-6.5, 23, -2.5], "size": [14.25, 2, 5], "pivot": [-5.5, 23, 0], "rotation": [0, 0, 45], "uv": [0, 30]},
						{"origin": [-4.5, 13, -2.5], "size": [9.25, 1, 5], "uv": [0, 37]}
					]
				},
				{
					"name": "bipedRightArm",
					"pivot": [-5, 22, 0]
				},
				{
					"name": "armorRightArm",
					"parent": "bipedRightArm",
					"pivot": [-5, 22, 0]
				},
				{
					"name": "bipedLeftArm",
					"pivot": [5, 22, 0]
				},
				{
					"name": "armorLeftArm",
					"parent": "bipedLeftArm",
					"pivot": [5, 22, 0]
				},
				{
					"name": "bipedLeftLeg",
					"pivot": [2, 12, 0]
				},
				{
					"name": "armorLeftLeg",
					"parent": "bipedLeftLeg",
					"pivot": [2, 12, 0],
					"cubes": [
						{"origin": [0.25, 6, -3], "size": [2, 2, 2], "pivot": [1.25, 6, -2], "rotation": [0, 0, 45], "uv": [40, 8]},
						{"origin": [-0.5, 5.75, -2.5], "size": [5, 2, 5], "uv": [56, 16]}
					]
				},
				{
					"name": "armorLeftBoot",
					"parent": "bipedLeftLeg",
					"pivot": [2, 12, 0],
					"cubes": [
						{"origin": [-0.5, 0, -3.5], "size": [5, 2, 6], "uv": [56, 8]}
					]
				},
				{
					"name": "bipedRightLeg",
					"pivot": [-2, 12, 0]
				},
				{
					"name": "armorRightLeg",
					"parent": "bipedRightLeg",
					"pivot": [-2, 12, 0],
					"cubes": [
						{"origin": [-3.75, 6, -3], "size": [2, 2, 2], "pivot": [-2.75, 6, -2], "rotation": [0, 0, 45], "uv": [40, 8]},
						{"origin": [-4.5, 5.75, -2.5], "size": [5, 2, 5], "uv": [56, 16]}
					]
				},
				{
					"name": "armorRightBoot",
					"parent": "bipedRightLeg",
					"pivot": [-2, 12, 0],
					"cubes": [
						{"origin": [-4.5, 0, -3.5], "size": [5, 2, 6], "uv": [56, 8]}
					]
				}
			]
		}
	]
}
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\geo\armor\copper_armor_set.geo.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\lang\en_us.json -----
{
  "key.categories.grimfate": "Grimfate",
  "key.grimfate.open_stats": "Open Stats",

  "key.grimfate.spellslot_1": "Spell Slot 1",
  "key.grimfate.spellslot_2": "Spell Slot 2",
  "key.grimfate.spellslot_3": "Spell Slot 3",
  "key.grimfate.spellslot_4": "Spell Slot 4",
  "key.grimfate.spellslot_5": "Spell Slot 5",
  "key.grimfate.spellslot_6": "Spell Slot 6",

  "screen.grimfate.stats_hub": "Attributes",
  "screen.grimfate.unspent": "Unspent points: %s",

  "attr.grimfate.vitality": "Vitality",
  "attr.grimfate.strength": "Strength",
  "attr.grimfate.intelligence": "Intelligence",
  "attr.grimfate.spirit": "Spirit",
  "attr.grimfate.dexterity": "Dexterity",
  "attr.grimfate.evasion": "Evasion",

  "attr.tip.vitality": "Increases health and regen.",
  "attr.tip.strength": "Increases physical melee damage.",
  "attr.tip.intelligence": "Increases spell power.",
  "attr.tip.spirit": "Increases max mana and mana regen.",
  "attr.tip.dexterity": "Increases physical ranged damage.",
  "attr.tip.evasion": "Dodge chance.",

  "grimfate.ui.stats.open": "Open Attributes",

"item.grimfate.rusty_ring": "Rusty Ring"
}


n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\lang\en_us.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json -----
{
  "key.categories.grimfate": "GrimFate",
  "key.grimfate.open_stats": "Открыть характеристики",

  "key.grimfate.spellslot_1": "Слот умения 1",
  "key.grimfate.spellslot_2": "Слот умения 2",
  "key.grimfate.spellslot_3": "Слот умения 3",
  "key.grimfate.spellslot_4": "Слот умения 4",
  "key.grimfate.spellslot_5": "Слот умения 5",
  "key.grimfate.spellslot_6": "Слот умения 6",

  "screen.grimfate.stats_hub": "Attributes",
  "screen.grimfate.unspent": "Unspent points: %s",

  "attr.grimfate.vitality": "Vitality",
  "attr.grimfate.strength": "Strength",
  "attr.grimfate.intelligence": "Intelligence",
  "attr.grimfate.spirit": "Spirit",
  "attr.grimfate.dexterity": "Dexterity",
  "attr.grimfate.evasion": "Evasion",

  "attr.tip.vitality": "Increases health and regen.",
  "attr.tip.strength": "Increases physical melee damage.",
  "attr.tip.intelligence": "Increases spell power.",
  "attr.tip.spirit": "Increases max mana and mana regen.",
  "attr.tip.dexterity": "Increases physical ranged damage.",
  "attr.tip.evasion": "Dodge chance.",

  "grimfate.ui.stats.open": "Открыть атрибуты",

  "item.grimfate.rusty_ring": "Rusty Ring"
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\lang\ru_ru.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_boots.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_boots" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_boots.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_chestplate.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_chestplate" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_chestplate.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_helmet.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_helmet" } }

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_helmet.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_leggins.json -----
{ "parent": "item/generated", "textures": { "layer0": "grimfate:item/copper_leggins" } }
n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\copper_leggins.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rusty_ring.json -----
{
  "parent": "item/generated",
  "textures": {
    "layer0": "grimfate:item/rusty_ring"
  }
}

n----- END FILE: .\grimfate\src\main\resources\assets\grimfate\models\item\rusty_ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\slot_types\necklace.json -----
{
  "name": "necklace",
  "size": 1,
  "cosmetic": false
}

n----- END FILE: .\grimfate\src\main\resources\data\curios\slot_types\necklace.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\curios\slot_types\ring.json -----
{
  "name": "ring",
  "size": 2,
  "cosmetic": false
}

n----- END FILE: .\grimfate\src\main\resources\data\curios\slot_types\ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\attributes.json -----
{
  "attributes": {
    "vitality":     { "cap": 99, "max_health_per": 6.0, "regen_hp_per": 0.06 },
    "strength":     { "cap": 99, "melee_damage_per": 0.7 },
    "intelligence": { "cap": 99, "spell_power_per": 0.7 },
    "spirit":       { "cap": 99, "max_mana_per": 10.0, "regen_mp_per": 0.08 },
    "dexterity":    { "cap": 99, "cast_speed_per": 0.5 },
    "evasion":      { "cap": 100, "evasion_per": 0.5 }
  }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\attributes.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\levels.json -----
{
  "max_level": 50,
  "base": 100.0,
  "growth": 1.10
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\levels.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\balance\spells.json -----
{
  "auto_bolt_staff": {
    "type": "projectile",
    "damage_type": "phys_ranged",
    "base_damage": 22,
    "mana_cost": 8,
    "cooldown_ticks": 40,
    "speed": 1.6,
    "range": 32,
    "requires_type": "STAFF",
    "scaling": {
      "INT": 0.25
    }
  },
  "spells": {
    "grimfate:knight_dash": {
      "school": "TECHNIQUE",
      "tags": ["MOVEMENT"],
      "base_cost": 8,
      "base_cooldown": 60,
      "scaling": { "dexterity": 0.7 }
    }
  }
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\balance\spells.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\rusty_ring.json -----
{
  "type": "grimfate:rusty_ring",
  "chance": 0.95,
  "conditions": [
    { "condition": "random_chance", "chance": 1.0 }
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\loot_modifiers\rusty_ring.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\apprentice_staff.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": ["S  ", " R ", "W  "],
  "key": {
    "S": {"item": "grimfate:linen_cloth"},
    "R": {"item": "grimfate:copper_rivet"},
    "W": {"item": "grimfate:hardwood_shaft"}
  },
  "result": {"id": "grimfate:apprentice_staff", "count": 1}
}
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\apprentice_staff.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\copper_sword.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": [" S ", " R ", "W  "],
  "key": {
    "S": {"item": "grimfate:linen_cloth"},
    "R": {"item": "grimfate:copper_rivet"},
    "W": {"item": "grimfate:hardwood_shaft"}
  },
  "result": {"id": "grimfate:apprentice_staff", "count": 1}
}
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\copper_sword.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\recipes\hunters_bow.json -----
{
  "type": "minecraft:crafting_shaped",
  "pattern": ["  S", " R ", "W  "],
  "key": {
    "S": {"item": "grimfate:linen_cloth"},
    "R": {"item": "grimfate:copper_rivet"},
    "W": {"item": "grimfate:hardwood_shaft"}
  },
  "result": {"id": "grimfate:apprentice_staff", "count": 1}
}
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\recipes\hunters_bow.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\boots.json -----
{ "values": ["grimfate:copper_boots"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\boots.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\chest.json -----
{ "values": ["grimfate:copper_chestplate"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\chest.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\cloth.json -----
{ "values": [] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\cloth.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\helm.json -----
{ "values": ["grimfate:copper_helmet"] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\helm.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\leather.json -----
{ "values": [] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\leather.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\legs.json -----
{ "values": ["grimfate:copper_chestplate"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\legs.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\plate.json -----
{ "values": ["grimfate:copper_helmet", "grimfate:copper_chestplate", "grimfate:copper_leggings", "grimfate:copper_boots"] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\armor\plate.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\daggers.json -----
{ "replace": false, "values": [] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\daggers.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\melee_weapons.json -----
{ "replace": false, "values": ["grimfate:rusty_sword", "grimfate:copper_sword"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\melee_weapons.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\ranged_weapons.json -----
{ "replace": false, "values": ["grimfate:simple_bow", "grimfate:hunters_bow"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\ranged_weapons.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\archer.json -----
{ "values": [] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\archer.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\mage.json -----
{ "values": [] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\mage.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\melee.json -----
{ "values": [] }

n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\role\melee.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\shields.json -----
{ "replace": false, "values": ["grimfate:weathered_shield"] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\shields.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\staves.json -----
{
  "replace": false,
  "values": [
    "grimfate:weathered_staff",
    "grimfate:apprentice_staff"
  ]
}


n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\staves.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\two_handed.json -----
{ "replace": false, "values": [] }
n----- END FILE: .\grimfate\src\main\resources\data\grimfate\tags\items\two_handed.json -----n
----- BEGIN FILE: .\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json -----
{
  "replace": false,
  "entries": [
    "grimfate:rusty_ring"
  ]
}

n----- END FILE: .\grimfate\src\main\resources\data\neoforge\loot_modifiers\global_loot_modifiers.json -----n
